

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2808425287808210"
     crossorigin="anonymous"></script>
  <link rel="apple-touch-icon" sizes="76x76" href="/Blog/img/favicon.ico">
  <link rel="icon" href="/Blog/img/favicon.ico">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Daolin">
  <meta name="keywords" content="">
  
    <meta name="description" content="Combinational Theory回顾: 如果我们有无限的硬币 分别代表 5, 10, 25, 50, 100 有几种凑齐 200 的方法? 例如: 100 + 50 + 10 + 10 + 10 + 10 + 10 &#x3D; 200   我们通常会限制 paration 中允许出现的元素 例如:   Combinatorial Properties of PartitionsConjugate">
<meta property="og:type" content="article">
<meta property="og:title" content="combinational theory">
<meta property="og:url" content="https://daolinzhou.github.io/2024/01/10/combinational-theory/">
<meta property="og:site_name" content="Daolin&#39;s Repository">
<meta property="og:description" content="Combinational Theory回顾: 如果我们有无限的硬币 分别代表 5, 10, 25, 50, 100 有几种凑齐 200 的方法? 例如: 100 + 50 + 10 + 10 + 10 + 10 + 10 &#x3D; 200   我们通常会限制 paration 中允许出现的元素 例如:   Combinatorial Properties of PartitionsConjugate">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/math443/surjection_8.png">
<meta property="article:published_time" content="2024-01-11T04:41:41.000Z">
<meta property="article:modified_time" content="2024-03-28T19:37:18.469Z">
<meta property="article:author" content="Daolin">
<meta property="article:tag" content="数学">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://daolinzhou.github.io/Blog/intro/math443/surjection_8.png">
  
  
  <title>combinational theory - Daolin&#39;s Repository</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/Blog/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"daolinzhou.github.io","root":"/Blog/","version":"1.8.14","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/Blog/local-search.xml"};
  </script>
  <script  src="/Blog/js/utils.js" ></script>
  <script  src="/Blog/js/color-schema.js" ></script>
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.1.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/Blog/">
      <strong>Daolin&#39;s Repo</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/Blog/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/Blog/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/Blog/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/Blog/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/Blog/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/Blog/intro/imprinting2.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="combinational theory">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2024-01-10 20:41" pubdate>
        2024年1月10日 晚上
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      19k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      159 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">combinational theory</h1>
            
            <div class="markdown-body">
              <link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><span id="more"></span>
<h1 id="Combinational-Theory"><a href="#Combinational-Theory" class="headerlink" title="Combinational Theory"></a>Combinational Theory</h1><p>回顾: 如果我们有无限的硬币 分别代表 5, 10, 25, 50, 100</p>
<p>有几种凑齐 200 的方法?</p>
<p>例如: 100 + 50 + 10 + 10 + 10 + 10 + 10 = 200</p>
<p><br></p>
<p><img src="/Blog/intro/math443/paration.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>我们通常会限制 paration 中允许出现的元素</p>
<p>例如:</p>
<p><img src="/Blog/intro/math443/paration_1.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<h2 id="Combinatorial-Properties-of-Partitions"><a href="#Combinatorial-Properties-of-Partitions" class="headerlink" title="Combinatorial Properties of Partitions"></a>Combinatorial Properties of Partitions</h2><p><strong>Conjugate of a paration</strong></p>
<p>当我们有一个 partition 时, 可以将 Ferrers diagram 进行翻转</p>
<p><img src="/Blog/intro/math443/paration_2.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>一个 paration 是 self-conjugate 如果它的翻转和自己一样</p>
<p>A partition is self-conjugate if it is its own conjugate.</p>
<p><br></p>
<p><strong>Durfee square of a partition</strong></p>
<p><img src="/Blog/intro/math443/paration_3.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p>如果我们让A 是一个 self-conjugate 的 paration of n</p>
<p>让 B 是一个 paration of n 同时 每个paration 都是 odd, distinct part</p>
<p><strong>Theorem: The set A is in bijection with B for all n</strong></p>
<p><img src="/Blog/intro/math443/paration_4.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p><strong>paration function</strong> $p(n)$</p>
<p>让 $p(n)$ 代表 number of partitions of n</p>
<p>例如 $p(4)=5$ </p>
<p>因为 4 的所有有五种paration $((4), (3, 1), (2,1,1), (2,2), (1,1,1,1))$</p>
<blockquote>
<p>Starting from n=0 the sequence of p(n) begins<br>1, 1, 2, 3, 5, 7, 11, 15, 22, 30, 42, 56, 77, 101, 135, …<br>This is sequence A000041 in the Online Encyclopedia of Integer Sequences (OEIS)</p>
</blockquote>
<p>利用 $p(n)$ 的生成函数，我们可以推导出很多东西。</p>
<p><img src="/Blog/intro/math443/paration_5.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<blockquote>
<p>为什么是这个式子?</p>
<p>我的理解就是 首先我们看 $\frac 1 {1-x}$ 的 generating function</p>
<script type="math/tex; mode=display">
\frac 1 {1-x} = 1+x+x^2+x^3\cdots</script><p>这相当于选择 1 出现的次数, 例如 $x^3$ 就是 1 出现三次</p>
<script type="math/tex; mode=display">
\frac 1 {1-x^2} = 1+x^2+x^4\cdots</script><p>这相当于选择 2 出现的次数</p>
<p>假设我们要求 $P(3)$</p>
<p>那么就是 $(1+x+x^2\cdots ) (1+x^2+x^4\cdots)(1+x^3+x^6\cdots)$ 中 $x^3$ 的 系数</p>
<p>我们可以忽略高于 $x^3$ 的项.</p>
</blockquote>
<p><img src="/Blog/intro/math443/paration_6.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>因此回归最原本的问题</p>
<p><img src="/Blog/intro/math443/paration_7.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p><br></p>
<h2 id="理解-paratition-generating-function"><a href="#理解-paratition-generating-function" class="headerlink" title="理解 paratition generating function"></a>理解 paratition generating function</h2><p>Partition generating function 的 <strong>Product form</strong></p>
<p><img src="/Blog/intro/math443/paration_8.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>我们说 下面的 identity 有一个 combinatorial interpretation</p>
<p><img src="/Blog/intro/math443/paration_9.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>每个 paration 都可以看作是一个长度递增的 sequence (可能是空)</p>
<p>我们可以将这个动作解读(视作) combinatorial choices. Choose the number of 1s, either 0 or 1 or 2 or … Then choose the number of 2s, either 0, 1, 2, or.. and so on. </p>
<p><img src="/Blog/intro/math443/paration_10.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<blockquote>
<p>因为 </p>
<script type="math/tex; mode=display">
\prod_{k=1}^{\inf}1+t^k = (1+t)(1+t^2)(1+t^3)\cdots</script><p>即选择一次 1 或是零次 1</p>
<p>选择一次 2 或是零次 2 等等</p>
</blockquote>
<p><br></p>
<h3 id="使用-generating-function-来证明-partition-class-之间的-bijection"><a href="#使用-generating-function-来证明-partition-class-之间的-bijection" class="headerlink" title="使用 generating function 来证明 partition class 之间的 bijection"></a>使用 generating function 来证明 partition class 之间的 bijection</h3><p><img src="/Blog/intro/math443/paration_11.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p>$P(n)$ 指的是 n 的 paration, 研究人员发现了 hypergeometric function 和 partition generating function 之间的关系</p>
<p>这种特性叫做 Rogers-Ramanujan identities: LHS 的和 等于 RHS 的乘积</p>
<p>例如:</p>
<p><img src="/Blog/intro/math443/paration_12.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p>如果一个 <strong>Discrete set</strong> 每个元素都有 non-negative integer size, 并且任何给定大小的元素数都是有限的, 那么它就是一个 <strong>combinatorial class</strong> </p>
<p>A <strong>discrete set</strong> is a <strong>combinatorial class</strong> if every element has a non-negative integer size, and the number of elements for any given size is finite</p>
<p><img src="/Blog/intro/math443/paration_13.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/math443/paration_14.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/math443/paration_15.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<blockquote>
<p>显然, 等式的右边是 parations by size 的集合</p>
<p>例如: 1 的 parations 的数量就是序列中 $t$ 的系数, 2 的 parations 的数量就是序列中 $t^2$ 的系数</p>
<p>我们要证明等式左边的序列也是这个性质</p>
<p>首先右边的序列记录的是 parations by size 的集合, 即所有这样点的集合</p>
<p><img src="/Blog/intro/math443/paration_16.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>而我们可以把这个点阵分为 3 个部分, Durfee square, 和 at most k part 和 each part at most k</p>
<p><img src="/Blog/intro/math443/paration_17.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>我们统计所有数的 paration 的可能</p>
<p>从另一个角度讲, 考虑 durfee square 的 rank, 就是统计每个 rank 有多少种可能</p>
<p>明显 对于 rank k, 有这些种点的组合形式</p>
<p><img src="/Blog/intro/math443/paration_18.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>即 partition with k parts 乘以 partition with maximum part equal to k </p>
<p>而我们还要统计点数, 还要在算上 $K\cdot K$ 这个矩阵中的点<br><img src="/Blog/intro/math443/paration_19.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>这个是 generating function, 但我们不是基于哪一个数有多少种 paration 来进行计算的, 而是基于 rank 有多少种组合来进行计算的</p>
<p>当我们固定 k 就可以算出 任意一个数有多少个 rank k paration</p>
<p><img src="/Blog/intro/math443/paration_20.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
</blockquote>
<p><img src="/Blog/intro/math443/paration_21.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/math443/paration_22.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p><br></p>
<h2 id="Vector-partition"><a href="#Vector-partition" class="headerlink" title="Vector partition"></a>Vector partition</h2><p>我们之前都是对 integer 进行 partition, 但我们也可以对 integer vector 进行 partition</p>
<p>例如 <code>((1, 0), (2, 1), (2, 1), (0, 1))</code> 就是 <code>(5, 3)</code> 的 vector paration</p>
<p>我们将 vector partition 通过一系列 变量来进行 encoding</p>
<p>例如原本 integer k 我们只需要看 $x^k $ 的系数</p>
<p>而现在对于 vector $(a,b,c)$ 我们要映射为 <img src="/Blog/intro/math443/vp.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/math443/vp_1.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p>通常情况下，我们会将部分内容限制在一小部分 vector 中, 我们可以 encode 在一个矩阵 $A$ 中, 并且用 $p_A(a,b)$ 表示使用 A 中 columns 的 paration 有多少种</p>
<p>例如:</p>
<p><img src="/Blog/intro/math443/vp_2.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>实际上这个问题种对于任何 $(m,n), p_A(m,n)=1$  因为 A 是可逆矩阵,  linear independent, 只有唯一解</p>
<p><img src="/Blog/intro/math443/vp_3.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/math443/vp_4.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/math443/vp_5.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/math443/vp_6.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>Cheema’s Theorem: </p>
<p>将 vector $\vec v$  partition 成 distinct part 的数量 等于 将 $\vec v$ partition 为每个 part 至少有一个 odd 元素</p>
<p><img src="/Blog/intro/math443/vp_7.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/math443/vp_8.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>我们要这个线性系统的非负整数解</p>
<p><br></p>
<p><br></p>
<h2 id="Polytopes"><a href="#Polytopes" class="headerlink" title="Polytopes"></a>Polytopes</h2><p>一些 polytopes 的例子:</p>
<p><img src="/Blog/intro/math443/poly.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>实际上在 linear programming 中我们就已经见过这个 polytopes,</p>
<p>simplex algorithm 就是在 polytopes 的顶点之间移动</p>
<p>convex 的定义: 就是图形中任意两点连成的线都在这个图形内</p>
<p><img src="/Blog/intro/math443/poly_1.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>而 <strong>convex hull</strong> 就是 最小可以容纳这个多边形的 convex set</p>
<p>$conv(S)$ 是 所有 S 中,点的线性组合, 这里就像是我们描述线的时候</p>
<p>$\vec v_1 \vec v_2$ 这条线可以用一个式子表达 $t\cdot \vec v_1+(1-t)\cdot \vec v_2$ 这里 t 是大于等于 0 小于等于 1 的实数.</p>
<p>同理要表达一个多维空间的 hyperplain 就可以对 convex set 的每个顶点进行同样的操作. 如果一个点不是 convex 的 顶点那么在这个式子中就会被自动忽略, 因为我们总是可以把他的系数设为 0.</p>
<p><img src="/Blog/intro/math443/poly_2.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>如果我们把 0 去掉, 那么就是 $conv((e_1, e_2, e_3))$ 就是由这三个点组成的三角形 (二维) 而不是三维体</p>
<script type="math/tex; mode=display">
\text{conv}((\pm 1, \pm1))=\text{conv}((1,1), (1,-1), (-1, 1), (-1, -1))</script><p>就是包裹这四个点的最小的 convex 图形, 即由这四个点组成的正方形</p>
<p><img src="/Blog/intro/math443/poly_3.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p>d-维 Euclidean space $\mathbb{R}^d$ 的 Hyperplane 是 一个 d-1 维的 affine subspace</p>
<p><img src="/Blog/intro/math443/poly_4.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>polygon 是由 hyperplane 来定义的 (linear programming 中就讲过)</p>
<p><img src="/Blog/intro/math443/poly_5.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>每个 $a_i$ 都定义了一个 polytope 的 facet 或是 flat side</p>
<p><img src="/Blog/intro/math443/poly_6.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/math443/poly_7.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/math443/poly_8.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>standard simplex 就是由 $e_i$ 组成的 convex hull</p>
<p><img src="/Blog/intro/math443/poly_9.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/math443/poly_10.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<h2 id="Dilates-of-Polytopes"><a href="#Dilates-of-Polytopes" class="headerlink" title="Dilates of Polytopes"></a>Dilates of Polytopes</h2><p><img src="/Blog/intro/math443/poly_11.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>我们可以将这个式子看作是一个 $n$ 的 integer partition</p>
<p>选择 $a_1$ 次的 $m_1$, $a_2$ 次的 $m_2$  等等</p>
<p>之后我们思考 parttions with restricted parts 和 dilates (扩张) of polytope 的关系</p>
<p><br></p>
<p><strong>Dilates</strong></p>
<p><img src="/Blog/intro/math443/poly_12.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p><strong>Lattice (格网) point enumerator</strong></p>
<p><img src="/Blog/intro/math443/poly_13.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>我们重新整理一下 problem</p>
<p>对于 polytope P, 我们想确定 $p(n)$</p>
<script type="math/tex; mode=display">
p(n)=|\mathbb{Z}^d \cap_n p|</script><blockquote>
<p>$\mathbb Z^d$ 指的是网格, 即 d 维上所有的 integer point, 我们要他和 我们关心的 polytope $P$ 的交集, 即 $P$ 中所有的 integer point, 再用 $|\cdot |$ 求集合的数量 </p>
</blockquote>
<p>我们关心这个序列, 因为我们可以算出</p>
<ul>
<li>integer solution</li>
<li>volume approximations</li>
</ul>
<p>例如:</p>
<p>d 维的 立方体:</p>
<p><img src="/Blog/intro/math443/poly_14.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>每个 component 有三个 integer <code>-1, 0, 1</code>, 我们有 $d$ components 因此有 $3^d$ 个 integer point</p>
<p>我们对立方体进行扩张, 得到 $(2n+1)^d$ 这是一个 polynomial in $n$</p>
<p><br></p>
<p>定义: 离散体积 (<strong>discrete volume</strong>) 就是 integer lattice point in $P$ </p>
<p>Notation: </p>
<script type="math/tex; mode=display">
L_p(t)=|tP\cap \mathbb{Z}^d|</script><p>(t 不一定是 integer)</p>
<blockquote>
<p>$t$ 和上面的 $n$ 一样表示扩张的 scalar</p>
</blockquote>
<p><img src="/Blog/intro/math443/poly_15.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>我们有两种视角</p>
<ol>
<li>固定网格, 之后扩展 polytope</li>
<li>固定 polytope, 缩小网格</li>
</ol>
<p><br></p>
<p>On the nature of $L_p(t)$</p>
<p><img src="/Blog/intro/math443/poly_16.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>$x_1, x_2$ 都可以是 任意 positive integer.  这里我们计算的是 </p>
<script type="math/tex; mode=display">
x_1+x_2\cdots + x_d=n</script><p>的 integer solution</p>
<p>如果 n 不是 integer 那么这个式子是无效的</p>
<p><img src="/Blog/intro/math443/poly_17.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/math443/poly_18.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/math443/poly_19.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p><br></p>
<h2 id="Theorems-for-2D-polytopes"><a href="#Theorems-for-2D-polytopes" class="headerlink" title="Theorems for 2D polytopes"></a>Theorems for 2D polytopes</h2><p>任何 polytope $P\subseteq \mathbb{R}^d$</p>
<p><img src="/Blog/intro/math443/poly_20.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>我们有个假设: $L_P(n)$ 是一个 polynomial in $n$, 并且 degree = dimension of $P$ </p>
<p><img src="/Blog/intro/math443/poly_21.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p><br></p>
<p><strong>Theorem</strong>: 假设 $P\subseteq \mathbb{R}^2$ , vertices 在 $\mathbb{Z}^2$ 中 (顶点都是整数), 假设 $Area (P) = A$, 并且在 boundary 有 $B$ 个 lattice points, 那么</p>
<script type="math/tex; mode=display">
L_P(n)= An^2+\frac {B}{2}n+1</script><p><img src="/Blog/intro/math443/poly_22.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p><strong>Pick’s Theorem</strong></p>
<p>假设 $P$ 是一个 integreal convex polygon with $i$ <strong>interior</strong> points (内部), 并且有 $b$ integral boundary points (边界), 那么</p>
<script type="math/tex; mode=display">
Area(P) = i+b/2 - 1</script><p><br></p>
<p><strong>Linking dimension and degree</strong></p>
<p>让 $P\subseteq \mathbb{R}^d$ 是一个 rational polytope, 那么 $L_P(n)$ 是一个 quasi polynomial of degree $d$</p>
<p><strong>quasi polynomial:</strong> 就像是分段函数一样</p>
<p><img src="/Blog/intro/math443/poly_23.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>例如</p>
<script type="math/tex; mode=display">
\begin{equation}
P(n)=
\begin{cases}
n^2 & \text{n is odd} \\
0 & \text{n is even} \\
\end{cases}

\end{equation}</script><p>$P_i(n)$ 是一个 polynomial</p>
<p><br></p>
<p><strong>Computing $L_P(n)$ for generic $P$</strong> (defined by rational points)</p>
<p>思想: 将 $P$ 的 <strong>hyper plane description</strong> 转为 <strong>vector partition problem</strong></p>
<p><img src="/Blog/intro/math443/poly_24.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>和 linear programming 一样, 通过 <strong>slack variable</strong> 将不等式转为等式</p>
<p> 后者使用 slack variable, 它 encode 一个 integer partition</p>
<p><img src="/Blog/intro/math443/poly_25.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>如果 $a_i=a_j$ 我们将他们视作有着相同值的 distinct parts</p>
<p>如果我们的 polytopes 由多个 half plane 组成, 我们可以将它视作 vector partition problem</p>
<p><img src="/Blog/intro/math443/poly_26.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>当添加 slack variable 后 $P$ 的 dimension 可能就不等同于 number of row in $A$</p>
<p><img src="/Blog/intro/math443/poly_27.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/math443/poly_28.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<blockquote>
<p>vertex description 就是 conv hall</p>
</blockquote>
<p><img src="/Blog/intro/math443/poly_29.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>$(i, j)$ 表示如何进行 partition, 其余的使用 [0 ,1] 或是 [1, 0] 填充</p>
<p>这里有个错误: (0, 1) 应该是</p>
<figure class="highlight scss"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs scss">(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>) -&gt; <span class="hljs-selector-attr">[2, 1]</span> <span class="hljs-selector-attr">[0, 1]</span> <span class="hljs-selector-attr">[1,0]</span><br></code></pre></td></tr></table></figure>
<p><img src="/Blog/intro/math443/poly_30.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p><br></p>
<h2 id="Partition-Functions"><a href="#Partition-Functions" class="headerlink" title="Partition Functions"></a>Partition Functions</h2><p>让 A 是一个 $d\times k$ matrix</p>
<p><img src="/Blog/intro/math443/vp_9.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/math443/vp_10.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/math443/vp_11.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/math443/vp_12.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/math443/vp_13.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/math443/vp_14.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><strong>这里的三个准则非常重要</strong></p>
<p><img src="/Blog/intro/math443/vp_15.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p><br></p>
<h2 id="General-Combinatorial-Classes"><a href="#General-Combinatorial-Classes" class="headerlink" title="General Combinatorial Classes"></a>General Combinatorial Classes</h2><p>让 $C$ 是一个 denumerable class, $|\cdot|$ 表示 size $|\cdot |:C\rightarrow \mathbb{N}$</p>
<p>任何给定 size 的 objective 都是 finite 的</p>
<p><img src="/Blog/intro/math443/gcc.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>例如: Binary word class 是一个 string</p>
<p>让 size 为 number of 0s + number of 1s</p>
<script type="math/tex; mode=display">
|1001011100| = 10</script><blockquote>
<p>但我们不能让 size 只是 number of 0s, 因为这样我们就可以有任意数量的 1, 例如对于 size 1, 我们有 0, 01, 011, 等等, 这个集合有无限个元素</p>
</blockquote>
<p><img src="/Blog/intro/math443/gcc_1.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>还有二叉树, 这里指的二叉树是每个节点要么没有子节点要么有两个子节点, 不存在一个节点只有一个子节点的情况</p>
<p><br></p>
<h2 id="Notation-Conventions"><a href="#Notation-Conventions" class="headerlink" title="Notation Conventions"></a>Notation Conventions</h2><p><img src="/Blog/intro/math443/gcc_2.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>我们的目标是 给一个 description of a class</p>
<ul>
<li>计算 formula for $c_n$ (number of objects size n) (systematically)</li>
<li>estimate $c_n$ (systematically)</li>
<li>identify useful structure in $C$ that can be exploited</li>
</ul>
<p><br></p>
<p><strong>Strategies</strong></p>
<ul>
<li><p>manually generate small elements and guess (OEIS <strong>On-Line Encyclopedia of Integer Sequences</strong>)</p>
</li>
<li><p>递归关系</p>
</li>
<li><p><img src="/Blog/intro/math443/gcc_3.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
</li>
<li><p>使用 generating functions</p>
<ul>
<li>将 structure 转为 generating function 的 <strong>functional equations</strong>. 使用 complex analysis + algebra 来解出系数</li>
</ul>
</li>
<li>Singularity analysis<ul>
<li>poles + square root singularities are useful to determine asymptotic counting formula. (“Analytic combinatorics”)</li>
<li>极点 + 平方根奇异点有助于确定渐近计数公式。(“解析组合学”)</li>
</ul>
</li>
</ul>
<p><img src="/Blog/intro/math443/gcc_4.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/math443/gcc_5.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/math443/gcc_6.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/math443/gcc_7.png" srcset="/Blog/img/loading.gif" lazyload alt=""><em>**</em></p>
<p><img src="/Blog/intro/math443/gcc_8.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/math443/gcc_9.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/math443/gcc_10.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/math443/gcc_11.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/math443/gcc_12.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/math443/gcc_13.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/math443/gcc_14.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<blockquote>
<p>这个式子是递归的式子, coefficient 描述的就是每种情况有多少种可能, 这个式子和binary tree的递归结构是一致的</p>
<p>如果我们允许二叉树的中间节点可以只有一个叶子节点</p>
<p>那么就应该是 </p>
<script type="math/tex; mode=display">
B(z)=z+1\cdot B(z)^2+1\cdot B(z)</script></blockquote>
<p><img src="/Blog/intro/math443/gcc_15.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p><br></p>
<p>如果 elements 是 uniquely generated, 那么我们可以直接将它转为 generating function</p>
<p><img src="/Blog/intro/math443/gcc_16.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>由于 $D$ 是 $A$ 的一个 term, 所以 Class $A$ 依赖于 $D$. 我们可以制作一个 directed graph of dependencies</p>
<p>而如过在这个 graph 中, $D$ 到 $A$ 也有一条线 ($D$ depend on $A$), 那么我们就有 <strong>cyclic dependency</strong></p>
<p>如果我们用 $+, \times , *, \circ \text{(Atomic)}, \epsilon$ 定义一个 class, 并且没有 cycle dependencies 那么它也被叫做 S-Regular</p>
<blockquote>
<p>计算机理论中, 证明一个 language 不是 regular 使用 pummping lemma</p>
</blockquote>
<p>例如: </p>
<p><img src="/Blog/intro/math443/gcc_17.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>我们有 $B\equiv A^*$ , $B$ 是 S-regular</p>
<p>This is even true if </p>
<p><img src="/Blog/intro/math443/gcc_18.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>这是一个有 cyclic dependency 的 equation</p>
<p><img src="/Blog/intro/math443/gcc_19.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/math443/gcc_20.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>$A^*$ 的 generating function 是 $\frac 1{1-t}$ (A 的 generating function 是 $t$)</p>
<p>之后我们可以递归进行求解问题</p>
<p>得到这个 class 的 generating function</p>
<p><img src="/Blog/intro/math443/gcc_21.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><strong>S-regular class</strong> 的 generating function 是一个 rational function $\frac{p(t)} {q(t)}$.</p>
<p>如果我们说一个 class 没有 rational generating function, 那么我们就知道它不是 S-regular</p>
<blockquote>
<p>Regular language 时使用 finite automata 来进行分别</p>
<p>我们可以通过证明一个 language 的 generating function 不是一个 rational function 来说明它不是 regular (也可以用 pumping lemma)</p>
</blockquote>
<p><img src="/Blog/intro/math443/gcc_22.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/math443/gcc_23.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/math443/gcc_24.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/math443/gcc_25.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<h2 id="Recursive-structure"><a href="#Recursive-structure" class="headerlink" title="Recursive structure"></a>Recursive structure</h2><h3 id="Rooted-Plane-Tree"><a href="#Rooted-Plane-Tree" class="headerlink" title="Rooted Plane Tree:"></a><strong>Rooted Plane Tree</strong>:</h3><ul>
<li>有一个 root node</li>
<li>embeded in plane</li>
<li>children are ordered</li>
</ul>
<p><br></p>
<h3 id="Binary-tree"><a href="#Binary-tree" class="headerlink" title="Binary tree:"></a>Binary tree:</h3><p>每个 vertex 有 两个或是零个子节点</p>
<p>size = number of leaves</p>
<p><img src="/Blog/intro/math443/rs.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<script type="math/tex; mode=display">
B(t)=t+B(t)^2</script><p>让 $u=B(t)$</p>
<script type="math/tex; mode=display">
u^2-u+t=0</script><p>解出来</p>
<script type="math/tex; mode=display">
u=\frac {1\pm \sqrt{1-4t}}{2}</script><p>我们选择有 right taylor series at 0: $\frac {1-\sqrt{1-4t}}{2}$</p>
<script type="math/tex; mode=display">
B(t)=t+t^2+2t^3+5t^4+\cdots</script><p>我们可以用 generativebinomial theorem 来确定第 n 项的系数</p>
<script type="math/tex; mode=display">
b_{n+1}={2n \choose n}\frac 1{n+1}</script><p><br></p>
<h3 id="2-3-tree"><a href="#2-3-tree" class="headerlink" title="2-3 tree"></a>2-3 tree</h3><p>每个 vertex 有 0, 2 或 3 个子节点</p>
<p><img src="/Blog/intro/math443/rs_1.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<h3 id="Full-Plane-trees"><a href="#Full-Plane-trees" class="headerlink" title="Full (Plane trees)"></a>Full (Plane trees)</h3><p>对于 children 没有任何约束</p>
<p>size = number of vertices</p>
<script type="math/tex; mode=display">
T = \bullet \times T^*</script><p><img src="/Blog/intro/math443/rs_2.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/math443/rs_3.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<h3 id="Dyck-path"><a href="#Dyck-path" class="headerlink" title="Dyck path"></a>Dyck path</h3><p><img src="/Blog/intro/math443/rs_4.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/math443/rs_5.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/math443/rs_6.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/math443/rs_7.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p><br></p>
<h2 id="Bijection"><a href="#Bijection" class="headerlink" title="Bijection"></a>Bijection</h2><p>如果对于所有 $n\ge 0$, generating function 都有 $a_n=b_n$  我们说两个combinational classes 是 bijection. 写作 $A\equiv B$</p>
<p>考虑 class $B$ of binary tree</p>
<p>size = number of internal vertices</p>
<p>specification: $B=\epsilon+\bullet\times B\times B$</p>
<p>$|\bullet|=1$</p>
<p>$B(t)=1+t\cdot B(t)^2$, 因此 $b_n={2n \choose n}\frac {1}{n+1}$</p>
<p><br></p>
<h3 id="triangulations"><a href="#triangulations" class="headerlink" title="triangulations"></a>triangulations</h3><p>一个 labelled 的凸多边形的 triangulation 和 tree 是 bijection 关系的</p>
<p><img src="/Blog/intro/math443/bijection.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>对于一个 triangulation, 我们先确定一条边, 之后这个边对应三角形的顶点就是 tree 的 root</p>
<p>其余两条边分别是两个子树</p>
<p><img src="/Blog/intro/math443/bijection_1.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>三角形有三条边, 第一条边用于和 parent node 链接, 剩余两条边用于和子节点链接</p>
<p>triangle 的数量就是 internal node 的数量</p>
<p><br></p>
<p>但是我们如何证明</p>
<h3 id="Strategy-1-mapping"><a href="#Strategy-1-mapping" class="headerlink" title="Strategy 1, mapping"></a>Strategy 1, mapping</h3><p>一种方法是定义一个 map</p>
<p>$\phi: T_n\rightarrow B_n$ 并且 show</p>
<ol>
<li>image of $\phi$ 在 $B_n$ 中</li>
<li>map 是 bijection<ol>
<li>injective $\phi(T_1)=\phi(T_2)\implies T_1=T_2$</li>
<li>surjective $\forall \beta, \exists B_n , \exists T \in T_n, \phi(T)=\beta$</li>
</ol>
</li>
</ol>
<p><img src="/Blog/intro/math443/bijection_2.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>这个方式当我们在可以准确地链接两个 class 的 特征 (characterizing features) 时非常好用</p>
<p><img src="/Blog/intro/math443/bijection_3.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<h3 id="Strategy-2"><a href="#Strategy-2" class="headerlink" title="Strategy 2"></a>Strategy 2</h3><p>我们只需要证明两个 class 的 combinationial specification 一致即可</p>
<p>对于 triangulation 问题, 他的 specification 是</p>
<p><img src="/Blog/intro/math443/bijection_4.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>因为我们从构造 triangulation 的角度看, 对于一个多边形, 我们先用一个三角形将它分成两个小的多边形, 然后对两个小多边形进行递归操作</p>
<p><img src="/Blog/intro/math443/bijection_5.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>因此我们能得到这个 specification</p>
<p>而这个和 binary tree 的 specification 是一样的</p>
<script type="math/tex; mode=display">
T(t)=1+t\cdot T(t)^2</script><script type="math/tex; mode=display">
B(t)=1+t\cdot B(t)^2</script><p>因此二者一致</p>
<p><br></p>
<p><br></p>
<h2 id="Labelled-Structures"><a href="#Labelled-Structures" class="headerlink" title="Labelled Structures"></a>Labelled Structures</h2><h3 id="Labels"><a href="#Labels" class="headerlink" title="Labels"></a>Labels</h3><p>对于一个 有 $n$ 个 atoms 的 size $n$ 的 object, 我们可以 labels $1, 2,\cdots,n$</p>
<p><img src="/Blog/intro/math443/label.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<blockquote>
<p>well labelled: 我们正好使用 “size of object” 来 label</p>
</blockquote>
<p><br></p>
<h3 id="Exponential-generating-function-EGF"><a href="#Exponential-generating-function-EGF" class="headerlink" title="Exponential generating function (EGF)"></a>Exponential generating function (EGF)</h3><p>从 counting 的角度, 这意味着有很多的 structures. 例如对于一个 rooted plane trees, 如果我们 label 它则有 n! 种不同的 label 方式</p>
<p>对于 labelled structures 我们使用 exponential generating function (EGF)</p>
<p>让 $C$ 是一个 well labelled combinatorial class, 定义</p>
<script type="math/tex; mode=display">
c(t)=\sum_{n\ge 0}c_n\frac {t^n}{n!}</script><p>通常我们会知道 $c(t)$ 指的是 OGF (ordinary generating function) 还是 EGF, 通常情况下我们使用 $\tilde c(t)$ 表示 OGF.</p>
<p><br></p>
<p><br></p>
<h4 id="basic-epsilon-and-atom"><a href="#basic-epsilon-and-atom" class="headerlink" title="basic: epsilon and atom"></a>basic: epsilon and atom</h4><p>一些 well labeled classes 和 他们的 egf 的例子</p>
<p><img src="/Blog/intro/math443/label_1.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<h4 id="classic-Permutations"><a href="#classic-Permutations" class="headerlink" title="classic: Permutations"></a>classic: Permutations</h4><script type="math/tex; mode=display">
P_n=n!</script><script type="math/tex; mode=display">
P(t)=\sum_{n\ge 0}n!\frac {t^n}{n!}=\sum_{n\ge 0}t^n=\frac 1{1-t}</script><p>就是说 permutation 的 egf 就是 $1+t+t^2\cdots$</p>
<blockquote>
<p>我觉得, 他就是普通的 generating function 但是为了节省一下冗余的 $n!$, 因为当我们 label 时通常会有 $n!$ 种情况</p>
</blockquote>
<p><img src="/Blog/intro/math443/label_2.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>对于 permutation 有两种方式描述</p>
<p>一种是以原本的顺序排列, 例如一个数组, 存储新的 label</p>
<p>另一种是使用 graph, 2 的位置存 3 就将 2 指向 3. 这样, 表示如何交换 label</p>
<p><br></p>
<h4 id="urn"><a href="#urn" class="headerlink" title="urn"></a>urn</h4><p><img src="/Blog/intro/math443/label_3.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>对于 set, set 本身就不在意 order, 因此 relabel 不会改变什么, 因此 $u_n=1$</p>
<p><br></p>
<h4 id="Cycles"><a href="#Cycles" class="headerlink" title="Cycles"></a>Cycles</h4><p><img src="/Blog/intro/math443/label_4.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>cycle 我们可以选择一个点, 固定住它, 之后对其余 $n-1$个点进行 permutation. </p>
<p><br></p>
<p><br></p>
<h3 id="General-thoughts"><a href="#General-thoughts" class="headerlink" title="General thoughts"></a>General thoughts</h3><p>一些一般的想法</p>
<p>number of unlabelled (urns) $\le$ number of labelled $\le n! \cdot$ number of unlabelled (list)</p>
<p>urns 就是 lower bound 的 例子</p>
<p>list permutation 就是 upper bound 的例子</p>
<p><br></p>
<p><strong>Combinational sum + labelling is inherited</strong> </p>
<p>证明 $C=A+B$:</p>
<p>我们知道 $c_n=a_n+b_n$</p>
<script type="math/tex; mode=display">
C(t)=\sum c_n \frac {t^n}{n!}=\sum (a_n+b_n) \frac {t^n}{n!}</script><script type="math/tex; mode=display">
=\sum a_n \frac {t^n}{n!}+\sum b_n \frac {t^n}{n!}</script><script type="math/tex; mode=display">
=A(t)+B(t)</script><p><br></p>
<h3 id="Products-star"><a href="#Products-star" class="headerlink" title="Products $\star$"></a>Products $\star$</h3><p>和简单的 cartesian product 不一样</p>
<p><img src="/Blog/intro/math443/label_5.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>我们为所有 relabelled elements 创建一个 set</p>
<script type="math/tex; mode=display">
A\star B=\bigcup_{\alpha\in A, \beta\in B}\text{Relabel}(\alpha, \beta)</script><p>$\text{Relabel}(\alpha, \beta)$ 是 choose $|\alpha|$ labels from $(1\cdots |\alpha|+|\beta|)$</p>
<ul>
<li>为 atom 赋值时保持 label 的顺序</li>
<li>使用其余的 $|\alpha|+|\beta|$ labels 来 relabel $\beta$ in some way</li>
</ul>
<p><img src="/Blog/intro/math443/label_0.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>如果 $C=A\star B$ 那么 </p>
<script type="math/tex; mode=display">
c_n=\sum_{k=0}^\text{inf} a_kb_{n-k}{n \choose k}</script><script type="math/tex; mode=display">
\sum_{n\ge 0}c_n \frac {t^n}{n!} &=&\sum_{n\ge 0}(\sum_{k=0}^\text{n} a_kb_{n-k}{n \choose k})\frac {t^n}{n!} \\
&=& \sum_{n\ge 0}\sum_{k=0}^n \frac {a_k}{k!}\frac {b_{n-k}}{(n-k)!}t^{k+(n-k)}\\
&=&A(t)B(t)</script><p><img src="/Blog/intro/math443/label_6.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/math443/label_7.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p>Sequences</p>
<script type="math/tex; mode=display">
C=SEQ(A)\implies \text{egf }\quad C(t) = \frac 1 {1-A(t)}</script><script type="math/tex; mode=display">
C=\epsilon+A\star C</script><p><br></p>
<p><br></p>
<h3 id="Sequence-operator"><a href="#Sequence-operator" class="headerlink" title="Sequence operator"></a>Sequence operator</h3><p>我们可以定义 exponents </p>
<script type="math/tex; mode=display">
C=A\star A\cdots A</script><script type="math/tex; mode=display">
C(t)=A(t)^{\star k}</script><p>and sequence</p>
<script type="math/tex; mode=display">
C=\text{SEQ}(A)\implies C=\epsilon+A\star C\implies C(t)=\frac 1{1-A(t)}</script><p><img src="/Blog/intro/math443/set_op.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/math443/set_op_1.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>我们可以用 ordered list 来表示一个 set, 但是 将所有的 ordering 视为等同的</p>
<p><br></p>
<p>例如: $\text{SET}(P)$</p>
<p><img src="/Blog/intro/math443/set_op_2.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>我们用 $C=\text{SET(A)}$ 来表示 equivalent class of $\text{SEQ(A)}$ under permuting the components</p>
<p><img src="/Blog/intro/math443/set_op_3.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>当 atom 被 labelled, 任何两个 components 必须是 distinct. for every sequence with k</p>
<p>Components is in an equivalent class of size $k!$</p>
<p>如果 $C^{(k)}\subset C=\text{SET(A)}$ 是 那些  constains exactlly $k$ 个 A 的 element  的 set 那么</p>
<script type="math/tex; mode=display">
C^{(k)}(t)=\frac {A(t)^k}{k!}</script><blockquote>
<p>分子是 $A(t)^k$ 是因为有 $k$ 个 element</p>
<p>分母是 $k!$ 因为有这么多的 permutations</p>
</blockquote>
<p><img src="/Blog/intro/math443/set_op_4.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/math443/set_op_5.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<blockquote>
<p>用 1 来说</p>
<p>Forest 是 set of plane tree, $F=\text{SET(P)}$</p>
<p>$F(t)=e^{P(t)}$</p>
<p>$P$ 是 plane tree, 它的 sqecification 是 $\bullet\times \text{SEQ(P)}$ , 他有一个 root 节点, 同时 可以有多个子树(可以是一个子树, 两个子树… 即 sequence 个子树)</p>
<p>$SEQ(P)$ 的 generating function是 $\frac 1{1-P(t)}$</p>
<script type="math/tex; mode=display">
P(t)=t\cdot\frac 1{1-P(t)}</script><p>解出来 $P(t)$</p>
</blockquote>
<p><br></p>
<h3 id="Cycle-Construction"><a href="#Cycle-Construction" class="headerlink" title="Cycle Construction"></a>Cycle Construction</h3><p>我们同样可以使用这个方式来进行 cycle construction</p>
<p><img src="/Blog/intro/math443/set_op_6.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<script type="math/tex; mode=display">
C=\text{cyc}(A)\implies C(t)=\sum_{k\ge 0}\frac {A(t)^k}{k}=\log \frac {1}{1-A(t)}</script><blockquote>
<p>for this to be well defined, $a_0 = 0$</p>
</blockquote>
<p><img src="/Blog/intro/math443/set_op_7.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p><br></p>
<h2 id="Surjection"><a href="#Surjection" class="headerlink" title="Surjection"></a>Surjection</h2><p>surjection 是一个 map $f:D\rightarrow R$, 使得每个元素都有 non-empty pre-image (考虑 finite $D$ 和 $R$)</p>
<p><img src="/Blog/intro/math443/surjection.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<script type="math/tex; mode=display">
\text{R = a class of surjection}</script><script type="math/tex; mode=display">
=\text{SEQ(SET}_{\ge0}(\bullet))</script><script type="math/tex; mode=display">
\text{Size = Size of domain}</script><p><strong>labelled construction.</strong></p>
<script type="math/tex; mode=display">
R(t)=\frac{1}{1-(e^t-1)}=\frac {1}{2-e^t}=1+t+\frac 32t^2\cdots +\frac {1561}{240}t^6\cdots</script><blockquote>
<p>有 $\frac {1561}{240}\cdot 6!=4683$ surjections on a domain of 6 elements</p>
<p>如果有六个元素, 那么有 4683 种 surjection 方式</p>
<p>注意</p>
<script type="math/tex; mode=display">
\text {SET}_{\ge 0}(\bullet) = \text {SET}(\bullet) - 1</script><p>从整体排除 empty 的 case, 而 $\text{SET}(\bullet)=e^t$</p>
</blockquote>
<p>由此我们可以得到几个变种</p>
<p><br></p>
<p><strong>(a) Surjection $f:D\rightarrow R, |D|=n$</strong></p>
<script type="math/tex; mode=display">
S=\text{SEQ(SET}_{\ge0}(\bullet)), \quad|\bullet|=1</script><script type="math/tex; mode=display">
S(t)=\frac {1}{2-e^t}=(e^t-1)^1+(e^t-1)^2+(e^t-1)^3\cdots +(e^t-1)^n</script><p><br></p>
<p><strong>(b) Surjection $f:D\rightarrow R, |D|=n, R=r$</strong></p>
<p>我们不再允许任意 size 的 R, 而是将它固定为 r</p>
<script type="math/tex; mode=display">
S^r=(\text{SET}_{\ge0}(\bullet))^r</script><script type="math/tex; mode=display">
S^r(t)=(e^t-1)^r</script><p>我们关注这个东西的 $r$ 次方, 就像普通的 generating function 一样</p>
<p><br></p>
<p> <strong>(c) Surjection $f:D\rightarrow R$ 使得 每个 R 中元素的 pre-image 是 size 1 或 2</strong></p>
<p><img src="/Blog/intro/math443/surjection_1.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<script type="math/tex; mode=display">
\text{SEQ(SET}_{1,2}(\bullet))=\frac {1}{1-(t+\frac {t^2}{2})}</script><p><br></p>
<h3 id="Set-Partiton"><a href="#Set-Partiton" class="headerlink" title="Set Partiton"></a>Set Partiton</h3><p>一个 set B 的 set partition 是一组 non-empty subset of $B$ , 同时 union 是 $B$ 并且没有 intersection</p>
<p>例如: (1, 4), (3), (2,5,6) 是 (1..6) 的 一个 set partition</p>
<p>我们可以用 notation: $14|256|3$ 来表示</p>
<p>每个 subset 被叫做一般 block, 他们是 unordered</p>
<script type="math/tex; mode=display">
S=SET(SET_{\ge 0}(\bullet)),\quad \text{labelled}, \quad |\bullet|=1</script><script type="math/tex; mode=display">
S(t)=e^{e^t-1}</script><script type="math/tex; mode=display">
s_n=n![t^n]e^{e^t-1}</script><p>被叫做 Bell number</p>
<p><br></p>
<p><img src="/Blog/intro/math443/surjection_2.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>我们可以进行细粒度的控制 set 的样子</p>
<p><br></p>
<h3 id="Permutations"><a href="#Permutations" class="headerlink" title="Permutations"></a>Permutations</h3><p><img src="/Blog/intro/math443/surjection_3.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<script type="math/tex; mode=display">
P(t)=e^{\log \frac {1}{1-t}}=\frac 1 {1-t}</script><p>我们可以描述并且找到 各种 permutation family 的 generating function.</p>
<p>我们可以 控制 cycle 的 length 和 cycle 的数量</p>
<p><img src="/Blog/intro/math443/surjection_4.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>我们可以禁止一个元素的环 (no fixed point)</p>
<p><img src="/Blog/intro/math443/surjection_5.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p><br></p>
<h2 id="Polya-Redfield-counting"><a href="#Polya-Redfield-counting" class="headerlink" title="Polya-Redfield counting"></a>Polya-Redfield counting</h2><p>我们使用 equivalence classes of sequence 定义 SET 和 CYCLES</p>
<p><strong>Equivalence class 的数量等于 distinct object 的数量</strong></p>
<p>现在我们对 unlabelled object 使用这个 strategy</p>
<p><br></p>
<p>我们考虑 unlabelled version of SETS</p>
<p>Multisets of size 4 with elements from <code>&#123;a,b&#125;</code></p>
<p><code>&#123;a, a, a, a&#125;, &#123;a, a, a, b&#125;, &#123;a, a, b, b&#125;, &#123;a, b, b, b&#125;, &#123;b, b, b, b&#125;</code></p>
<p>我们将下面这些 sequence 视为一个 equivalence class</p>
<p><code>(a, a, b, b) = (a, b, a, b) = (a, b, b, a) = (b, b, a, a) = (b, a, b, a) = (b, a, a, b)</code></p>
<p><br></p>
<p><img src="/Blog/intro/math443/surjection_6.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/math443/surjection_7.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<blockquote>
<p>cyclic permutation 的每个括号代表一个 cycle</p>
<p><code>(1, 2, 3, 4)</code> 代表的就是 <code>1-&gt;2-&gt;3-&gt;4-&gt;1</code> 这样一个cycle</p>
<p><code>(1, 3)(2, 4)</code> 就是两个 cycle</p>
</blockquote>
<p><img src="/Blog/intro/math443/surjection_8.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>两种颜色的还算简单</p>
<p>对于正三边体, 我们有一个 colouring vector <code>(x1, x2, x3, x4)</code></p>
<p>如果一个 colouring 可以通过旋转 (物理上的) 变成另一个 colouring 我们就认为他们是等价的 (在一个 equivalence class)</p>
<p><img src="/Blog/intro/math443/surjection_9.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<h3 id="Sets-of-permutations"><a href="#Sets-of-permutations" class="headerlink" title="Sets of permutations"></a>Sets of permutations</h3><p>我们可以用哪些 permutations 来描述 equivalence class</p>
<p>我们的 set 要满足下面三个性质</p>
<ul>
<li>Identity permutation 必须在 set 中 (例如一个 cycle 我们不进行旋转, 它本身也是 equivalence class 的一个元素)</li>
<li>如果一个 permutation 在 set 中, 那么它的 inverse 也在 set 中 (例如 cycle, 我们顺时针旋转九十度后, 它在 set 中, 同样我们逆时针旋转 90 度 它也在 set 中)</li>
<li>如果 $\sigma_1, \sigma_2$ 在 set 中, 那么 composition $\sigma_1(\sigma_2(x))$ 也在 set 中 (例如: 顺时针旋转 45 度 和 逆旋转 30 度结合是顺时针旋转 15 度)</li>
</ul>
<p><img src="/Blog/intro/math443/surjection_10.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>这被叫做 <strong>GROUP of permutations</strong></p>
<p><br></p>
<h3 id="Cycle-index-series"><a href="#Cycle-index-series" class="headerlink" title="Cycle index series"></a>Cycle index series</h3><p><img src="/Blog/intro/math443/surjection_11.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>例如 如果我们有三个元素</p>
<p>cycle 1, 只有 <code>(1)(2)(3)</code>这种 permutation 方式, 即 $t_1^3$</p>
<p>cycle 1 和 cycle 2, 有 <code>(1)(2, 3), (2)(1, 3), (3),(1,2)</code> 这三种方式 $3t_1 t_2$</p>
<p>cycle 3 有 <code>(1, 2, 3) (1, 3, 2)</code> 两种方式</p>
<p><img src="/Blog/intro/math443/surjection_12.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<blockquote>
<p>example 中, 对于 cycle 为 3 的 index 我们有下面三种方案</p>
<p><img src="/Blog/intro/math443/cyc.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
</blockquote>
<p>对于 prime number, 他的式子就简单许多, 因为对 prime 进行 旋转不会得到和原本一样的图形</p>
<p>例如一个 length 为 4 的 cycle 由 1 和 2 组成 (1, 2, 1, 2)</p>
<p>我们将它偏移一次就是 (2, 1, 2, 1) 再偏移一次就是 (1, 2, 1, 2)</p>
<p>但如果是 length 为 5 的 cycle, 只有偏移 5 次才能得到和原本一样的图形</p>
<p><img src="/Blog/intro/math443/surjection_13.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/math443/surjection_14.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/math443/surjection_15.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/math443/surjection_16.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/math443/surjection_17.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p>我们通过 equivalent class 的视角</p>
<p><img src="/Blog/intro/math443/cyc_1.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>一个无序 set 可以看作是有序 tuple 的 equivalent class</p>
<p><img src="/Blog/intro/math443/cyc_2.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<script type="math/tex; mode=display">
Z_{S_3}(2,2,2) = 24/6=4</script><blockquote>
<p>2, 2, 2 指的是颜色, 就是这里的 a 和 b, 有两个变量, 如果我们寻找 a, b, c 三个变量再 cycle 3 的 组合, 那就应该是 3</p>
<p>每个 2 分别对应 $t_1, t_2, t_3$ </p>
<p>我怀疑如果 2, 2, 3 就可以是对于 length 为 1 和 2 的 cycle 允许用两种颜色, length 为 3 的  cycle 允许用 三种颜色, 颜色指的是 a, b, c</p>
</blockquote>
<script type="math/tex; mode=display">
Z_{S_3}(a+b, a^2+b^2,a^3+b^3)=a^3+a^2b+ab^2+b^3</script><p><img src="/Blog/intro/math443/cyc_3.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/math443/cyc_4.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>还有图论中的 isomorphic graph</p>
<p><img src="/Blog/intro/math443/cyc_5.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/math443/cyc_6.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/math443/cyc_7.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<blockquote>
<p>这里 (12)(3)(4)</p>
<p>我们说 1 和 2 可以互相替换</p>
<p>因此 边 A 没有等价的替代</p>
<p>B 和 D 是可以互相替换的 因为我们把 B (1,3) 中的 1 替换为 2 就成了 D (2, 3), 反过来也是一样</p>
<p>C 和 E 是可以互相替换的</p>
<p>F 不可替换</p>
<p>所以对应的 edge permutation 就是 (A)(BD)(CE)(F)</p>
<p>我们之关系 cycle 的结构, (13)(24)等同于(12)(34)</p>
</blockquote>
<p><img src="/Blog/intro/math443/cyc_8.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/math443/cyc_9.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p><br></p>
<p><br></p>
<h2 id="POSET"><a href="#POSET" class="headerlink" title="POSET"></a>POSET</h2><p>我们理解了 structure 和 counting of combinatorial classes. 我们尝试去组织 combinatorial class 的元素</p>
<p><img src="/Blog/intro/math443/poset.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/math443/poset_1.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/math443/poset_2.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/math443/poset_3.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/math443/poset_4.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/math443/poset_5.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/math443/poset_6.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/math443/poset_7.png" srcset="/Blog/img/loading.gif" lazyload alt=""><em>**</em></p>
<p><img src="/Blog/intro/math443/poset_8.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p><br></p>
<h2 id="Dilworth’s-Theorem"><a href="#Dilworth’s-Theorem" class="headerlink" title="Dilworth’s Theorem"></a>Dilworth’s Theorem</h2><p>这个 theorem 是针对 partially ordered set 的, 它等价于一些其他美丽的 theorem in combinatoric 例如 hall’s theorem</p>
<p>定义 partially ordered set $S$ 和 relation $\le$ on $S$ 满足</p>
<p><img src="/Blog/intro/math443/poset_9.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>注意 对于任意两个 poset 元素, 他们有可能也无法比较, 但如果任意两个都可以比较, 我们也称为 totally ordered</p>
<p>例如我们可以定义 如果 a 可以整除 b, 那么 $b\le a$, 显然在这个 poset 中 2 和 3 是无法比较的</p>
<p>有两个自然的方式来定义 partially ordered set 的宽度 width</p>
<p>这可以被认为是衡量它与完全有序的距离有多远 (which can be thought of as measuring how far away from totally ordered it is)</p>
<p>width 需要被定义为 positive integer, 只有是 1 的时候 才是 total ordered</p>
<p><strong>chain 是一个 partially ordered set 的 subset, chain 中的所有元素都可以两两互相比较 (totally ordered)</strong></p>
<p><strong>anti-chain 是一个 partially ordered set 的 subset, 但是两两都不可比较</strong></p>
<p><img src="/Blog/intro/math443/poset_10.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<h3 id="Hasse-diagrams"><a href="#Hasse-diagrams" class="headerlink" title="Hasse diagrams"></a>Hasse diagrams</h3><p>我们可以将 poset 绘制成 Hasse diagrams</p>
<p><img src="/Blog/intro/math443/poset_11.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<blockquote>
<p> Dilworth theorem statement: 让 $S$ 是一个 finite partially ordered set. 最大的 antichain 的大小等于 $S$ 的最小 chain cover</p>
</blockquote>
<p>通常来说, 证明 $A==B$, 我们可以证明 $A\ge B \text{ and }A\le B$</p>
<p>如果 最大 antichain 又 length $d$, 那么 任何 chain cover $h$ 都有 至少 d 个 chains, 因为 antichain 中 任何两个元素都无法互相比较, 必须将他们分配给不同的chain. 即: $h \ge d$</p>
<blockquote>
<p>Mirsky’s Theorem: 让 S 是一个 finite partially ordered set. 那么 maximal chain in $S$ 等于 minimal anti chain cover of $S$</p>
</blockquote>
<p><img src="/Blog/intro/math443/poset_12.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/math443/poset_13.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/math443/poset_14.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/math443/poset_15.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/math443/poset_16.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<h3 id="Dilworth’s-theorem-的应用"><a href="#Dilworth’s-theorem-的应用" class="headerlink" title="Dilworth’s theorem 的应用"></a>Dilworth’s theorem 的应用</h3><p>$P$ 是一个 finite poset, maximum anti-chain 是 minimal chain cover in P</p>
<p><strong>应用 1: Erdos-szekges Theorem:</strong> 一个 有 $rs+1$ 个 实数的 sequence, 要么有一个 length $r+1$ 的 increasing sequence, 要么有一个 $r+1$ 的 decreasing sequence, 也可能两者都有</p>
<p><img src="/Blog/intro/math443/poset_17.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p><strong>应用 2, hall’s theorem</strong></p>
<p><img src="/Blog/intro/math443/poset_18.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/math443/poset_19.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<h3 id="Rank"><a href="#Rank" class="headerlink" title="Rank"></a>Rank</h3><p>Poset 的 rank 是 length of longest chain (number of edges / number of elements + 1)</p>
<p>一个 connected poset 是 graded: 如果所有的 maximal chains 有同样的 length</p>
<p><img src="/Blog/intro/math443/poset_20.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/math443/poset_21.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/math443/poset_22.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/math443/sperner.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/math443/sperner_1.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/math443/sperner_2.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/math443/sperner_3.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/math443/sperner_4.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/math443/sperner_5.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/math443/sperner_6.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/math443/sperner_7.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/math443/sperner_8.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p><br></p>
<h2 id="Lattices"><a href="#Lattices" class="headerlink" title="Lattices"></a>Lattices</h2><p>定义: lattice 是一个 poset $P$, 使得 $\forall x, y\in P$, </p>
<ul>
<li>$x, y$ 有 上界(join) $x\or y$ 和 下界(meet) $x\and y$</li>
</ul>
<p><img src="/Blog/intro/math443/lattice.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>上界和下界是唯一的, 不然他们自身无法互相比较</p>
<p>反例</p>
<p><img src="/Blog/intro/math443/lattice_1.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>Lattices 同样有 algebrraic characterization. 我们通过 meet 和 join operation 定义 lattice 并推导出 “$\le$”</p>
<p><img src="/Blog/intro/math443/lattice_2.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/math443/lattice_3.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<h3 id="The-partition-Lattice"><a href="#The-partition-Lattice" class="headerlink" title="The partition Lattice"></a>The partition Lattice</h3><p>integer partition 有什么有用/有趣的?</p>
<h4 id="Dominance-Ordering"><a href="#Dominance-Ordering" class="headerlink" title="Dominance Ordering"></a>Dominance Ordering</h4><p><img src="/Blog/intro/math443/lattice_4.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>$\lambda, M$ 都是一个序列</p>
<p>我们假设他们都是从大到小 sorted</p>
<p>但他们不一定等长.</p>
<ol>
<li><p>我们总是可以通过添加 padding 0 来让他们等长</p>
<p>例如 $(3, 2, 1) \rightarrow (3,2,1,0,0)$ 来和 $(3,1,1,1,1)$ 等长</p>
</li>
<li><p><img src="/Blog/intro/math443/lattice_5.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
</li>
</ol>
<p>因此 $(3,1,1,1,1)\le (3,2,1,0,0)$</p>
<p><img src="/Blog/intro/math443/lattice_6.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/math443/lattice_7.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/math443/lattice_8.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/math443/lattice_9.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/math443/lattice_10.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<h2 id="q-Binomials"><a href="#q-Binomials" class="headerlink" title="q Binomials"></a>q Binomials</h2><h3 id="q-factorial"><a href="#q-factorial" class="headerlink" title="q factorial"></a>q factorial</h3><p>让 $q$ 是一个 formal variable</p>
<p>Fix $j\ge 0$ 定义:</p>
<script type="math/tex; mode=display">
[j]_q:= 1+q+q^2\cdots +q^{j-1}=\frac {q^j-1}{q-1}</script><p>我们约定 $[q]_0=1$</p>
<script type="math/tex; mode=display">
[j]_q = \begin{cases}
1 & q=0\\
j & q=1\\
\end{cases}</script><p>一个 q analog 是一个 泛化, 通常 q = 1 会给你 original function</p>
<p>我们可以用这个 q-analogne of integer 来定义 factorial</p>
<p><img src="/Blog/intro/math443/q_analog.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><strong>q-binomial</strong> 也被称为 Gaussian Binomial coefficient</p>
<script type="math/tex; mode=display">
\begin{bmatrix} k \\ j \end{bmatrix}_q =\begin{cases}
\frac {[k]_q!}{[j]_q![k-j]_q!} & \text{if }\quad k,j\ge 0,\quad j \le k\\
0 & \text{otherwise}\\
\end{cases}</script><p><img src="/Blog/intro/math443/q_analog_1.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>当 $q=1$ 时, 等于 $k\choose j$</p>
<p><img src="/Blog/intro/math443/q_analog_2.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/math443/q_analog_3.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<h3 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h3><p>directly from definition 我们可以得到</p>
<script type="math/tex; mode=display">
\begin{bmatrix} n \\ k \end{bmatrix}_q = \begin{bmatrix} n \\ n-k \end{bmatrix}_q</script><script type="math/tex; mode=display">
\begin{bmatrix} n \\ 0 \end{bmatrix}_q = \begin{bmatrix} n \\ n \end{bmatrix}_q = 1</script><script type="math/tex; mode=display">
\begin{bmatrix} n \\ 1 \end{bmatrix}_q = \begin{bmatrix} n \end{bmatrix}_q</script><p>Lemma (pascal-type identity)</p>
<script type="math/tex; mode=display">
\begin{bmatrix} n \\ k \end{bmatrix}_q = \begin{bmatrix} n-1 \\ k \end{bmatrix}_q +q^{k}\begin{bmatrix} n \\ k-1 \end{bmatrix}_q</script><p>可以使用代数证明它</p>
<p>一个推论 $\begin{bmatrix} n \ k \end{bmatrix}_q$ 总是 polynomial</p>
<p><img src="/Blog/intro/math443/q_analog_4.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>并且我们可以用 Mathematical induction 来证明这个 polynomial 的所有 coefficient 都是 positive integer</p>
<p>但是我们怎么理解这个系数?</p>
<p><img src="/Blog/intro/math443/q_analog_5.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<h3 id="Integer-Coefficients"><a href="#Integer-Coefficients" class="headerlink" title="Integer Coefficients"></a>Integer Coefficients</h3><p>对于 $n \choose k$ 我们有很多解释, $\begin{bmatrix} n \ k \end{bmatrix}_q$ 应该也如此 refinement</p>
<p>How can we parametrize something counted by $n \choose k$</p>
<p>例如 它可以用于计算有 k 个 1 的 length n 的 binary string 的数量</p>
<p><img src="/Blog/intro/math443/q_analog_6.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>例如 $R_{m,n}$ 代表 $m\times n$ 的矩阵中的 set of partition </p>
<p>总共有 $m+n \choose m$</p>
<blockquote>
<p>回顾: 这是一个 granded poset with $rank(\lambda)=|\lambda|$</p>
</blockquote>
<p>让</p>
<script type="math/tex; mode=display">
r_i(m,n)=|\{\lambda\in R_{m,n}\quad |\quad |\lambda|=i\}|</script><p><img src="/Blog/intro/math443/q_analog_8.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/math443/q_analog_7.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<h2 id="Interpretations-of-q-binomial"><a href="#Interpretations-of-q-binomial" class="headerlink" title="Interpretations of q-binomial"></a>Interpretations of q-binomial</h2><p>让 $r_i(m,n) = $  number of integer partition of $i$ that fit into an $m\times n$ rectangle</p>
<p><img src="/Blog/intro/math443/q_analog_9.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>Theorem: $R(m,n)=\begin{bmatrix} m+n \ n \end{bmatrix}_q$</p>
<p><img src="/Blog/intro/math443/q_analog_10.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/math443/q_analog_11.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/math443/q_analog_12.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/math443/q_analog_13.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/math443/q_analog_14.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/math443/q_analog_15.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/math443/q_analog_16.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/math443/q_analog_17.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/math443/q_analog_18.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p><br></p>
<h3 id="Lattices-of-vector-spaces"><a href="#Lattices-of-vector-spaces" class="headerlink" title="Lattices of vector spaces"></a>Lattices of vector spaces</h3><p><img src="/Blog/intro/math443/vector_space.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>$L_n(q)$ 是一个 poset 同时也是一个 lattice</p>
<p>我们可以定义他的 join 和 meet</p>
<p><img src="/Blog/intro/math443/vector_space_1.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<h3 id="Flag"><a href="#Flag" class="headerlink" title="Flag"></a>Flag</h3><p>定义: Flag 是一个 maximal chain $L_n(q)$</p>
<p><img src="/Blog/intro/math443/vector_space_2.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/math443/vector_space_3.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/math443/vector_space_4.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/math443/vector_space_5.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/math443/vector_space_6.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/math443/vector_space_7.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/math443/vector_space_8.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/math443/vector_space_9.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p><img src="/Blog/intro/math443/vector_space_10.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/math443/vector_space_11.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/math443/vector_space_12.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/math443/vector_space_13.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/math443/vector_space_14.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/math443/vector_space_15.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/math443/vector_space_16.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/math443/vector_space_17.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/math443/vector_space_18.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/math443/vector_space_19.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/math443/vector_space_20.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p><br></p>
<h2 id="Discrete-Geometry"><a href="#Discrete-Geometry" class="headerlink" title="Discrete Geometry"></a>Discrete Geometry</h2><p>定义: <strong>incidence structures</strong></p>
<p>incidence structure 是一个 triple $(V, L,\sim )$</p>
<p>$V, L$ 是 disjoin set, $\sim$ 代表 relation on $V \times L$</p>
<p>$V$ 是 points, $L$ 是 line (or “blocks”)</p>
<p><img src="/Blog/intro/math443/geometry.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/math443/geometry_1.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>定义: parallel</p>
<p>我们说两个 line 是 parallel 的, 如果他们没有共同的点, 或是全是共同的点</p>
<p>(Two lines are said to be parallel if they have no points in common or all points in common)</p>
<script type="math/tex; mode=display">
l||l'\implies l \cap l'=\empty \text{ or } l=l'</script><p><br></p>
<h3 id="Affine-Plane"><a href="#Affine-Plane" class="headerlink" title="Affine Plane"></a>Affine Plane</h3><p>当一个 incidence structure 的 $V, L$ 满足以下性质时, 我们说他是 affine plane</p>
<ol>
<li>任何两个不同的 point 都在 exactly one line 上</li>
<li><p>如果一个 point $p$ 不再 line $l$, 那么它就在某个 line $l’$ 且 $l||l’$ , 这个线是唯一的</p>
</li>
<li><p>存在三个点不同时再一个 line 中 (There exists 3 points not all contained on a common line)</p>
</li>
</ol>
<p><img src="/Blog/intro/math443/geometry_2.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<h3 id="Finite-Affine-Geometries-AG"><a href="#Finite-Affine-Geometries-AG" class="headerlink" title="Finite Affine Geometries (AG)"></a>Finite Affine Geometries (AG)</h3><p>Given a field $F$ (finite or infinite), 我们可以定义一个 incidence structure</p>
<p>Notation $AG(2, F)$,  Points: $F^2$</p>
<p><img src="/Blog/intro/math443/geometry_3.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/math443/geometry_4.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/math443/geometry_5.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/math443/geometry_6.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/math443/geometry_6.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/math443/geometry_7.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/math443/geometry_8.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<h3 id="Projective-Geometry"><a href="#Projective-Geometry" class="headerlink" title="Projective Geometry"></a>Projective Geometry</h3><p>Affine Geometry: $AG(2, F)\quad AG(2,q)=AG(2,F_q)$</p>
<p><img src="/Blog/intro/math443/ag.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>Proposition: 如果 $P=(V,L,\sim )$ 是一个 affine plane, 那么 “parallel” 是一个 equivalence relation.</p>
<p>如果 $V$ 是 finite 那么存在 $n\in \mathbb{N}$, 叫做 <strong>order of P</strong> such that:</p>
<ol>
<li>Every point is in $(n+1)$ lines</li>
<li>Every line contains $n$ points</li>
<li>Every parallel clan has size n</li>
<li>$|V|=n^2, |L|=n^2+n$</li>
</ol>
<blockquote>
<p>两个 parallel line 我们可以看作是在 infinity 远相交的线</p>
</blockquote>
<p><br></p>
<h3 id="Projective-plane"><a href="#Projective-plane" class="headerlink" title="Projective plane"></a>Projective plane</h3><p>我们定义 second family of incidence structures</p>
<p>定义: 一个 projective plane 是一个 incidence structure $P=(V, B, \sim)$ 使得:</p>
<ol>
<li>Any two points are contained in exactly one line (两个点只能同时存在于一条线上)</li>
<li>The intersection of any two lines is a single point (任何两个线只能交与一点)</li>
<li>Every point is <strong>not</strong> incident with at least two lines; Every line is non-incident with at least two points.</li>
</ol>
<p><img src="/Blog/intro/math443/geometry_9.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/math443/geometry_10.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/math443/geometry_10.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/math443/geometry_11.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/math443/geometry_12.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p>Affine planes 和 projective planes 有什么联系?</p>
<p>让 $P=(V,B,\sim)$ 作为一个 affine plane, 并且创建一个新的 incidence structure $P^+$ (为每个 parallel class 增加一个 infinite point)</p>
<p><img src="/Blog/intro/math443/geometry_13.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/math443/geometry_14.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p><img src="/Blog/intro/math443/affine.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/math443/affine_1.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/math443/affine_2.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/math443/affine_3.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/math443/affine_4.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/math443/affine_5.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/math443/affine_6.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/math443/affine_7.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/math443/affine_8.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/math443/affine_9.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/Blog/categories/%E6%95%B0%E5%AD%A6/">数学</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/Blog/tags/%E6%95%B0%E5%AD%A6/">数学</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/Blog/2024/01/31/Network-Flow/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Network Flow</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/Blog/2023/12/21/Coroutines/">
                        <span class="hidden-mobile">记一次 Coroutine 实现过程</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/Blog/js/events.js" ></script>
<script  src="/Blog/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/Blog/js/local-search.js" ></script>



  
    <script  src="/Blog/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
        typing(title);
      
    })(window, document);
  </script>





  

  
    <!-- MathJax -->
    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']]
        },
        loader: {
          load: ['ui/lazy']
        },
        options: {
          renderActions: {
            findScript: [10, doc => {
              document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
                const display = !!node.type.match(/; *mode=display/);
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
                const text = document.createTextNode('');
                node.parentNode.replaceChild(text, node);
                math.start = { node: text, delim: '', n: 0 };
                math.end = { node: text, delim: '', n: 0 };
                doc.math.push(math);
              });
            }, '', false],
            insertedScript: [200, () => {
              document.querySelectorAll('mjx-container').forEach(node => {
                let target = node.parentNode;
                if (target.nodeName.toLowerCase() === 'li') {
                  target.parentNode.classList.add('has-jax');
                }
              });
            }, '', false]
          }
        }
      };
    </script>

    <script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js" ></script>

  











<!-- 主题的启动项 保持在最底部 -->
<script  src="/Blog/js/boot.js" ></script>


</body>
</html>
