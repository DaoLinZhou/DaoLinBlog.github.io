

<!DOCTYPE html>
<html lang="" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/Blog/img/favicon.ico">
  <link rel="icon" href="/Blog/img/favicon.ico">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Daolin">
  <meta name="keywords" content="">
  
    <meta name="description" content="test">
<meta property="og:type" content="article">
<meta property="og:title" content="algorithm analysis">
<meta property="og:url" content="https://daolinzhou.github.io/Blog/2021/01/13/algorithm-analysis/">
<meta property="og:site_name" content="Daolin&#39;s Repository">
<meta property="og:description" content="test">
<meta property="og:locale">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/cmpt307/merge_sort.PNGte">
<meta property="article:published_time" content="2021-01-14T03:05:48.000Z">
<meta property="article:modified_time" content="2022-04-02T06:00:16.821Z">
<meta property="article:author" content="Daolin">
<meta property="article:tag" content="算法分析">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://daolinzhou.github.io/Blog/intro/cmpt307/merge_sort.PNGte">
  
  
  <title>algorithm analysis - Daolin&#39;s Repository</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/Blog/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"daolinzhou.github.io","root":"/Blog/","version":"1.8.14","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/Blog/local-search.xml"};
  </script>
  <script  src="/Blog/js/utils.js" ></script>
  <script  src="/Blog/js/color-schema.js" ></script>
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.1.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/Blog/">
      <strong>Fluid</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/Blog/">
                <i class="iconfont icon-home-fill"></i>
                Startseite
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/Blog/archives/">
                <i class="iconfont icon-archive-fill"></i>
                Archiv
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/Blog/categories/">
                <i class="iconfont icon-category-fill"></i>
                Kategorie
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/Blog/tags/">
                <i class="iconfont icon-tags-fill"></i>
                Etiketten
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/Blog/about/">
                <i class="iconfont icon-user-fill"></i>
                Über mich
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/Blog/intro/internet.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="algorithm analysis">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-01-13 19:05" pubdate>
        January 13, 2021 pm
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      15k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      124 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">algorithm analysis</h1>
            
            <div class="markdown-body">
              <p>test</p>
<span id="more"></span>
<h2 id="算法的要求"><a href="#算法的要求" class="headerlink" title="算法的要求"></a>算法的要求</h2><p><strong>Correctness</strong>(正确):  如果对于任何给定<strong>输入</strong>, 算法都会在<strong>有限的步骤</strong>内给予正确的<strong>输出</strong> (an algorithm for a problem is correct if for any input instance ofthe problem, the algorithm gives a correct output in finite steps)</p>
<p><strong>Efficiency</strong>(效率): 如果算法以输入大小终止于<strong>多项式时间</strong>，则该算法是有效的 (an algorithm is efficient if the algorithm terminates in polynomialtime (many steps) in the size of the input)</p>
<ul>
<li>计算时间和内存空间是有限的资源 (Computing time and memory space are bounded resource)</li>
<li>许多计算问题是优化问题，需要使用最佳资源来解决问题 (Many computing problems are optimization problems, solving the problemsusing optimum resources)</li>
<li>就时间和/或空间而言，算法应高效 (Algorithms should be efficient in terms of time and/or space)</li>
</ul>
<p><br></p>
<p><br></p>
<h2 id="设计与分析算法"><a href="#设计与分析算法" class="headerlink" title="设计与分析算法"></a>设计与分析算法</h2><ol>
<li>Identify a problem</li>
<li>Formulating the problem with certain mathematical precision</li>
<li>Design an algorithm to solve the problem</li>
<li>Analyze the algorithm<ul>
<li>Prove the correctness of algorithm</li>
<li>Analyze the efficiency of algorithm</li>
</ul>
</li>
</ol>
<p><br></p>
<p>举个例子:</p>
<p><img src="./Blog/intro/cmpt307/aa_1.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/aa_2.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/aa_3.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/aa_4.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/aa_5.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>证明算法正确性的步骤和数学归纳法(Mathematical induction) 很像</p>
<p>但有一点, 数学中的概念是无限的. 而计算机是有限的. 所以对于计算机问题来说是有边界的. 所以最后一步就是确定边界的正确性.</p>
<p><br></p>
<p><img src="/Blog/intro/cmpt307/aa_6.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p><br></p>
<h3 id="Efficient-algorithms"><a href="#Efficient-algorithms" class="headerlink" title="Efficient algorithms"></a>Efficient algorithms</h3><ul>
<li>一个算法是 poly-time (polynomial running time) 如果对于常数c, d $c&gt;0,d&gt;0$ 使得 对于每个size n 的输入, 算法的运行时间小于$cn^d$ primitive computational steps.</li>
<li>poly-time 的算法叫做 efficient algorithm</li>
<li>A  poly-time algorithm has the desirable scaling property:<ul>
<li>When the input size doubles, the running time increases by at most a constant factor</li>
</ul>
</li>
</ul>
<blockquote>
<p>例如: 如果输入是size n, 算法使用 $cn^d$步, 如果输入是2n, 算法用$c2^dn^d$ 步, 而$c2^d$是一个常数, 可以看作是一个新的$c$ 所以依然是$cn^d$</p>
</blockquote>
<p><br></p>
<h3 id="Messures-for-running-time"><a href="#Messures-for-running-time" class="headerlink" title="Messures for running time"></a>Messures for running time</h3><p>有5种方式来measure running time:</p>
<ol>
<li>Worst-case running time<ul>
<li>对于任何 size 为 n 的输入, 最长的运行时间</li>
</ul>
</li>
<li>Average-case running time<ul>
<li>对于所有 size 为 n 的输入, 平均的运行时间</li>
<li>The notion of “average” assumes a probability distribution over the inputs.</li>
</ul>
</li>
<li>Expected running time<ul>
<li>一个随机算法的 running time</li>
</ul>
</li>
<li>Amotized running time<ul>
<li>Worest case running time of any sequence of <em>n</em> operations</li>
</ul>
</li>
<li>Big-oh notation, $t(n)$ is $O(t_1(n))$ if there exist constants $c&gt;0$ and $n_0&gt;0$,  s.t. $0\le t(n)\le t_1(n)$ for all $n \ge n_0$</li>
</ol>
<p><img src="/Blog/intro/cmpt307/insertion_sort.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p>在解决 sorting 问题时一些常见思想</p>
<p>甚至在解决一些其他算法问题时也可以用到的思想:</p>
<ol>
<li>incremental approach (insertion-sort): 假设$A[1…j-1]$ 已经是排好序的, 把 $A[j]$ 插入其中使得 $A[1…j]$ 是排好序的</li>
<li>Divide-and-conquer approach(分治算法):<ul>
<li>把一个问题分成若干子问题</li>
<li>递归解决子问题</li>
<li>把子问题的结果合并成最终问题的解</li>
<li>Merge sort 就是一个例子</li>
</ul>
</li>
</ol>
<p><img src="/Blog/intro/cmpt307/merge_sort.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/merge_sort_1.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>我们为两个子块的最后一个元素后面添加一个无穷大的元素, 这样就不用考虑边界问题了</p>
<p><br></p>
<h4 id="分析-merge-sort-的正确性"><a href="#分析-merge-sort-的正确性" class="headerlink" title="分析 merge sort 的正确性"></a>分析 merge sort 的正确性</h4><p><img src="/Blog/intro/cmpt307/merge_sort_2.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/merge_sort_3.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/merge_sort_4.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p>Merge sort 的 running time</p>
<ul>
<li>让 $T(n)$ 作为 Merge sort 的 running time. $T(1) = c, c&gt;0$ c is constant</li>
<li>Divide array of size <em>n</em> takes $c_1n$ time, $c_1&gt;0$ a constant</li>
<li>Recursion on an array of size $n/2$ takes $T(n/2)$ time</li>
<li>Merge two arrays of size n/2 takes $c_2n$ times, $c_2 &gt; 0$ a constant</li>
<li>$T(n) = c_1n+T(n/2)+T(n/2)+c_2n$</li>
<li>解决这个recurrence, 我们得到 $T(n) = O(n\log n)$</li>
</ul>
<p><img src="/Blog/intro/cmpt307/merge_sort_5.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p><br></p>
<h2 id="Asymptotic-Order-of-Groth"><a href="#Asymptotic-Order-of-Groth" class="headerlink" title="Asymptotic Order of Groth"></a>Asymptotic Order of Groth</h2><p>计算机科学中有几种 notation:</p>
<ul>
<li><strong>Big-oh notation</strong>: $t(n)$ is $O(t_1(n))$, 如果有常数 $c&gt;0, n_0&gt;0$ 使得: $0\le t(n) \le c t_1(n)$ $\forall n \ge n_0$ <ul>
<li>上界</li>
<li>例如 $t(n) = 5n^2+7n+4$, $t(n) = O(n^2)$ 而不是 $O(n^k)\ for\ 0 &lt; k&lt; 2$</li>
</ul>
</li>
</ul>
<p><br></p>
<ul>
<li><strong>Big-Omega notation:</strong> $t(n)$ is $\Omega(t_1(n))$, 如果有常数 $c&gt;0, n_0&gt;0$ 使得 $t(n) \ge c\cdot t_1(n) \ge0 ,\forall n\ge n_0$<ul>
<li>下界</li>
<li>例如 $t(n) = 5n^2+7n+4$, $t(n) = \Omega(n^k) ,\forall k\le2$ 而不是 $O(n^k)\ for\ 2 &lt; k$</li>
</ul>
</li>
</ul>
<p><br></p>
<ul>
<li><strong>Big-Theta notation:</strong> $t(n)$ is $\Theta(t_1(n))$ 如果有常数 $c_1,c_2&gt;0, n_0&gt;0$ , 使得 $0\le c_1 t_1(n) \le t(n) \le c_2t_1(n)$ for all $n \ge n_0$<ul>
<li>如果 $t(n)$ is $O(t_1(n))$ 同时 $t(n)$ is $\Omega(t_1(n))$, 那么 t(n) 就是 $\Omega(t_1(n))$  <strong>For tight (up to a constantfactor) upper and lower bounds on time/space complexit</strong></li>
<li>$t(n)=n^2+7n+4$, $t(n)$ is $\Theta(n^2)$ 而不是 $\Theta(n^k), \forall k\ne 2$</li>
</ul>
</li>
</ul>
<p><br></p>
<ul>
<li><strong>Lette-oh notation</strong>: $t(n)$ is $o(t_1(n))$ 如果对于任意常数 $c&gt;0$, 存在一个常数 $n_0&gt;0$ 使得$0\le t(n)\le ct_1(n), \forall n \ge n_0$ <ul>
<li>也可以表示为: $\lim_{n\to \inf} t(n)/t_1(n)=0$</li>
<li>$t(n)=n^2+7n+4$ is $o(n^k)$ for $k&gt;2$</li>
</ul>
</li>
</ul>
<p><br></p>
<ul>
<li><strong>Lettle-omega notation</strong>: $t(n)$ is $\omega(t_1(n))$ ,如果对于任意常数 $c&gt;0$, 存在一个常数 $n_0&gt;0$ 使得$0\le ct_1(n)\le t(n), \forall n \ge n_0$ <ul>
<li>也可以表示为: $\lim_{n\to \inf} t(n)/t_1(n)=\inf$</li>
<li>$t(n)=n^2+7n+4$ is $o(n^k)$ for $k&lt;2$</li>
</ul>
</li>
</ul>
<p><br></p>
<p><br></p>
<p>这些 notation 遵循下面的性质</p>
<p><img src="/Blog/intro/cmpt307/notations.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/notations_1.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/notations_2.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p>常见复杂度</p>
<p><img src="/Blog/intro/cmpt307/notations_3.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/notations_4.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p><img src="/Blog/intro/cmpt307/notations_5.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/notations_6.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/notations_7.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p><br></p>
<p><br></p>
<h3 id="Maximum-subarray-problem"><a href="#Maximum-subarray-problem" class="headerlink" title="Maximum subarray problem"></a>Maximum subarray problem</h3><p>使用分治算法解决问题</p>
<p>解决 max-subarray 问题</p>
<p>具体的问题描述可以参考<a target="_blank" rel="noopener" href="https://leetcode.com/problems/maximum-subarray/">leetcode53</a></p>
<p>简单来说就是求一个数组中的一段区间, 使得这段区间的值最大</p>
<p><br></p>
<p><strong>暴力解法</strong></p>
<p>一种直观的想法就是尝试所有的可能. 再从中找到最小值</p>
<p><img src="/Blog/intro/cmpt307/msa_1.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>通过这个图可以看出是一个$O(n^2)$ 的算法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123; <br>        <span class="hljs-type">int</span> max = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++)&#123;<br>            <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>            <span class="hljs-comment">// find max subarray [i...k]</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = i; k &lt;= n; k++)&#123;<br>                sum += nums[k];<br>                <span class="hljs-keyword">if</span>(sum &gt; max)&#123;<br>                    max = sum;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> max;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p><br></p>
<p>然而这道题可以使用分治算法</p>
<p>对于一个数组$A[1:n]$ 我们可以把它分为两个部分 $A[1:m] ,A[m+1:n]$</p>
<p>此时有三种可能:</p>
<ol>
<li>最大subarray在$A[1:m]$ 之间 ($A_l$)</li>
<li>最大subarray在$A[m+1:n]$ 之间 ($A_r$)</li>
<li>最大subarray在$A[i: j]$ 之间 $i\le m\le j$ ($A_c$)</li>
</ol>
<p>对于前两种可能, 递归求解即可.</p>
<p>而如果最大subarray在它们之间, 也很简单, 只要从mid这个点向两侧扩张即可.</p>
<p>对于这三种可能得到的结果, 选择它们中最大的那个值.</p>
<p>伪代码:</p>
<p><img src="/Blog/intro/cmpt307/msa_2.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/msa_3.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/msa_4.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <br>    <span class="hljs-comment">// find subarray cross mid from [l, r]</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getMaxCrossingSubArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> mid,</span></span><br><span class="hljs-params"><span class="hljs-function">                   <span class="hljs-type">int</span>&amp; ret_l, <span class="hljs-type">int</span>&amp; ret_r)</span></span>&#123;<br>        <span class="hljs-comment">// [l, mid]</span><br>        <span class="hljs-type">int</span> max_l = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> sum_l = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> c_i = mid+<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = mid; i &gt;= l; i--)&#123;<br>            sum_l += nums[i];<br>            <span class="hljs-keyword">if</span>(sum_l &gt; max_l)&#123;<br>                max_l = sum_l;<br>                c_i = i;<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-comment">// [mid+1, r]</span><br>        <span class="hljs-type">int</span> max_r = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> sum_r = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> c_j = mid;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = mid+<span class="hljs-number">1</span>; j &lt;= r; j++)&#123;<br>            sum_r += nums[j];<br>            <span class="hljs-keyword">if</span>(sum_r &gt; max_r)&#123;<br>                max_r = sum_r;<br>                c_j = j;<br>            &#125;<br>        &#125;<br>        <br>        ret_l = c_i;<br>        ret_r = c_j;<br>        <span class="hljs-keyword">return</span> max_l + max_r;<br>    &#125;<br>    <br>    <span class="hljs-comment">// find subarray from [l, r]</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getMaxSubArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span>&amp; ret_l, <span class="hljs-type">int</span>&amp; ret_r)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(l == r)&#123;<br>            ret_l = ret_r = l;<br>            <span class="hljs-keyword">return</span> nums[l];<br>        &#125;<br>        <br>        <span class="hljs-type">int</span> mid = (r+l)/<span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span> li = <span class="hljs-number">0</span>, lj = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> ri = <span class="hljs-number">0</span>, rj = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> ci = <span class="hljs-number">0</span>, cj = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> max_sum_l = <span class="hljs-built_in">getMaxSubArray</span>(nums, l, mid, li, lj);<br>        <span class="hljs-type">int</span> max_sum_r = <span class="hljs-built_in">getMaxSubArray</span>(nums, mid+<span class="hljs-number">1</span>, r, ri, rj);<br>        <span class="hljs-type">int</span> max_sum_c = <span class="hljs-built_in">getMaxCrossingSubArray</span>(nums, l, r, mid, ci, cj);<br>        <br>        <span class="hljs-comment">// find the max return value between 2 sub arrays</span><br>        <span class="hljs-type">int</span> ret_max;<br>        <span class="hljs-keyword">if</span>(max_sum_l &gt; max_sum_r)&#123;<br>            ret_l = li;<br>            ret_r = lj;<br>            ret_max = max_sum_l;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            ret_l = ri;<br>            ret_r = r;<br>            ret_max = max_sum_r;<br>        &#125;<br>        <br>        <span class="hljs-comment">// if ci and cj are valid and the sum is biggest</span><br>        <span class="hljs-keyword">if</span>(ci &lt;= cj &amp;&amp; max_sum_c &gt; ret_max)&#123;<br>            ret_l = ci;<br>            ret_r = cj;<br>            ret_max = max_sum_c;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> ret_max;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">getMaxSubArray</span>(nums, <span class="hljs-number">0</span>, nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>, l, r);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p><br></p>
<p><br></p>
<p>证明算法的正确性:</p>
<p><img src="/Blog/intro/cmpt307/msa_5.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/msa_6.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/msa_7.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p>分析算法:</p>
<p><img src="/Blog/intro/cmpt307/msa_8.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p><br></p>
<h3 id="使用分治算法的矩阵乘法"><a href="#使用分治算法的矩阵乘法" class="headerlink" title="使用分治算法的矩阵乘法"></a>使用分治算法的矩阵乘法</h3><p>传统的矩阵乘法算法是写三层loop:</p>
<p><img src="/Blog/intro/cmpt307/matrix_m.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>然而使用分治算法, 我们可以这样:</p>
<p>我们可以把一个大的矩阵看作是一个(2, 2)的矩阵</p>
<p><img src="/Blog/intro/cmpt307/matrix_m_1.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>而这四个元素每一个又分别是一个矩阵</p>
<p><img src="/Blog/intro/cmpt307/matrix_m_2.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p>此时矩阵乘法就变成这样</p>
<p><img src="/Blog/intro/cmpt307/matrix_m_3.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>对于每一个元素的乘法, 又是一个小的矩阵乘法</p>
<p><br></p>
<p>因此算法就是这样</p>
<p><img src="/Blog/intro/cmpt307/matrix_m_4.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>然而这也的算法依然是$O(n^3)$ 的算法, 并没有明显的提升.</p>
<p><br></p>
<p>如何让它的速度更快?</p>
<p>上面的操作中有8个矩阵乘法运算, 我们要减少这个计算量</p>
<p>我们先计算这样的10个矩阵</p>
<p><img src="/Blog/intro/cmpt307/matrix_m_5.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>之后就在计算7次矩阵乘法</p>
<p><img src="/Blog/intro/cmpt307/matrix_m_6.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<blockquote>
<p>虽然我们减少了乘法的操作, 但是加法与减法的操作增加了. 也就是说时间复杂度的常数项增加了</p>
</blockquote>
<p>为什么这个结果是正确的? 这个可以用数学证明出来</p>
<p>// TODO 证明</p>
<p><br></p>
<p><img src="/Blog/intro/cmpt307/matrix_m_7.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p><br></p>
<h2 id="Master-Theorem"><a href="#Master-Theorem" class="headerlink" title="Master Theorem"></a>Master Theorem</h2><p><img src="/Blog/intro/cmpt307/master.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>把一个问题分解为 $a$ 个子问题, 每个子问题的数据量是 $n/b$</p>
<p><img src="/Blog/intro/cmpt307/master_1.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p><br></p>
<h2 id="Randomized-Algorithms-and-Average-Case-Analysis"><a href="#Randomized-Algorithms-and-Average-Case-Analysis" class="headerlink" title="Randomized Algorithms and Average Case Analysis"></a>Randomized Algorithms and Average Case Analysis</h2><p>ALG-Example:</p>
<p>假设有一个算法是这样</p>
<p>传入一个size n 的序列 $a_1, a_2\cdots a_n$</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pseudocode">x = 0;<br>for i = 1 to n do:<br>	if a[i] &gt; x:<br>		x = a[i];<br>		call f(a[i]);<br></code></pre></td></tr></table></figure>
<p>就是说每当我们遇见一个数, 它比它前面所有值都大时, 我们就调用一个函数$f$</p>
<p>假设函数 $f$ 的运行时间是 $t$</p>
<p>那么这个算法的运行时间是多少?</p>
<p><br></p>
<p>假设 $f$ 被调用了 $k$ 次, 那么运行时间就是 $O(n+kt)$, 最坏的情况下 $(a_1&lt;a_2&lt;\cdots &lt;a_n), k=n$ 此时的时间复杂度就是$O(nt)$</p>
<p>而在最好的情况下 $(a_1 &gt; a_2&gt;\cdots &gt; a_n), k=1$ 因此此时的时间复杂度就是 $O(n+t)$</p>
<p>那么 average running time 是多少?</p>
<p><br></p>
<p><strong>Average running time analysis</strong></p>
<ul>
<li><p>An assumption on the distribution of inputs</p>
<p>Let $A={A_1,… A_r}$ be the set of possible input sequences ($r=n!$)</p>
<p>Let $p(A<em>j)\ge 0$ be the probability that $A_j$ is an input $\sum</em>{j=1}^rp(A_j)=1$</p>
<p>Let $k_j$ be the number function $f$ is called when $A_j$ is the input</p>
</li>
<li><p>Average running time</p>
<p>Average value of $k$: $\bar k=\sum_{j=1}^{r} p(A_j)\cdot k_j$</p>
<p>Average running time: $O(n+kt)$</p>
</li>
<li><p>Uniform distribution: $p(A_j)=1/r, 1\le j\le r$</p>
</li>
</ul>
<p><br></p>
<p><br></p>
<h3 id="Randomized-Algorithms"><a href="#Randomized-Algorithms" class="headerlink" title="Randomized Algorithms"></a>Randomized Algorithms</h3><p>如果一个算法不仅仅被input决定, 还被一些outcome random event 影响, 那么它就是随机算法(例如用random number generator)</p>
<ul>
<li><p>Let <strong>RANDOM</strong>(a, b) be a function returns an integer $j$ with$a\le j\le b$</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs pseudocode">j = Random(l, r)<br><br>input sequence A[j] of A:<br><br>x = 0;<br>for i = 1 to n do:<br>	if a[i] &gt; x:<br>		x = a[i]<br>		call f(a[i])<br></code></pre></td></tr></table></figure>
<p><br></p>
</li>
</ul>
<p>Equal likehood assumption: In an experiment, each of all possible outcomes has the <strong>same likehood</strong> of occurrence. or the same probability of occurrence.</p>
<p>Under the equal like hood assumption, let $S$ be the sample space for an experiment. For $a \in S$ and $A \subseteq S$</p>
<script type="math/tex; mode=display">
Pr[\{a\}]=Pr[a]=\frac 1{|S|}\tag 1</script><script type="math/tex; mode=display">
Pr[A]=\frac {|A|}{|S|}\tag 2</script><ol>
<li>probability that $a$ occurs</li>
<li>probability $A$ occurs</li>
</ol>
<p>例如:</p>
<ul>
<li><p>Probability of getting H(head) in tossing a coin:</p>
<p>Sample space $S={H, T}$ event $A={H}, Pr[A]=\frac {|A|}{|S|}=\frac 12$</p>
</li>
<li><p>Probability of gettting event number in rolling a dice:</p>
<p>$S={1,2,3,4,5,6}$ event $A={2,4,6}, Pr[A]=\frac {|A|}{|S|}=\frac 36=\frac 12$</p>
</li>
</ul>
<p><img src="/Blog/intro/cmpt307/dis_var.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p><br></p>
<p><strong>Average running time of Random ALG-Example</strong></p>
<ul>
<li><p>Random variable $X<em>i=1$ if $f(a_i)$ is called, otherwise $X_i=0$, $X=\sum</em>{i=1}^n X_i$</p>
</li>
<li><p>$E[X<em>i]=Pr[a_i&gt;x]=Pr[a_i&gt;max</em>{i\le c\le i-1}a_c]$</p>
<p>On the uniform distribution assumtion, every interger in a sequence $a_1…a_i$ is equally likely to be the maximun, So $E[X_i]=1/i$</p>
</li>
<li><p>$E[X] = E[\sum<em>{i=1}^nX_i]=\sum</em>{i=1}^nE[X<em>i]=\sum</em>{i=1}^n1/i=\ln n+O(1)$</p>
</li>
</ul>
<p>The average running time is $O(n+tE[X])=O(n+t\log n)$</p>
<p><br></p>
<p><br></p>
<h2 id="Heap-Sort"><a href="#Heap-Sort" class="headerlink" title="Heap Sort"></a>Heap Sort</h2><p><img src="/Blog/intro/cmpt307/heapify.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>具体的 heap sort 和 heapify 都在其他的文章中写了, 这里主要讲解一些证明</p>
<p>max leap 的 properity: $A[\lfloor i/2 \rfloor] \ge A[i]$</p>
<p><img src="/Blog/intro/cmpt307/heap.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/heap_1.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>为什么是 $O(\sum_{k=1}^{\log_2n}kn/2^k)$</p>
<p>当对一个node进行shift down, 需要k步, $k$ 是高度, 而这一层一共有$n/2^k$个node, $O(\sum<em>{k=1}^{\log_2n}kn/2^k) = O(n \sum</em>{k=1}^{\log_2n}k/2^k)=O(n)$</p>
<p><br></p>
<p>heap sort</p>
<p><img src="/Blog/intro/cmpt307/heap_sort.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p>heap increase key: 增加某个值</p>
<p><img src="/Blog/intro/cmpt307/heap_sort_1.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/heap_sort_2.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/heap_sort_3.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p><br></p>
<h2 id="Quick-Sort"><a href="#Quick-Sort" class="headerlink" title="Quick Sort"></a>Quick Sort</h2><p><img src="/Blog/intro/cmpt307/quick_sort.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/quick_sort_1.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/quick_sort_2.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/quick_sort_3.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/quick_sort_4.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p><br></p>
<h2 id="Randomized-QuickSort"><a href="#Randomized-QuickSort" class="headerlink" title="Randomized QuickSort"></a>Randomized QuickSort</h2><p><img src="/Blog/intro/cmpt307/quick_sort_5.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/quick_sort_6.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>每个元素都和pivot比较<strong>一次</strong></p>
<p><img src="/Blog/intro/cmpt307/quick_sort_7.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/quick_sort_8.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<h2 id="Comparison-Base-Sorting-Alogrighm-的极限"><a href="#Comparison-Base-Sorting-Alogrighm-的极限" class="headerlink" title="Comparison Base Sorting Alogrighm 的极限"></a>Comparison Base Sorting Alogrighm 的极限</h2><p><img src="/Blog/intro/cmpt307/quick_sort_9.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/quick_sort_10.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p><br></p>
<p>一些不基于比较的排序算法可以在linear time 进行排序</p>
<p><img src="/Blog/intro/cmpt307/quick_sort_11.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/quick_sort_12.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/quick_sort_13.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/quick_sort_14.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/quick_sort_15.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/quick_sort_16.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p><br></p>
<h2 id="Redix-Sort"><a href="#Redix-Sort" class="headerlink" title="Redix Sort"></a>Redix Sort</h2><p><img src="/Blog/intro/cmpt307/radix.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/radix_1.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<h2 id="Bucket-Sort"><a href="#Bucket-Sort" class="headerlink" title="Bucket Sort"></a>Bucket Sort</h2><p><img src="/Blog/intro/cmpt307/radix_2.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/radix_3.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/radix_4.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p><br></p>
<h2 id="Medians-and-Order-Statistics"><a href="#Medians-and-Order-Statistics" class="headerlink" title="Medians and Order Statistics"></a>Medians and Order Statistics</h2><p><img src="/Blog/intro/cmpt307/radix_5.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/radix_6.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/radix_7.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/radix_8.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>这种方法会找到一个x, 这个x距离median很近, 之后进行paration</p>
<p><br></p>
<p><br></p>
<h2 id="Hash-Tables"><a href="#Hash-Tables" class="headerlink" title="Hash Tables"></a>Hash Tables</h2><p><strong>Dictionary:</strong>maintain a dynamic set $S$, each $x\in S$ has a key $x.key$ from $U={0,1,…n-1}$ so that insert, search and delete operations in $S$ is efficient.</p>
<p><img src="/Blog/intro/cmpt307/hash_table.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p>然而我们可以使用一个小的array</p>
<p><img src="/Blog/intro/cmpt307/hash_table_1.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/hash_table_2.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p>n is an upper bound on the number of keys in $S$</p>
<p><img src="/Blog/intro/cmpt307/hash_table_3.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/hash_table_4.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/hash_table_5.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/hash_table_6.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/hash_table_7.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/hash_table_8.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<blockquote>
<p>Theorem: Assume a hash function $h$ is selected at random from a universal family $H$ of hash functions and used to hash $n$ keys into a table $T$ of size $m$.For a key $x$ not in $S$, the expected length of the list that $x$ hashed to is at most$n/m$</p>
</blockquote>
<p><img src="/Blog/intro/cmpt307/hash_table_9.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/hash_table_10.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p>证明 $H_{pm}$ 是 universal</p>
<p>让 $k, l$ 为两个不同的key. 我们要证明 $Pr[h<em>{ab}(k)=h</em>{ab}(l)] \le 1/m$ 对于正整数 a,b, 让 $r=(ak+b) \mod p$ 同时 $s=(al+b) \mod p$.  那么:</p>
<script type="math/tex; mode=display">
r-s=a(k-l) \mod p</script><p> 由于 $a&gt;0$ 同时 $|k-l|&gt;0$. 因此 $a(k-l) \mod p$ 不为 0.</p>
<p>所以$r \ne s$, mod $p$ 不会产生碰撞</p>
<p>由于:</p>
<script type="math/tex; mode=display">
a=((r-s)({(k-l)^{-1} \mod p})) \mod p</script><script type="math/tex; mode=display">
 b=(r-ak) \mod p</script><p><img src="/Blog/intro/cmpt307/hash_table_11.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/hash_table_12.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p><br></p>
<h3 id="Open-addressing"><a href="#Open-addressing" class="headerlink" title="Open addressing"></a>Open addressing</h3><p>direct addressing使用link list来解决哈希冲突. open addressing 则是使用一个非常大的array</p>
<p><img src="/Blog/intro/cmpt307/hash_table_13.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/hash_table_14.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/hash_table_15.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/hash_table_16.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/hash_table_17.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/hash_table_18.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p><br></p>
<h2 id="Binary-Search-Tree"><a href="#Binary-Search-Tree" class="headerlink" title="Binary Search Tree"></a>Binary Search Tree</h2><p><img src="/Blog/intro/cmpt307/bst.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/bst_1.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>右边的树是这样: 每个节点的所有子节点用单向链表连接. 而父亲节点只指向第一个子节点.</p>
<p><img src="/Blog/intro/cmpt307/bst_2.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/bst_3.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/bst_4.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/bst_5.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/bst_6.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/bst_7.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/bst_8.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/bst_9.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/bst_10.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/bst_11.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/bst_12.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p><br></p>
<h2 id="Dynamic-Progrmming"><a href="#Dynamic-Progrmming" class="headerlink" title="Dynamic Progrmming"></a>Dynamic Progrmming</h2><ul>
<li>动态规划：将问题划分为重叠(overlapping)的子问题，为每个子问题找到一个解决方案，并将解决方案保留在表中，然后根据表中的解决方案查找原始问题的解决方案。 贝尔曼（Bellman）在1950年代率先进行了动态编程的系统研究</li>
<li><p>分治算法: 将一个问题划分为独立(independent)的子问题，找出每个子问题的解，并将子问题的解与原问题的解相结合(其实对于重叠子问题, 可以用一张表记录子问题的解, 这样来避免重复的计算)</p>
</li>
<li><p>Main steps to develop a dynamic programming algorithm</p>
<ol>
<li>Characterize the structure of an optimal solution.</li>
<li>Recursively define the value of an optimal solution</li>
<li>Compute the value of an optimal solution, usually in a bottom up fashion</li>
<li>Construct an optimal solution from computed information</li>
</ol>
</li>
</ul>
<p><br></p>
<h3 id="Rod-cutting-problem"><a href="#Rod-cutting-problem" class="headerlink" title="Rod cutting problem"></a>Rod cutting problem</h3><p><img src="/Blog/intro/cmpt307/dynamic_pro.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/dynamic_pro_1.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/dynamic_pro_2.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>top-down 方法, 使用递归</p>
<p><img src="/Blog/intro/cmpt307/dynamic_pro_3.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>top-down 方法, 使用递归, 使用表来记忆子问题的结果</p>
<p><img src="/Blog/intro/cmpt307/dynamic_pro_4.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/dynamic_pro_5.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/dynamic_pro_6.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/dynamic_pro_7.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/dynamic_pro_8.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<blockquote>
<p>对于这个问题, 我有我的见解. 我们不用计算所有的 $p[i] + r[n-i]$ pairs, 反正最终都会被分为长度为1,2,3,4的rod, 我们只需要判断 <1, n-1>, <2, n-2>, <3, n-3>, <4, n-4> 这4个值中最大的pairs即可, 这样算法就变成 O(n) 级别的</p>
</blockquote>
<p><br></p>
<h3 id="Matrix-chain-multiplication"><a href="#Matrix-chain-multiplication" class="headerlink" title="Matrix-chain multiplication"></a>Matrix-chain multiplication</h3><p><img src="/Blog/intro/cmpt307/dynamic_pro_9.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/dynamic_pro_10.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>矩阵乘法的计算顺序就非常重要</p>
<p>那么如何才能找到一个最好的矩阵乘法的顺序?</p>
<p><img src="/Blog/intro/cmpt307/dynamic_pro_11.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/dynamic_pro_12.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/dynamic_pro_13.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/dynamic_pro_14.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/dynamic_pro_15.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/dynamic_pro_16.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p><br></p>
<h3 id="Longest-common-sequence-LCS-problem"><a href="#Longest-common-sequence-LCS-problem" class="headerlink" title="Longest common sequence(LCS) problem"></a>Longest common sequence(LCS) problem</h3><p><img src="/Blog/intro/cmpt307/dynamic_pro_17.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/dynamic_pro_18.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/dynamic_pro_19.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/dynamic_pro_20.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/dynamic_pro_21.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/dynamic_pro_22.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/dynamic_pro_23.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<h3 id="Optimal-binary-search-tree-BST"><a href="#Optimal-binary-search-tree-BST" class="headerlink" title="Optimal binary search tree (BST)"></a>Optimal binary search tree (BST)</h3><p><img src="/Blog/intro/cmpt307/dynamic_pro_24.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/dynamic_pro_25.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/dynamic_pro_26.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/dynamic_pro_27.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>这里有一个很重要的性质: 如果一个tree $T$ 是Optimal binary search tree, 那么它的所有子树也都是Optimal binary search tree</p>
<p><img src="/Blog/intro/cmpt307/dynamic_pro_28.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/dynamic_pro_29.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>根据上面的性质就可以构建出Bellman Equation</p>
<p><img src="/Blog/intro/cmpt307/dynamic_pro_30.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/dynamic_pro_31.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/dynamic_pro_32.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/dynamic_pro_33.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<h3 id="0-1-背包问题"><a href="#0-1-背包问题" class="headerlink" title="0-1 背包问题"></a>0-1 背包问题</h3><p><img src="/Blog/intro/cmpt307/dynamic_pro_34.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/dynamic_pro_35.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/dynamic_pro_36.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/dynamic_pro_37.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p><br></p>
<h2 id="贪心算法-Greedy-Algorithm"><a href="#贪心算法-Greedy-Algorithm" class="headerlink" title="贪心算法(Greedy Algorithm)"></a>贪心算法(Greedy Algorithm)</h2><blockquote>
<p>贪心算法实现简单思路也简单, 但难就难在如何证明一个问题可以通过贪心算法来解决</p>
</blockquote>
<p><img src="/Blog/intro/cmpt307/greedy_1.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>算法很简单, 只要每次选择最先完成的一个任务, 之后以这个任务的结束时间作为基准, 再以这个时间之后的所有任务中挑选最先完成的一个任务</p>
<p>上面的例子中最多可以完成 b, e, h 三个任务</p>
<p><img src="/Blog/intro/cmpt307/greedy_2.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>首先, 这个问题是可以用动态规划来解决的</p>
<p><img src="/Blog/intro/cmpt307/greedy_3.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/greedy_4.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>算法是先把所有的任务根据结束时间排序, 之后第一个任务就是我要选择的$a_1$ 之后根据$a_1$ 的结束之间, 找到其余所有开始时间大于$a_1$结束时间的其他任务 $S_1$, 在从$S_1$ 中找到最早结束的任务$a_4$作为接下来选择的任务, 把$S_1$中开始时间大于$a_4$ 结束时间的任务组合称为$S_4$ 不断重复这个过程</p>
<p><img src="/Blog/intro/cmpt307/greedy_5.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/greedy_6.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p><br></p>
<p>如何设计一个贪心算法?</p>
<ul>
<li>Cast the optimization problem as one in which a choice leaves one subproblem.</li>
<li>证明贪心的选择会个出这个问题的解  在贪婪选择后, 表现出最优子结构，即在，剩余的子问题具有以下性质：如果将子问题的最优解与贪婪选择相结合，则可以获得最优解。</li>
</ul>
<p>In dynamic programming, a solution to a subproblem is computed based on solutions to <strong>multiple</strong> smaller subproblems.</p>
<p>In greedy, to find a solution to a subproblem, the number of smaller subproblems considered is reduced to one.</p>
<p><br></p>
<p>Greedy-choice property: a global optimal solution can be computed by making locally optimal greedy choices, each choice finds a solution for a (larger) subprobelm.</p>
<p><strong>Optimal substructure</strong>(最优子结构): Optimal solution contains optimal solutions to subproblems.</p>
<p><br></p>
<p><br></p>
<p><img src="/Blog/intro/cmpt307/greedy_7.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/greedy_8.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/greedy_9.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p><br></p>
<h2 id="霍夫曼编码问题"><a href="#霍夫曼编码问题" class="headerlink" title="霍夫曼编码问题"></a>霍夫曼编码问题</h2><p><img src="/Blog/intro/cmpt307/huffman.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/huffman_1.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/huffman_2.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>参考<a href="https://daolinzhou.github.io/Blog/2020/07/23/Huffman-Tree/">哈夫曼树</a></p>
<p><img src="/Blog/intro/cmpt307/huffman_3.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/huffman_4.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<blockquote>
<p>有个typo, 应该是<code>z.right=y=...</code></p>
</blockquote>
<p><br></p>
<h2 id="Amortized-Analysis"><a href="#Amortized-Analysis" class="headerlink" title="Amortized Analysis"></a>Amortized Analysis</h2><p>Average the time required to perform a sequence of operations.</p>
<p>Give the average performance of each operation in the worst case. no probability is involved.</p>
<p>有三种技巧</p>
<ol>
<li><p>Aggregate analysis: 确定upper bound $T(n)$ on the total cost of a sequence of $n$ operations, 之后用 $T(n)/n$ 作为 amortized cost of each operation</p>
</li>
<li><p>Accounting method:  determine an amortized cost of each operation; 不同type的operation可能有不同的amortized costs</p>
<p>overcharge some operations early in the sequence, store the overcharge as “prepaid credit”  and the credits pay for later operations that are charged less than they actually cost</p>
</li>
<li><p>Potential method: 类似于accounting method, 但是credits are maintained as “potential energy” for a whole sequence rather than individual operations</p>
</li>
</ol>
<p><img src="/Blog/intro/cmpt307/Amortized_analysis.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p><br></p>
<p>假设我们用一个binary array $A$表示一个数$x$, 数组长度为$k$</p>
<p>$A[0]$ 是 lowest-order bit, $A[k-1]$ 是 highest-order bit. $x=\sum_{i=0}^{k-1}2^iA[i]$</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs pseudocode">Increment(A) /*Add 1 mod 2^k to A*/<br>	i = 0;<br>	while i &lt; k and A[i] = 1 do:<br>		A[i] = 0;<br>		i ++;<br>	if i &lt; k:<br>		A[i] = 1;<br></code></pre></td></tr></table></figure>
<ul>
<li>Cost of a sequence of $n$ increments to $A$<ul>
<li>Brute-force analysis: $O(k)$ for one increment, $O(kn)$ for $n$ increment</li>
<li>Aggregate analysis:<ul>
<li>$A[0]$ is filpped once in every $2^0=1$ increment</li>
<li>$A[1]$ is flipped once in every $2^1=2$ iincrement</li>
<li>$A[i]$ is flipped once in every $2^i$ increment</li>
<li>Total cost is $\sum<em>{i=0}^{k-1}\lfloor n/2^i\rfloor &lt; n\sum</em>{i=0}^{\text{inf}}(1/2^i)=2n$</li>
<li>Amortized cost per increment is $O(n)/n=O(1)$</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/Blog/intro/cmpt307/Amortized_analysis_1.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p><br></p>
<h3 id="Accounting-Method"><a href="#Accounting-Method" class="headerlink" title="Accounting Method"></a>Accounting Method</h3><ul>
<li>给不同的operation不同的cost, cost charged to an operation is the amortized cost of the operation</li>
</ul>
<p>对于operation $i$, 定义$\hat c_i$ be the amortized cost, $c_i$ be the real cost of i. For $\hat c_i \ge c_i$, $\hat c_i -c_i$ is called credit of $i$</p>
<p>For sequence of operations, $\sum<em>{i=1}^n \hat c_i \ge \sum</em>{i=1}^n c_i$ is always required</p>
<p>Analysis for a sequence of $n$ PUSH, POP and MultiPOP operations</p>
<ul>
<li>Real cost: PUSH 1; POP 1; MultiPOP $\min(|S|, k)$</li>
<li>Amortized cost: PUSH 2 (<strong>has credit 1, use to pay the pop of the pushed object</strong>); POP 0; MultiPOP 0</li>
<li>Total cost $T(n)\le 2n$ and average cost per operation is $O(n)/n=O(1)$</li>
</ul>
<p><br></p>
<p><br></p>
<p>用 Accounting Method 解决increment binary counter 问题</p>
<ul>
<li>Real cost of flipping a bit: 1</li>
<li>Amortized cost of flipping a bit: flip from 0 to 1 take cost <strong>2</strong>, flip from 1 to 0 take cost <strong>0</strong></li>
<li>每次加一 exactly one $0\to 1$ filp performed (except the counter is all 1). Total cost $T(n)\le 2n$ and average cost per increment is $O(n)/n=O(1)$</li>
</ul>
<p><br></p>
<h3 id="Potential-Method"><a href="#Potential-Method" class="headerlink" title="Potential Method"></a>Potential Method</h3><p>Credits are not associated with each operation, but use collectively as “potential energy” to pay for future operations</p>
<p>假设一个sequence of $n$ operations, 初始时的data structure$D_0$ For each $i=1,2,…n$ let $c_i$ be the real cost of $i$th iteration and $D_i$ be the data structure agter the $i$th operation. Potential function $\Phi (D_i)$ is a real number that is the potential associated with $D_i$</p>
<p>The amortized cost $\hat c_i$ of the ith operation w.r.t. $\Phi$ is</p>
<script type="math/tex; mode=display">
\hat c_i=c_i+\Phi(D_i)-\Phi(D_{i-1})</script><p>The total amortized cost of $n$ operations is</p>
<script type="math/tex; mode=display">
\sum_{i=1}^n \hat c_i=\sum_{i=1}^n(c_i+\Phi(D_i)-\Phi(D_{i-1}))=\sum_{i=1}^nc_i+\Phi(D_n)-\Phi(D_{0})</script><p>Usually $\Phi(D_0)=0$ and  $\Phi(D_i)\ge \Phi(D_0)$ for all i</p>
<p><br></p>
<p><br></p>
<h4 id="Analysis-for-stack-operation"><a href="#Analysis-for-stack-operation" class="headerlink" title="Analysis for stack operation"></a>Analysis for stack operation</h4><p>$\Phi(D_0)=0$ for each $1 \le i \le n, \Phi(D_i)=|S|$ the number of objects in $S$ after the ith operation</p>
<p>这里 $\Phi(D_i)$ 代表在第i次操作后stack中的元素</p>
<ul>
<li>If the $i$th operation is PUSH, then $\hat c<em>i = c_i+\Phi(D_i)-\Phi(D</em>{i-1})=1+1=2$</li>
<li>If the $i$ th operation is POP, then $\hat c<em>i = c_i+\Phi(D_i)-\Phi(D</em>{i-1})=1-1=0$</li>
<li>If the $i$ th operation is MultiPOP then $\hat c<em>i = c_i+\Phi(D_i)-\Phi(D</em>{i-1})=c_i+(-c_i)=0$</li>
</ul>
<p>就变成和Accounting一样的问题了</p>
<p><br></p>
<h4 id="Analysis-for-incrementing-binary-counter"><a href="#Analysis-for-incrementing-binary-counter" class="headerlink" title="Analysis for incrementing binary counter"></a>Analysis for incrementing binary counter</h4><p><img src="/Blog/intro/cmpt307/Amortized_analysis_2.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/Amortized_analysis_3.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<h2 id="Dynamic-tables"><a href="#Dynamic-tables" class="headerlink" title="Dynamic tables"></a>Dynamic tables</h2><p>Store a non-predictable number $n$ of objects in a table.</p>
<ul>
<li><p>Allocate a table $T$ with size $T.size$</p>
</li>
<li><p>When $n &gt; T.size$, allocate a new table $T’$ with $T’.size&gt;T.size$ and store all objects in $T’$(table expansion)</p>
</li>
<li>When $n &lt;&lt; T.size$, allocate a new table $T’’$, $T’’.size &lt; T.size$ and store all objects in $T’’$ (table contraction)</li>
</ul>
<p>$T$ 支持 Table-Insert (插入一个元素) 和 Table-Delete(删除一个元素)</p>
<ul>
<li>Table-Insert 如果没有table expansion, $O(1)$ 时间, 反之 $O(T.size)$ 时间</li>
<li>Table-Delete 如果没有table contraction, $O(1)$ 时间, 反之 $O(T.size)$ 时间</li>
</ul>
<p>我们要证明amortized cost of per Table-Insert/Table-Delete is $O(1)$</p>
<p><img src="/Blog/intro/cmpt307/dynamic_table.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/dynamic_table_1.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/dynamic_table_2.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/dynamic_table_3.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/dynamic_table_4.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/dynamic_table_5.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/dynamic_table_6.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<h2 id="B-树"><a href="#B-树" class="headerlink" title="B 树"></a>B 树</h2><p>Balanced tree</p>
<p><img src="/Blog/intro/cmpt307/b_tree.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/b_tree_1.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/b_tree_2.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/b_tree_3.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/b_tree_4.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/b_tree_5.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/b_tree_6.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/b_tree_7.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>更具体的操作就不细讲了.</p>
<p><br></p>
<p><br></p>
<h2 id="斐波那契堆-Fibonacci-Heaps"><a href="#斐波那契堆-Fibonacci-Heaps" class="headerlink" title="斐波那契堆 Fibonacci Heaps"></a>斐波那契堆 Fibonacci Heaps</h2><p><img src="/Blog/intro/cmpt307/fibonacci_heap.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/fibonacci_heap_1.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/fibonacci_heap_2.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>这些提升只是在理论层面(和红黑树类似), 而这个数据结构非常复杂难以实现</p>
<p><img src="/Blog/intro/cmpt307/fibonacci_heap_3.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/fibonacci_heap_4.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>每次都想root list中插入元素, 当插入一定元素时, 就rearrange, 使它变成Consoldated Fibonacci heap</p>
<p><br></p>
<p><br></p>
<h2 id="Disjoint-Set"><a href="#Disjoint-Set" class="headerlink" title="Disjoint Set"></a>Disjoint Set</h2><p>又被称为 Union-Find 并查集</p>
<p>对于用数组实现并查集的方法以前写过了. 这里写linked list的实现方法</p>
<p><img src="/Blog/intro/cmpt307/fibonacci_heap_5.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/fibonacci_heap_6.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/fibonacci_heap_7.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/fibonacci_heap_8.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/fibonacci_heap_9.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/fibonacci_heap_10.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/fibonacci_heap_11.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/fibonacci_heap_12.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/fibonacci_heap_13.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/fibonacci_heap_14.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%98%BF%E5%85%8B%E6%9B%BC%E5%87%BD%E6%95%B8">阿克曼函数</a></p>
<p><br></p>
<h2 id="Graph-Algorithm"><a href="#Graph-Algorithm" class="headerlink" title="Graph Algorithm"></a>Graph Algorithm</h2><p><img src="/Blog/intro/cmpt307/graph_1.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/graph_2.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/graph_3.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/graph_4.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/graph_5.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/graph_6.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/graph_7.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/graph_8.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/graph_9.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/graph_10.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<h3 id="基本图论算法"><a href="#基本图论算法" class="headerlink" title="基本图论算法"></a>基本图论算法</h3><p><img src="/Blog/intro/cmpt307/graph_alg.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/graph_alg_1.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/graph_alg_2.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/graph_alg_3.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/graph_alg_4.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/graph_alg_5.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/graph_alg_6.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/graph_alg_7.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/graph_alg_8.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/graph_alg_9.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/graph_alg_10.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/graph_alg_11.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/graph_alg_12.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/graph_alg_13.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/graph_alg_14.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/graph_alg_15.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/graph_alg_16.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/graph_alg_17.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>根据finish time 的 decreacing order 排成一排</p>
<p><img src="/Blog/intro/cmpt307/graph_alg_18.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/graph_alg_19.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/graph_alg_20.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<h3 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h3><p><img src="/Blog/intro/cmpt307/min_span_tree.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/min_span_tree_1.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/min_span_tree_2.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/min_span_tree_3.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/min_span_tree_4.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/min_span_tree_5.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/min_span_tree_6.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/min_span_tree_7.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/min_span_tree_8.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/min_span_tree_9.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/min_span_tree_10.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/min_span_tree_11.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<h3 id="单源最短路径"><a href="#单源最短路径" class="headerlink" title="单源最短路径"></a>单源最短路径</h3><p><img src="/Blog/intro/cmpt307/min_span_tree_12.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/min_span_tree_13.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/shortest_path.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/shortest_path_1.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/shortest_path_2.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/shortest_path_3.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/shortest_path_4.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/shortest_path_5.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/shortest_path_6.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/shortest_path_7.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/shortest_path_8.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/shortest_path_9.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/shortest_path_10.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/shortest_path_11.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/shortest_path_12.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/shortest_path_13.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/shortest_path_14.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/shortest_path_15.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/shortest_path_16.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/shortest_path_17.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/shortest_path_18.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/shortest_path_19.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/shortest_path_20.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/shortest_path_21.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/shortest_path_22.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/shortest_path_23.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/shortest_path_24.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/shortest_path_25.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/shortest_path_26.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/shortest_path_27.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<h3 id="All-Pairs-Shortest-path"><a href="#All-Pairs-Shortest-path" class="headerlink" title="All-Pairs Shortest path"></a>All-Pairs Shortest path</h3><p><img src="/Blog/intro/cmpt307/shortest_path_28.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/shortest_path_29.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/shortest_path_30.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/shortest_path_31.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/shortest_path_32.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/shortest_path_33.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/shortest_path_34.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/shortest_path_35.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/shortest_path_36.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/shortest_path_37.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/shortest_path_38.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>由于这个可以看作是矩阵乘法, 所以我们可以直接求 $W_1, W_2, W_4, W_8\cdots$ 将矩阵平方, 来加速计算</p>
<p><br></p>
<p><img src="/Blog/intro/cmpt307/floyd.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/floyd_1.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/floyd_2.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/floyd_3.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/floyd_4.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/floyd_5.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/floyd_6.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/floyd_7.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/floyd_8.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/floyd_9.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/floyd_10.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/floyd_11.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/floyd_12.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cmpt307/floyd_13.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>这个算法的核心思想就是把一个有负权边无负权环的图转换为没有负权边的图, 再用 Dijkstra 求解</p>
<p>重点是$h(v)$的选取(新建一个点, 使用bellman ford获得点到所有点的最短路径, 顺便检测负权环), 以及定义的新边不会影响负权环</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/Blog/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">算法与数据结构</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/Blog/tags/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/">算法分析</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/Blog/2021/04/29/FFT/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">FFT</span>
                        <span class="visible-mobile">Vorheriger</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/Blog/2021/01/11/Numerical-Analysis/">
                        <span class="hidden-mobile">Numerical Analysis</span>
                        <span class="visible-mobile">Nächster</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;TOC</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Suchen</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">Stichwort</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/Blog/js/events.js" ></script>
<script  src="/Blog/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/Blog/js/local-search.js" ></script>



  
    <script  src="/Blog/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
        typing(title);
      
    })(window, document);
  </script>





  

  
    <!-- MathJax -->
    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']]
        },
        loader: {
          load: ['ui/lazy']
        },
        options: {
          renderActions: {
            findScript: [10, doc => {
              document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
                const display = !!node.type.match(/; *mode=display/);
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
                const text = document.createTextNode('');
                node.parentNode.replaceChild(text, node);
                math.start = { node: text, delim: '', n: 0 };
                math.end = { node: text, delim: '', n: 0 };
                doc.math.push(math);
              });
            }, '', false],
            insertedScript: [200, () => {
              document.querySelectorAll('mjx-container').forEach(node => {
                let target = node.parentNode;
                if (target.nodeName.toLowerCase() === 'li') {
                  target.parentNode.classList.add('has-jax');
                }
              });
            }, '', false]
          }
        }
      };
    </script>

    <script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js" ></script>

  











<!-- 主题的启动项 保持在最底部 -->
<script  src="/Blog/js/boot.js" ></script>


</body>
</html>
