

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/Blog/img/favicon.ico">
  <link rel="icon" href="/Blog/img/favicon.ico">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Daolin">
  <meta name="keywords" content="">
  
    <meta name="description" content="机器学习基础介绍, 机器学习分类 numpy数据基础">
<meta property="og:type" content="article">
<meta property="og:title" content="python3入门机器学习(1)">
<meta property="og:url" content="https://daolinzhou.github.io/Blog/2020/04/10/machine-learning/">
<meta property="og:site_name" content="Daolin&#39;s Repository">
<meta property="og:description" content="机器学习基础介绍, 机器学习分类 numpy数据基础">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/lris_flowers.PNG">
<meta property="article:published_time" content="2020-04-11T02:41:51.000Z">
<meta property="article:modified_time" content="2020-05-20T22:17:23.288Z">
<meta property="article:author" content="Daolin">
<meta property="article:tag" content="python3">
<meta property="article:tag" content="机器学习">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://daolinzhou.github.io/Blog/intro/lris_flowers.PNG">
  
  
  <title>python3入门机器学习(1) - Daolin&#39;s Repository</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/Blog/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"daolinzhou.github.io","root":"/Blog/","version":"1.8.14","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/Blog/local-search.xml"};
  </script>
  <script  src="/Blog/js/utils.js" ></script>
  <script  src="/Blog/js/color-schema.js" ></script>
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.1.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/Blog/">
      <strong>Daolin&#39;s Repo</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/Blog/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/Blog/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/Blog/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/Blog/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/Blog/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/Blog/intro/sincegate.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="python3入门机器学习(1)">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2020-04-10 19:41" pubdate>
        2020年4月10日 晚上
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      15k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      123 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">python3入门机器学习(1)</h1>
            
            <div class="markdown-body">
              <p>机器学习基础介绍, 机器学习分类</p>
<p>numpy数据基础</p>
<span id="more"></span>
<h1 id="机器学习基础"><a href="#机器学习基础" class="headerlink" title="机器学习基础"></a>机器学习基础</h1><p><br></p>
<h2 id="机器学习的数据"><a href="#机器学习的数据" class="headerlink" title="机器学习的数据"></a>机器学习的数据</h2><p>机器学习其实就是喂给我们的算法数据, 让我们的算法在数据中寻找相应的关系</p>
<p><img src="/Blog/intro/lris_flowers.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>使用注明的鸢尾花数据来说明</p>
<p>这个数据就是给出了很多鸢尾花相关的信息, 数据中主要包含三类鸢尾花</p>
<p>这个数据整体的信息是这个样子的:</p>
<p><img src="/Blog/intro/lris_flowers_1.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>总共包含150个数据信息, 对于每个数据信息给出了4个方面的信息: 萼片的长宽和花瓣的长宽</p>
<p><img src="/Blog/intro/lris_flowers_2.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>这样4个信息就描述了一朵花, 对于每一朵花都分属3种鸢尾花之一, 那么整个数据就可以表示成这个样子(这里只选出3条信息作为例子)</p>
<p><img src="/Blog/intro/lris_flowers_3.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><strong>关于数据的相关概念:</strong></p>
<ul>
<li><p>数据整体叫<strong>数据集 (data set)</strong></p>
</li>
<li><p>每一行数据称为一个<strong>样本 (sample)</strong></p>
</li>
<li>除去最后一列, 每一列表达样本的一个<strong>特征 (feature)</strong> , 或者可以理解成是一个属性</li>
<li>最后一列, 称为<strong>标记 (label)</strong>, 这也是机器想要去学习的内容</li>
</ul>
<p><img src="/Blog/intro/lris_flowers_4.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""> </p>
<p> 很显然X是一个矩阵, y是一个向量</p>
<p><img src="/Blog/intro/lris_flowers_5.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>每一行都是一个特征向量, 通常向量都是以列排列(列向量) 所以这个矩阵就也可以写成</p>
<p><img src="/Blog/intro/lris_flowers_6.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p>取两个特征举例</p>
<p><img src="/Blog/intro/lris_flowers_7.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p>特征可以很抽象 </p>
<p><img src="/Blog/intro/lris_flowers_8.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>喂给算法的特征是什么样子的, 将很大程度影响输出结果的准确性和可靠性, 甚至有专门领域取研究: 特征工程</p>
<p>值得一提的是, 有一些 “高级方法” 例如深度学习, 其实可以理解成算法在自动地帮助我们进行特征工程</p>
<p><br></p>
<p><br></p>
<h2 id="机器学习的主要任务"><a href="#机器学习的主要任务" class="headerlink" title="机器学习的主要任务"></a>机器学习的主要任务</h2><p>机器学习关注的任务主要有两类: 分类任务, 回归任务</p>
<p><br></p>
<h3 id="分类任务"><a href="#分类任务" class="headerlink" title="分类任务"></a>分类任务</h3><p>例如, 给一张图片, 区分里面的动物是猫还是狗</p>
<p>例如, 识别手写数字</p>
<p><br></p>
<p>对于分类任务可以再进行细分, 主要分为这样几类任务</p>
<h4 id="二分类任务"><a href="#二分类任务" class="headerlink" title="二分类任务"></a>二分类任务</h4><p>二分类任务, 二选一的任务, 例如判断是猫是狗</p>
<p>生活中很多任务使用二分类就可以了: 判断邮件是不是垃圾邮件, 判断发给客户信用卡是否有风险, 判断肿瘤是良性还是恶性</p>
<p><br></p>
<h4 id="多分类任务"><a href="#多分类任务" class="headerlink" title="多分类任务"></a>多分类任务</h4><p><img src="/Blog/intro/lris_flowers_9.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>把结果锁定多个中的一个而不是两个中的一个, 手写数字识别就是从10个种类中选择一个</p>
<p>生活中的应用: 数字识别, 图像识别</p>
<p>一些看似复杂的任务, 也可以转换成分类任务, 例如2048</p>
<p><img src="/Blog/intro/category_task.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>最终机器要做到的就是: 给出现在盘面的状况机器判断上移下移左移右移即可(4个中选一个)</p>
<p>同理对于更加复杂的游戏也是如此, 例如下围棋. 毕竟棋盘上落子的地方有限的, 所以每一步机器要做的事情就是根据现在的棋盘信息选择一个地方进行落子</p>
<p><img src="/Blog/intro/category_task_1.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>甚至无人车领域也可以转化为分类任务, 根据车周围环形的图像信息机器进行选择方向盘向左还是向右, 以及旋转多少角度</p>
<p>即使配合上踩下油门和刹车力度的不同. 方向盘, 油门, 刹车他们的组合也是有限的, 在这些组合中选择一个, 因此我们也可以把它转换成一个多分类问题</p>
<blockquote>
<p>注意: 只是说这些问题可以转换为多分类问题, 但不是说用多分类解决这些问题是最好的方案</p>
</blockquote>
<p>有一些算法只支持完成二分类的任务</p>
<p>但是一个多分类的任务我们其实是可以转换成二分类的任务的, 这种转化的方式还不止一个</p>
<p>有一些算法天然可以完成多分类任务</p>
<p><br></p>
<h4 id="多标签分类"><a href="#多标签分类" class="headerlink" title="多标签分类"></a>多标签分类</h4><p><img src="/Blog/intro/category_task_2.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>之前的分类对于某一张图片, 我们都是把图片放到一个类别中, 区别只是类别数是只有两个还是有多个</p>
<p>不过更高级的分类任务可以让我们把一张图片分到多个类别中</p>
<p>这是一个前沿的课题, 文章中不会涉及</p>
<p><br></p>
<p>然而还有另一类数据</p>
<p><img src="/Blog/intro/category_task_3.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>和上一类数据的不同在与最后一列 (标签列)</p>
<p>之前的数据的标签列都是 <strong>类别</strong>, 但是这个数据中, 价格不是类别, 而是连续的数字</p>
<p>这一类任务被称为<strong>回归任务</strong></p>
<h3 id="回归任务"><a href="#回归任务" class="headerlink" title="回归任务"></a>回归任务</h3><p>结果是一个连续数字的值, 而非一个类别</p>
<p>例如: 预测房屋价格, 预测学生乘积, 市场分析, 股票价格</p>
<p>有一些算法只能解决回归问题, 有一些算法只能解决分类问题, 有一些算法的思路既能解决回归问题, 又能解决分类问题</p>
<p>某些情况下, 回归任务是可以简化为分类任务的</p>
<p>依然用无人驾驶举例, 之前说它是分类问题, 但是方向盘打的角度其实是连续的数值, 只是我们将他类别化(每一度看作是一个类别), 这样一来我们就将一个回归任务简化成一个分类任务</p>
<p>比如说预测学生的成绩, 其实是回归任务, 但有时候我们并不需要预测学生的具体成绩, 只需要看成绩是A+, A, B, C-等等, 这样也把一个回归的任务变成了分类的任务</p>
<p><img src="/Blog/intro/category_task_4.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p>我们说机器学习解决分类问题和监督问题, 其实更为准确地说是<strong>监督学习</strong>解决了它们, 其实机器学习领域还可以解决其他的问题, 不过文章以解决分类问题和回归问题为主</p>
<p>机器学习还可以解决什么问题?</p>
<p><br></p>
<p><br></p>
<h2 id="监督学习-非监督学习-半监督学习-和-增强学习"><a href="#监督学习-非监督学习-半监督学习-和-增强学习" class="headerlink" title="监督学习, 非监督学习, 半监督学习 和 增强学习"></a>监督学习, 非监督学习, 半监督学习 和 增强学习</h2><p>分类和回归这两类任务其实是从机器学习<strong>可以解决的问题的角度</strong>分类的, 而不是从机器学习算法本身进行分类的</p>
<p>如果我们将目光放在机器学习算法上, 整体上我们可以将机器学习算法分成 <strong>监督学习, 非监督学习, 半监督学习 和 增强学习</strong> 这四个大类</p>
<p><br></p>
<h3 id="监督学习"><a href="#监督学习" class="headerlink" title="监督学习"></a>监督学习</h3><p><strong>给机器的训练数据拥有 “标记” 或者 “答案”</strong></p>
<p>例如上面提到的鸢尾花和房产的数据集, 都拥有”标记”列</p>
<p><img src="/Blog/intro/Supervised_learning.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>比如分辨照片是猫还是狗只给出照片是不够的, 还要分辨这个照片到底是猫还是狗</p>
<p><img src="/Blog/intro/Supervised_learning_1.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>同样对于mnist数据集, 不仅要有图片信息, 还要有标记信息</p>
<p><br></p>
<p>监督的意思就在于我们人类已经针对给机器的数据进行了正确答案的划分. 这种正确答案的划分本身就被称为是一种监督的信息</p>
<p>实际思考一下生活中很多学习的过程都是监督学习的过程</p>
<p><img src="/Blog/intro/Supervised_learning_2.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>文章中大部分算法都属于监督学习算法</p>
<p><br></p>
<h3 id="非监督学习"><a href="#非监督学习" class="headerlink" title="非监督学习"></a>非监督学习</h3><p>给机器的训练数据没有任何”标记”或者”答案”</p>
<p><img src="/Blog/intro/unSupervised_learning.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>每一个点并没有表示类别, 非监督学习就是基于相应的算法可以为这些点进行分类</p>
<p><img src="/Blog/intro/unSupervised_learning_1.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>通常管这样的工作叫做<strong>聚类分析</strong></p>
<p>其实电商网站对每一个人都是同等对待的, 初始的时候是没有标记的, 但是随着在电商网站上留下越来越多的足迹, 电商网站就可以用非监督学习的方式对用户进行分类</p>
<p><br></p>
<p>非监督学习的另一个重要应用就是对数据进行<strong>降维处理</strong></p>
<p>对数据进行降维处理主要分为两部分内容:</p>
<ul>
<li><p>特征提取: 信用卡的信用评级和人的胖瘦无关?</p>
<p>数据通常有很多特征, 有一些特征对我们将要预测/计算的结果没有贡献</p>
</li>
<li><p>特征压缩: PCA</p>
</li>
</ul>
<p>特征压缩并不丢弃任何特征</p>
<p>特征压缩例子:</p>
<p><img src="/Blog/intro/unSupervised_learning_2.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>例如在这个二维特征平面上分布着很多数据点</p>
<p>但是似乎这些点整体是成一个直线的形式, 如果化成一根直线的话, 把所有点都映射到这根直线上的话, 这些点的信息并没有丢失多少, 但是经过这样处理后这些二维的点就变成了一维的点</p>
<p> <strong>特征压缩做的事情就是: 尽量少的损失信息的情况下, 将高维的特征向量压缩成低维的特征向量</strong></p>
<p><br></p>
<p>对数据进行降维还有一个重要的意义: 方便可视化</p>
<p><img src="/Blog/intro/unSupervised_learning_3.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>还可以进行<strong>异常检测</strong></p>
<p><img src="/Blog/intro/unSupervised_learning_4.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>就是有的时候数据中的某些点明显具有异常</p>
<p> 并不是说异常点没有意义, 但是我们直观地去看它就可以看出来<strong>它不能表达样本的整体的特性</strong>, 而对于机器学习来说, 很多时候是要找到样本一般化的特征. 对于这种特殊的点对我们发现一般性规律很有可能是没有帮助的</p>
<blockquote>
<p>非监督学习通常用作辅助监督学习</p>
</blockquote>
<p><br></p>
<h3 id="半监督学习"><a href="#半监督学习" class="headerlink" title="半监督学习"></a>半监督学习</h3><p>一部分数据有”标记”或者”答案”, 另一部分数据没有</p>
<p>这种情况更为常见, 因为生活中会因为各种原因产生标记缺失</p>
<p>通常都先使用<strong>无监督学习手段</strong>对数据做处理, 之后使用<strong>监督学习手段</strong>做数据的训练和预测</p>
<p>半监督学习就是监督学习和非监督学习的结合, 相对是容易的</p>
<p><br></p>
<h3 id="增强学习"><a href="#增强学习" class="headerlink" title="增强学习"></a>增强学习</h3><p>根据周围环境的情况, 采取行动, 根据采取行动的结果, 学习行动方式</p>
<p><img src="/Blog/intro/unSupervised_learning_5.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>算法通常叫做一个Agent, 要根据周围的环境来采取行动, 行动之后算法会收到一些反馈, 这些反馈有的时候会使用 reward(奖赏) 的机制, 有的时候是使用惩罚的机制进行反馈.</p>
<p>当Agent得到反馈之后, 它就会相应地改变自己的行为模式, 之后根据该机的算法在做出一个Action(动作), 环境再反馈Agent以此类推</p>
<p>在循环中增强自己的智能, 所以叫增强学习</p>
<p>增强学习是非常适合机器人的, AlphaGo实际上是增强学习的一个应用, 它在和人或者自己博弈中每一次落子其实都是和环境进行了一次交互, 此时AlphaGo就会思考刚才的落子是好还是不好</p>
<p>无论是无人驾驶还是机器人其实都需要增强学习</p>
<p>同样增强学习是比较前沿的学习领域, 监督学习和半监督学习是基础</p>
<p><br></p>
<p>然而<strong>监督学习, 非监督学习, 半监督学习 和 增强学习</strong>这四个大类并不是对机器学习分类的唯一标准</p>
<p><br></p>
<p><br></p>
<h2 id="在线学习-批量学习-离线学习-参数学习和非参数学习"><a href="#在线学习-批量学习-离线学习-参数学习和非参数学习" class="headerlink" title="在线学习, 批量学习 (离线学习), 参数学习和非参数学习"></a>在线学习, 批量学习 (离线学习), 参数学习和非参数学习</h2><ul>
<li>批量学习 Batch Learning(有时候也叫离线学习Offline Learning)</li>
<li>在线学习 Online Learning</li>
</ul>
<h3 id="批量学习"><a href="#批量学习" class="headerlink" title="批量学习"></a>批量学习</h3><p>之前所介绍的算法如果没有特殊说明都可以使用批量学习的方式来进行机器学习</p>
<p><img src="/Blog/intro/category_task_4.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>所谓批量学习就是首先收集一定量的样本资料, 然后将这些样本资料送给机器学习算法, 算法就会训练出一个模型</p>
<p>当我们训练出这个模型之后就可以直接将模型投入生产环境中了</p>
<p>在具体应用的时候可能有新的样例送进来, 让模型预测出相应的结果, 这个过程中我们的模型不会再发生任何变化</p>
<p>例如: 手写识别系统, 在训练好模型后投入实践, 虽然在使用的过程中依然会投入大量新的样例, 但这些样例不会作为训练集来优化模型了</p>
<p><br></p>
<h4 id="批量学习的特点"><a href="#批量学习的特点" class="headerlink" title="批量学习的特点"></a>批量学习的特点</h4><p><strong>优点</strong>: 简单, 只需要学习机器学习算法本身就好了, 不需要考虑当算法投入生产环境中以后, 面对新的数据我们怎样来逐步优化算法</p>
<p><strong>问题</strong>: 如何适应环境的变化? 例如在不同年代, 垃圾邮件的标签不同</p>
<p><strong>解决方案</strong>: 定时重新批量学习, 让新来的样本数据和原来的样本融合在一起, 形成新的数据集, 然后在新的数据集上重新执行算法, 重新训练模型</p>
<p><strong>缺点</strong>: 每次重新批量学习, 运算量巨大. 在某些环境变化非常快的情况下, 甚至不可能</p>
<p><br></p>
<h3 id="在线学习"><a href="#在线学习" class="headerlink" title="在线学习"></a>在线学习</h3><p><img src="/Blog/intro/category_task_4.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>整体流程不变, 不过每次输入样例进入模型得到预期的结果之后同时我们输入样例并不浪费掉, 我们将输入样例和正确结果迭代进机器学习算法来改进模型</p>
<p>在线学习相当不不仅仅使用模型得到想要的结果, 与此同时我们还在不断地训练算法让算法进行学习, 所以叫做在线学习</p>
<p><img src="/Blog/intro/online_learning.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<h4 id="在线学习的特点"><a href="#在线学习的特点" class="headerlink" title="在线学习的特点"></a>在线学习的特点</h4><p><strong>优点</strong>: 及时反映新的环境变化</p>
<p><strong>问题</strong>: 新的数据带来不好的变化, 例如错误地使用系统产生的异常数据</p>
<p><strong>解决方案</strong>: 需要加强对数据进行监控 (讲非监督学习时说过, 有一个使用场景就是进行异常数据检测), 通常在在线学习的过程中, 就需要对异常数据进行检测</p>
<p><strong>其他</strong>: 也适用于数据量巨大, 完全无法批量学习的环境 (在线学习算法也是对批量学习算法的一个改进)</p>
<p><br></p>
<p>从另外一个维度, 我们还可以把机器学习分为:</p>
<ul>
<li>参数学习 Parametric Learning</li>
<li>非参数学习 Nonparametric Learning</li>
</ul>
<h3 id="参数学习"><a href="#参数学习" class="headerlink" title="参数学习"></a>参数学习</h3><p><img src="/Blog/intro/para_leaning.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>这就是一个二维的特征空间, 假设横坐标是房屋的面积, 纵坐标是房屋的价格</p>
<p>对应每一个房屋相应就在特征空间中代表一个点, 基于这些数据点我可以假设房屋的价格和房屋的面积是一个线性的关系 f(x) = ax + b</p>
<p>当有了这个假设之后, 机器学习的过程就是想办法找到一个好的a和b来描述房屋的面积和房屋的价格之间的关系. a 和 b 就是参数</p>
<p>基于这样的学习特点的学习算法就叫做参数学习</p>
<p>参数学习最大的特点就是: 喂给机器很多数据, 这些数据的作用是希望学到我们想要的参数. 一旦我们学到了参数, 那么这些数据集就不再有用了</p>
<p>例如上面的 f(x) = ax+b, 一旦我们知道 a 和 b, 那么对于一个新的房屋, 只要将它的面积代入公式, 就可以预测出房屋的价格. 此时预测的结果和我们喂给机器的训练数据都是<strong>没有关系</strong>的</p>
<p>事实上可以做出非常多的假设, 统计学领域有非常多的统计模型. 我们可以假设特征和要预测的结果之间是某种统计模型可以涵盖的关系, 之后我们的任务就是学习统计模型中的参数. 一旦学到了这些参数, 后面的预测是非常简单的, 不再需要原有数据集的参与</p>
<p><br></p>
<h3 id="非参数学习"><a href="#非参数学习" class="headerlink" title="非参数学习"></a>非参数学习</h3><p>非参数学习就是不对模型进行过多假设</p>
<p><strong>非参数不等于没有参数</strong></p>
<p>非参数学习中的参数其实并不少, 区别只是在于我们不对整个问题进行一个建模. 不把整个问题理解成是学习一些参数, 但是在学习的过程中依然是要有参数来参与的</p>
<p><br></p>
<p><br></p>
<h2 id="和机器学习相关的”哲学”思考"><a href="#和机器学习相关的”哲学”思考" class="headerlink" title="和机器学习相关的”哲学”思考"></a>和机器学习相关的”哲学”思考</h2><p>机器学习这类算法主要处理的是<strong>不确定世界中相关的问题</strong></p>
<p>这和传统算法解决的问题有很大不同, 经典算法所解决的问题通常都是有固定, 唯一, 标准的答案的</p>
<p>但机器学习不同, 它面对的是高度不确定的现实世界中的问题, 面对这些问题, 机器学习给我们的答案其实也是不确定的, 概率性的, 有统计意义的答案</p>
<p>面对这样的答案, 我们难免会思考某些问题: 这些答案真的可靠吗, 我们到底能多大程度地相信这些答案, 机器学习学习到的本质是什么….</p>
<p><img src="/Blog/intro/think_in_ai.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>从算法的角度它们是有优劣的, 但微软的这篇文章揭示出来, 如果我们喂给这些算法足够多的数据 (横坐标是数据规模, 纵坐标是预测的准确率) 所有的算法的准确率都在稳定上升</p>
<p> 数据量越大, 准确率越高. 当数据量大到一定程度时, 其实算法的准确率之间的差别并不大</p>
<p>机器学习领域, 算法本身似乎不是那么重要, 只要我们喂给算法的数据足够多, 质量足够好, 甚至有过”数据计算法”这样一个说法</p>
<p>也正是因为如此, 大数据时代才拉开帷幕</p>
<p><br></p>
<p>数据本事确实非常重要, 而且现阶段机器学习解决的大多数问题都是数据驱动的(高度依赖数据本身的质量). </p>
<p>这也使得很多机器学习的研究者花费大量时间处理数据</p>
<ul>
<li><p>收集更多的数据</p>
</li>
<li><p>提高数据质量</p>
</li>
<li><p>提高数据的代表性</p>
</li>
<li><p>研究更重要的特征(特征工程)</p>
</li>
</ul>
<p>机器学习领域内有非常多的算法, 但是其实它们解决的问题大抵上是差不多的, 以监督学习为例, 它解决的问题就是两个问题: 分类问题和回归问题</p>
<p>在这种情况下, 针对要研究的问题到底要选择怎样的算法?</p>
<p>和选择相关的问题, 最简单也是最深刻的原则: 奥卡姆的剃刀</p>
<h3 id="奥卡姆的剃刀"><a href="#奥卡姆的剃刀" class="headerlink" title="奥卡姆的剃刀"></a>奥卡姆的剃刀</h3><p>简单的就是好的, 对于一个问题不要有过多的假设, 不要对它进行过多地复杂化</p>
<p>然而一个容易引发争议的问题就是: 到底在机器学习领域, 什么叫”简单”. 不同的情况下有不同的答案</p>
<p><br></p>
<h3 id="没有免费的午餐定理"><a href="#没有免费的午餐定理" class="headerlink" title="没有免费的午餐定理"></a>没有免费的午餐定理</h3><p>另一个有趣的定理叫做<strong>没有免费的午餐定理</strong></p>
<p>即: 可以用严格地数学推导出: <strong>任意两个算法, 他们的期望性能是相同的</strong></p>
<p>这个定理揭示出一个非常重要的问题, 如果任意两个算法, 他们的期望性能是相同的, 那么说明其实没有任何一个算法比另外一个算法好, 相当于说所有的算法是等价的</p>
<p>而如果是这样的话又为什么要学习这么多的算法呢? 期望可以简单地理解成是平均值</p>
<p>换句话说对于任意两个算法, 把它们作用在所有问题中, 对于某些问题a算法比b算法好, 对于另一些问题b算法比a算法好, 但是平均来讲a, b两个算法是一样的</p>
<p><strong>具体到某个特定的问题, 有些算法可能更好. 但没有一种算法, 绝对比另外一种算法好</strong></p>
<p>即: 脱离具体问题, 谈哪个算法好是没有意义的</p>
<p>同时它也告诉我们在机器学习领域时间的过程中必须要做的一件事: 在面对一个具体问题的时候, 尝试使用多种算法进行对比试验, 是必要的</p>
<p><br></p>
<p><br></p>
<h1 id="Numpy数据基础"><a href="#Numpy数据基础" class="headerlink" title="Numpy数据基础"></a>Numpy数据基础</h1><p><br></p>
<h2 id="numpy-array-基础"><a href="#numpy-array-基础" class="headerlink" title="numpy.array 基础"></a>numpy.array 基础</h2><figure class="highlight python"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br>np.__version__<br></code></pre></td></tr></table></figure>
<p>为什么要用numpy.array, 而不用 python 的 list</p>
<p><br></p>
<h3 id="Python-List-的特点"><a href="#Python-List-的特点" class="headerlink" title="Python List 的特点"></a>Python List 的特点</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">L = [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>)]<br>L[<span class="hljs-number">5</span>] = <span class="hljs-number">100</span><br>L[<span class="hljs-number">5</span>] = <span class="hljs-string">&quot;Machine Learning&quot;</span><br></code></pre></td></tr></table></figure>
<p>python 的 list 是对类型不做具体限定的list, 与此同时 list 中每一个元素的类型也可以是不一样的</p>
<p>这样的存储结构使得python的list非常灵活, 但与此同时也带来了一个缺点: 效率低</p>
<p>当然python中也有只能限定存一种类型的数组, array</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> array<br>arr = array.array(<span class="hljs-string">&#x27;i&#x27;</span>, [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>)])  <span class="hljs-comment"># 第一个参数 i 表示整型, 第二个参数 list 表示数组内的元素</span><br><br><span class="hljs-comment"># array 的操作和 list 是一样的</span><br>arr[<span class="hljs-number">5</span>] = <span class="hljs-number">100</span><br></code></pre></td></tr></table></figure>
<p>array 也有一个缺点: 它只是将存储的数据当作数组来看, 或者二维数组来看. 但没有把这些数据看作是向量或矩阵</p>
<p>因此也没有为这些数据配备和向量相关, 矩阵相关的运算, 这使得在机器学习算法中使用array也不方便</p>
<p>由此numpy应运而生, 可以使用numpy.array进行向量和矩阵的运算</p>
<p><br></p>
<h3 id="numpy-array"><a href="#numpy-array" class="headerlink" title="numpy.array"></a>numpy.array</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">nparr = np.array([i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>)])<br><span class="hljs-comment"># numpy.array 的基本操作和 list, array 也是一样的</span><br>nparr[<span class="hljs-number">5</span>] = <span class="hljs-number">100</span><br><br><br><span class="hljs-comment"># 同时numpy.array也封装了一些自己独特的方法</span><br><br><span class="hljs-comment"># 由于numpy.array也只能存储单一类型, 可以用dtype(data type 的缩写)来查看到底存储那种类型</span><br><span class="hljs-built_in">print</span>( nparr.dtype )<br><br>nparr[<span class="hljs-number">5</span>] = <span class="hljs-number">5.0</span><br></code></pre></td></tr></table></figure>
<h3 id="其他创建-numpy-array-的方法"><a href="#其他创建-numpy-array-的方法" class="headerlink" title="其他创建 numpy.array 的方法"></a>其他创建 numpy.array 的方法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python">np.zeros(<span class="hljs-number">10</span>)	<span class="hljs-comment"># 创建零向量, 或零矩阵, 默认情况dtype为 float64</span><br><br>np.zeros(<span class="hljs-number">10</span>, dtype=<span class="hljs-built_in">int</span>)	<span class="hljs-comment"># 指定类型为int</span><br><br>np.zeros((<span class="hljs-number">3</span>, <span class="hljs-number">5</span>)) <span class="hljs-comment"># 创建二维的数组3行5列全是0</span><br><br>np.zeros(shape=(<span class="hljs-number">3</span>, <span class="hljs-number">5</span>), dtype=<span class="hljs-built_in">int</span>)<br><br><span class="hljs-comment">##################</span><br><br>np.ones((<span class="hljs-number">3</span>, <span class="hljs-number">5</span>)) <span class="hljs-comment"># 创建二维数组3行5列全是1</span><br><br>np.full((<span class="hljs-number">3</span>, <span class="hljs-number">5</span>), <span class="hljs-number">666</span>) <span class="hljs-comment"># 创建二维数组3行5列值全是666</span><br><br>np.full(shape=(<span class="hljs-number">3</span>, <span class="hljs-number">5</span>), fill_value=<span class="hljs-number">666.0</span>) <span class="hljs-comment"># 显示指定参数名</span><br></code></pre></td></tr></table></figure>
<h4 id="arange"><a href="#arange" class="headerlink" title="arange"></a>arange</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># python 中有range这样的函数</span><br>[i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-number">20</span>, <span class="hljs-number">2</span>)]<br><span class="hljs-comment"># [0, 2, 4, 6, 8, 10, 12, 14, 16, 18]</span><br><br><span class="hljs-comment"># numpy中的arange的用法和它完全相同</span><br>np.arange(<span class="hljs-number">0</span>, <span class="hljs-number">20</span>, <span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure>
<p>唯一的一点不同就是arange的步长可以是浮点数, 但python的range不行, 步长默认为1</p>
<p><br></p>
<h4 id="linspace"><a href="#linspace" class="headerlink" title="linspace"></a>linspace</h4><p>参数和arange一样</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">np.linspace(<span class="hljs-number">0</span>, <span class="hljs-number">20</span>, <span class="hljs-number">10</span>) <span class="hljs-comment"># 在0到20这个区间里等长地截取10个点, 这10个点是包括0和20这两个点的</span><br></code></pre></td></tr></table></figure>
<p><br></p>
<h4 id="random"><a href="#random" class="headerlink" title="random"></a>random</h4><p>随机数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python">np.random.randint(<span class="hljs-number">0</span>, <span class="hljs-number">10</span>)  <span class="hljs-comment"># 生成从0到10的一个随机数</span><br>np.random.randint(<span class="hljs-number">0</span>, <span class="hljs-number">10</span>, <span class="hljs-number">10</span>) <span class="hljs-comment"># 第三个参数代表生成的数组的形状, 这里生成了有10个0-10随机数的数组 </span><br>np.random.randint(<span class="hljs-number">4</span>, <span class="hljs-number">8</span>, size=(<span class="hljs-number">3</span>, <span class="hljs-number">5</span>)) <span class="hljs-comment"># 第三个参数指定参数名, 生成3x5的矩阵, 每个数为[4, 8)之间的随机数</span><br><br><span class="hljs-comment"># 设置随机种子</span><br>np.random.seed(<span class="hljs-number">666</span>)<br><br><span class="hljs-comment"># 生成0, 1之间随机浮点数</span><br>np.random.random()<br><span class="hljs-comment"># 同样是指定size</span><br>np.random.random(<span class="hljs-number">10</span>)<br>np.random.random((<span class="hljs-number">3</span>, <span class="hljs-number">5</span>)) <span class="hljs-comment"># 3x5的随机数矩阵</span><br><br><span class="hljs-comment"># 上面的随机数实在0, 1之间均匀分布的浮点数</span><br><span class="hljs-comment"># 有的时候我们希望生成服从正态分布的随机浮点数</span><br>np.random.normal() <span class="hljs-comment"># 均值为0方差为1</span><br>np.ramdom.normal(<span class="hljs-number">10</span>, <span class="hljs-number">100</span>) <span class="hljs-comment"># 均值为10, 方差为100</span><br>np.random.normal(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, (<span class="hljs-number">3</span>, <span class="hljs-number">5</span>)) <span class="hljs-comment"># 同样三个参数指定大小</span><br><br><span class="hljs-comment"># 乱序生成0-99, 常用于索引</span><br>np.random.permutation(<span class="hljs-number">100</span>)<br></code></pre></td></tr></table></figure>
<p><br></p>
<h3 id="numpy-array-的基本操作"><a href="#numpy-array-的基本操作" class="headerlink" title="numpy.array 的基本操作"></a>numpy.array 的基本操作</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">x = np.array(<span class="hljs-number">10</span>) 	<span class="hljs-comment"># 长度为10的一维数组</span><br>X = np.arange(<span class="hljs-number">15</span>).reshape(<span class="hljs-number">3</span>, <span class="hljs-number">5</span>)	<span class="hljs-comment"># 3*5的二维数组</span><br></code></pre></td></tr></table></figure>
<h4 id="基本属性"><a href="#基本属性" class="headerlink" title="基本属性"></a>基本属性</h4><p>首先介绍numpy中数组的基本属性</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">x.ndim	<span class="hljs-comment"># 查看数组是几维的数组, x的维度为1</span><br>X.ndim	<span class="hljs-comment"># X的维度为2</span><br>x.shape <span class="hljs-comment"># 返回一个元组, (10,) 说明是一维数组, 第一个维度有10个元素</span><br>X.shape <span class="hljs-comment"># 返回一个有两个元素的元组(3, 5), 3行5列</span><br><br>x.size <span class="hljs-comment"># 返回10, 说明x有10个元素</span><br>X.size <span class="hljs-comment"># 返回15, 说明X有15个元素</span><br></code></pre></td></tr></table></figure>
<p><br></p>
<h4 id="数据访问"><a href="#数据访问" class="headerlink" title="数据访问"></a>数据访问</h4><p>和list的使用是一样的</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(x[<span class="hljs-number">0</span>])<br><span class="hljs-built_in">print</span>(X[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>])	<span class="hljs-comment"># 虽然可以正确访问到单个元素, 然而numpy中是不建议这么写的</span><br><br><span class="hljs-comment"># numpy 为多维数组提供了一个特殊的访问方式</span><br>X[(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>)]  <span class="hljs-comment"># 直接传入一个元组</span><br>X[<span class="hljs-number">2</span>, <span class="hljs-number">2</span>]	   <span class="hljs-comment"># 不加括号也是可以的</span><br><br><span class="hljs-comment"># 切片操作</span><br>x[<span class="hljs-number">0</span>:<span class="hljs-number">5</span>] 	<span class="hljs-comment"># 从0切到5(不包括5)</span><br>x[:<span class="hljs-number">5</span>]	<span class="hljs-comment"># 默认从0 开始</span><br>x[<span class="hljs-number">5</span>:]	<span class="hljs-comment"># 从5切到最后</span><br>x[::<span class="hljs-number">2</span>]	<span class="hljs-comment"># 第三个参数是步长</span><br>x[::-<span class="hljs-number">1</span>]	<span class="hljs-comment"># 倒数地访问</span><br><br><span class="hljs-comment"># 切片这种语法也可以应用在二维数组中</span><br>X[:<span class="hljs-number">2</span>, :<span class="hljs-number">3</span>]	<span class="hljs-comment"># 访问前2行的前3列, 第一维取一个切片前2行, 第二位再取一个切片前3列</span><br><br><span class="hljs-comment"># X[:2][:3] 这样是行不通的</span><br><span class="hljs-comment"># A = X[:2] 返回X的前2行, A是2*5的矩阵</span><br><span class="hljs-comment"># A[:3] 返回A的前3行, A只有2行所以没有改变</span><br></code></pre></td></tr></table></figure>
<p>这也就是为什么numpy不建议用 X[][] 的方法访问元素, 而是使用元组的方式</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python">X[:<span class="hljs-number">2</span>, ::<span class="hljs-number">2</span>] <span class="hljs-comment"># 访问前2行, 每一行访问的间隔为2</span><br>X[::-<span class="hljs-number">1</span>, ::-<span class="hljs-number">1</span>] <span class="hljs-comment"># 行倒着数, 列也倒着数, 相当于对整个矩阵进行了反转</span><br><br><span class="hljs-comment"># 对于多维矩阵我们有时候会进行降维处理</span><br>X[<span class="hljs-number">0</span>]    <span class="hljs-comment"># 自然可以</span><br>X[<span class="hljs-number">0</span>, :] <span class="hljs-comment"># 行取第0行, 列取从头到尾</span><br>X[:, <span class="hljs-number">0</span>] <span class="hljs-comment"># 取一列, 行取从头到尾, 列取第0列</span><br><br><span class="hljs-comment"># 获得原来矩阵的子矩阵, 这个子矩阵和python的list有一个非常重要的不同</span><br>subX = X[:<span class="hljs-number">2</span>, :<span class="hljs-number">3</span>]<br>subX[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>] = <span class="hljs-number">100</span><br><br></code></pre></td></tr></table></figure>
<p>如果在list中使用切片, 返回的list和原来的list是没有关系的</p>
<p>但在numpy中不是如此, 在subX改变后X也跟着改变了</p>
<p>numpy优先考虑的是效率, 所以对于取子矩阵的方式numpy是用类似与引用的方式来获得的, 此时修改子矩阵 会同时修改原矩阵中的元素</p>
<p>如果想创建和原来矩阵不相关的子矩阵</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">subX = X[:<span class="hljs-number">2</span>, :<span class="hljs-number">3</span>].copy()<br></code></pre></td></tr></table></figure>
<p>通过copy函数得到矩阵的复制, 这个副本就和原矩阵脱离了关系</p>
<p><br></p>
<h4 id="reshape"><a href="#reshape" class="headerlink" title="reshape"></a>reshape</h4><p>当我们向改变数据的维度时的方法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">x.shape <span class="hljs-comment"># (10,)</span><br><br>x.reshape(<span class="hljs-number">2</span>, <span class="hljs-number">5</span>) <span class="hljs-comment"># 返回一个2*5的矩阵</span><br></code></pre></td></tr></table></figure>
<p>注意, 这个方法是没有改变x自身的</p>
<p>注意, 一维的向量和二维的矩阵是两个概念</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">A = x.reshape(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>) <span class="hljs-comment"># A是一个1*10的矩阵</span><br>A.ndim 	<span class="hljs-comment"># 2</span><br>A.shape <span class="hljs-comment"># (1, 10)</span><br>x.shape <span class="hljs-comment"># (10,)</span><br></code></pre></td></tr></table></figure>
<p>有的时候我们希望reshape是只想指定一个维度的数据</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">x.reshape(<span class="hljs-number">10</span>, -<span class="hljs-number">1</span>)   <span class="hljs-comment"># 我希望reshape之后有10行, 每一行有多少元素我不关心, 因此列对应的参数传-1</span><br>x.reshape(-<span class="hljs-number">1</span>, <span class="hljs-number">10</span>)   <span class="hljs-comment"># 不关心有多少行, 但每行要有10个元素</span><br>x.reshape(<span class="hljs-number">3</span>, -<span class="hljs-number">1</span>)    <span class="hljs-comment"># 会报错, 因为x有10个元素, 10不能被3整除</span><br></code></pre></td></tr></table></figure>
<p><br></p>
<h4 id="合并操作"><a href="#合并操作" class="headerlink" title="合并操作"></a>合并操作</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">x = np.array([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])<br>y = np.array([<span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>])<br>z = np.array([<span class="hljs-number">666</span>, <span class="hljs-number">666</span>, <span class="hljs-number">666</span>])<br><br><span class="hljs-comment"># 合并xy, 并返回</span><br>np.concatenate([x, y])<br><br><span class="hljs-comment"># 得到含有9个元素的列表</span><br>np.concatenate([x, y, z])<br></code></pre></td></tr></table></figure>
<p>基于二维矩阵进行合并操作</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python">A = np.array([[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>],<br>              [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]])<br><br>np.concatenate([A, A])<br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">结果:</span><br><span class="hljs-string">[[1, 2, 3],</span><br><span class="hljs-string"> [4, 5, 6],</span><br><span class="hljs-string"> [1, 2, 3],</span><br><span class="hljs-string"> [4, 5, 6]]</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br><span class="hljs-comment"># axis 默认为 0, 即沿着第0个维度进行拼接(沿着行方向拼接行)</span><br><span class="hljs-comment"># 设置 axis 为1, 即沿着第1个维度进行拼接(沿着列方向拼接)</span><br>np.concatenate([A, A], axis=<span class="hljs-number">1</span>)<br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">结果:</span><br><span class="hljs-string">[[1, 2, 3, 1, 2, 3],</span><br><span class="hljs-string"> [4, 5, 6, 4, 5, 6]]</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br></code></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python">z = np.array([<span class="hljs-number">666</span>, <span class="hljs-number">666</span>, <span class="hljs-number">666</span>])<br>A = np.array([[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>],<br>              [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]])<br><span class="hljs-comment"># A这个矩阵表示有2个样本, 每个样本有3个特征</span><br><span class="hljs-comment"># z这个向量表示一个样本, 只有它本身的三个特征, 所以它不是一个矩阵</span><br><span class="hljs-comment"># 我想将z这一个样本融合进A这个矩阵中</span><br><span class="hljs-comment"># 一种方式是可以把z也转换成矩阵进行操作</span><br>A2 = np.concatenate([A, z.reshape(<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>)])<br><br><span class="hljs-comment"># 另一种简单的方式</span><br>np.vstack([A, z])<br><br><span class="hljs-comment"># 有vstack就有hstack, 即水平方向堆积</span><br>B = np.full((<span class="hljs-number">2</span>, <span class="hljs-number">2</span>), <span class="hljs-number">100</span>)<br>np.hstack([A, B])<br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">[[1, 2, 3, 100, 100],</span><br><span class="hljs-string"> [4, 5, 6, 100, 100]]</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br></code></pre></td></tr></table></figure>
<p><br></p>
<h4 id="分割操作"><a href="#分割操作" class="headerlink" title="分割操作"></a>分割操作</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">x = np.arange(<span class="hljs-number">10</span>)<br><br><span class="hljs-comment"># 指定分割点3, 7 把数组分成3段</span><br>x1, x2, x3 = np.split(x, [<span class="hljs-number">3</span>, <span class="hljs-number">7</span>]) <br><span class="hljs-built_in">print</span>(x1) <span class="hljs-comment"># [0, 1, 2] 即 x[:3]</span><br><span class="hljs-built_in">print</span>(x2) <span class="hljs-comment"># [3, 4, 5, 6] 即 x[3:7]</span><br><span class="hljs-built_in">print</span>(x3) <span class="hljs-comment"># [7, 8, 9] 即 x[7:]</span><br><br><span class="hljs-comment"># 把数组分成两段, 第二个参数传入的依然是一个数组</span><br>x1, x2 = np.split(x, [<span class="hljs-number">5</span>])<br></code></pre></td></tr></table></figure>
<p>二维数组也是一样的</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python">A = np.arrange(<span class="hljs-number">16</span>).reshape([<span class="hljs-number">4</span>, <span class="hljs-number">4</span>])<br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">[[0, 1, 2, 3],</span><br><span class="hljs-string"> [4, 5, 6, 7],</span><br><span class="hljs-string"> [8, 9 ,10, 11],</span><br><span class="hljs-string"> [12, 13, 14, 15]]</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br>A1, A2 = np.split(A, [<span class="hljs-number">2</span>])<br><span class="hljs-built_in">print</span>(A1)<br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">[[0, 1, 2, 3],</span><br><span class="hljs-string"> [4, 5, 6, 7]]</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-built_in">print</span>(A2)<br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">[[8, 9 ,10, 11],</span><br><span class="hljs-string"> [12, 13, 14, 15]]</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br></code></pre></td></tr></table></figure>
<p>默认情况下依然是基于行所在的维度(第0个轴)进行分割</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python">A1, A2 = np.split(A, [<span class="hljs-number">2</span>], axis=<span class="hljs-number">1</span>)<br><span class="hljs-built_in">print</span>(A1)<br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">[[0, 1],</span><br><span class="hljs-string"> [4, 5],</span><br><span class="hljs-string"> [8, 9],</span><br><span class="hljs-string"> [12, 13]]</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-built_in">print</span>(A2)<br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">[[2, 3],</span><br><span class="hljs-string"> [6, 7],</span><br><span class="hljs-string"> [10, 11],</span><br><span class="hljs-string"> [14, 15]]</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br><span class="hljs-comment"># numpy 也设置了两个简单的方法</span><br>upper, lower = np.vsplit(A, [<span class="hljs-number">2</span>])<br>left, right = np.hsplit(A, [<span class="hljs-number">2</span>])<br></code></pre></td></tr></table></figure>
<p>数据的分割有什么意义?</p>
<p>之前讲机器学习, 如果是4*4的矩阵, 很可能代表有4个样本, 每个样本有3个特征, 而最后一列代表的是每一个样本对应的label的值</p>
<p>当我们运行机器学习算法时就要将特征矩阵和 label 向量分隔开</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python">data = np.arrange(<span class="hljs-number">16</span>).reshape([<span class="hljs-number">4</span>, <span class="hljs-number">4</span>])<br>X, y = np.split(data, [-<span class="hljs-number">1</span>], axis=<span class="hljs-number">1</span>)<br>X, y = np.hsplit(data, [-<span class="hljs-number">1</span>])<br><br><span class="hljs-built_in">print</span>(X)<br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">[[0, 1, 2],</span><br><span class="hljs-string"> [4, 5, 6],</span><br><span class="hljs-string"> [8, 9 ,10],</span><br><span class="hljs-string"> [12, 13, 14]]</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br><span class="hljs-built_in">print</span>(y)<br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">[[3],</span><br><span class="hljs-string"> [7],</span><br><span class="hljs-string"> [11],</span><br><span class="hljs-string"> [15]]</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-comment"># 如果我们想让y以向量的方式表示</span><br>y[:, <span class="hljs-number">0</span>]<br></code></pre></td></tr></table></figure>
<p><br></p>
<h4 id="矩阵运算"><a href="#矩阵运算" class="headerlink" title="矩阵运算"></a>矩阵运算</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># python list 的乘法</span><br>n = <span class="hljs-number">10</span><br>L = [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]<br><span class="hljs-comment"># 2 * L 的结果是将两个L拼接起来, 而不是让L的每一个元素都乘以2</span><br><br><span class="hljs-comment"># 如果想让每个元素都乘以2, 则要这样写</span><br>A = []<br><span class="hljs-keyword">for</span> e <span class="hljs-keyword">in</span> L:<br>    A.append(<span class="hljs-number">2</span>*e)<br>    <br><span class="hljs-comment"># 或者用生成表达式(列表解析) 更快</span><br>A = [<span class="hljs-number">2</span>*e <span class="hljs-keyword">for</span> e <span class="hljs-keyword">in</span> L]<br></code></pre></td></tr></table></figure>
<p>而在numpy中使用列表解析的速度是非常快的远远快于list的列表解析</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">A = np.array(<span class="hljs-number">2</span>*e <span class="hljs-keyword">for</span> e <span class="hljs-keyword">in</span> L)<br></code></pre></td></tr></table></figure>
<p>而且numpy.array支持list不支持的乘法操作, 速度更快</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">A = <span class="hljs-number">2</span> * L<br></code></pre></td></tr></table></figure>
<p>在numpy中对于”将数组看成是向量或矩阵进行运算”有一个特殊的名字Universal Function</p>
<p>Universal Function近乎支持所有的运算符相应的运算</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python">X = np.arrange(<span class="hljs-number">1</span>, <span class="hljs-number">16</span>).reshape(<span class="hljs-number">3</span>, <span class="hljs-number">5</span>)<br>X + <span class="hljs-number">1</span> 	<span class="hljs-comment"># 将所有元素加1</span><br>X - <span class="hljs-number">1</span>   <span class="hljs-comment"># 将所有元素减1</span><br>X * <span class="hljs-number">2</span>   <span class="hljs-comment"># 将所有元素称2</span><br>X / <span class="hljs-number">2</span>   <span class="hljs-comment"># 除法</span><br>X // <span class="hljs-number">2</span>  <span class="hljs-comment"># 整除</span><br>X ** <span class="hljs-number">2</span>  <span class="hljs-comment"># 幂运算</span><br>X % <span class="hljs-number">2</span>   <span class="hljs-comment"># 求余运算</span><br><span class="hljs-number">1</span> / X   <span class="hljs-comment"># 对矩阵中所有元素取倒数</span><br><br>np.<span class="hljs-built_in">abs</span>(X)<br>np.sin(X)	<span class="hljs-comment"># 对X中所有元素取sin</span><br>np.cos(X)<br>np.exp(X)   <span class="hljs-comment"># 对X的所有元素都取e的x次方</span><br>np.power(<span class="hljs-number">3</span>, X) <span class="hljs-comment"># 对X的所有元素都取3的x次方</span><br><span class="hljs-number">3</span> ** X      <span class="hljs-comment"># 和上面的结果一致</span><br><br>np.log(X)   <span class="hljs-comment"># 求自然对数, 以e为底</span><br>np.log2(X)<br>np.log10(X)<br></code></pre></td></tr></table></figure>
<p> <strong>矩阵和矩阵之间的运算</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">A = np.arange(<span class="hljs-number">4</span>).reshape(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>)<br>B = np.full((<span class="hljs-number">2</span>, <span class="hljs-number">2</span>), <span class="hljs-number">10</span>)<br>A + B<br>A - B<br>A * B     <span class="hljs-comment"># A 和 B对应元素相乘, 不是点乘</span><br>A.dot(B)  <span class="hljs-comment"># A 和 B 点乘 </span><br>A.T       <span class="hljs-comment"># A 的转置</span><br></code></pre></td></tr></table></figure>
<p><strong>向量和矩阵的运算</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">v = np.array([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>])<br>A = np.arange(<span class="hljs-number">4</span>).reshape(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>)<br>v + A    <span class="hljs-comment"># 数学上向量和矩阵相加是没有意义的</span><br>         <span class="hljs-comment"># numpy中是向量和矩阵的每一行进行加法</span><br>         <span class="hljs-comment"># 和使用一个数和一个向量作加法的道理是一样的</span><br></code></pre></td></tr></table></figure>
<p>数学上向量和矩阵相加是没有意义的</p>
<p>numpy中是向量和矩阵的每一行进行加法, 和使用一个数和一个向量作加法的道理是一样的</p>
<p>等同于先把v叠成A的形状在进行加法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">np.vstack([v] * A.shape[<span class="hljs-number">0</span>]) + A<br><br><span class="hljs-comment"># 由于这种堆叠也经常使用, numpy也提供了一个方便的函数</span><br><span class="hljs-comment"># (2, 1) 代表堆叠的方式, 行向量堆叠2次, 列向量堆叠一次</span><br>np.tile(v, (<span class="hljs-number">2</span>, <span class="hljs-number">1</span>))  <br>np.tile(v, (<span class="hljs-number">2</span>, <span class="hljs-number">1</span>)) + A<br></code></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">v * A    <span class="hljs-comment"># 向量v 和 A的每一个行向量进行乘法 </span><br>v.dot(A) <span class="hljs-comment"># 点乘, v看作1*2的行向量</span><br>A.dot(v) <span class="hljs-comment"># v看作时2*1的列向量</span><br></code></pre></td></tr></table></figure>
<p><strong>矩阵的逆</strong></p>
<p>np.linalg.inv 这个方法就是用来求矩阵的逆的</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">A_inv = np.linalg.inv(A)<br>A.dot(A_inv)    <span class="hljs-comment"># 得到单位矩阵</span><br><br><span class="hljs-comment"># 当X不为方阵时无法求逆, 但可以求伪逆</span><br>pinvX = np.linalg.pinv(X)<br>X.dot(pinvX)  <span class="hljs-comment"># 得到单位矩阵</span><br></code></pre></td></tr></table></figure>
<h4 id="聚合操作"><a href="#聚合操作" class="headerlink" title="聚合操作"></a>聚合操作</h4><p>简单来说就是把一组值变成一个值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">L = np.random.random(<span class="hljs-number">100</span>)<br><span class="hljs-built_in">sum</span>(L) <span class="hljs-comment"># python自带的 sum</span><br>np.<span class="hljs-built_in">sum</span>(L) <span class="hljs-comment"># numpy中的 sum</span><br></code></pre></td></tr></table></figure>
<p>而这两个sum的区别就是效率上的区别</p>
<p>其他的聚合操作</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">np.<span class="hljs-built_in">min</span>(L) <span class="hljs-comment"># L.min()</span><br>np.<span class="hljs-built_in">max</span>(L) <span class="hljs-comment"># L.max()</span><br></code></pre></td></tr></table></figure>
<p>矩阵的聚合操作</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">X = np.arange(<span class="hljs-number">16</span>).reshape(<span class="hljs-number">4</span>, -<span class="hljs-number">1</span>) <br>np.<span class="hljs-built_in">sum</span>(X) <span class="hljs-comment"># 120, 0-15的和</span><br></code></pre></td></tr></table></figure>
<p>聚合运算默认不管传入一维的数组还是二维的矩阵都是将所有元素进行聚合</p>
<p>但有时我们有这样的需求: 求出每一行的和或每一列的和</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">np.<span class="hljs-built_in">sum</span>(X, axis=<span class="hljs-number">0</span>)    <span class="hljs-comment"># X 每一列的和</span><br>np.<span class="hljs-built_in">sum</span>(X, axis=<span class="hljs-number">1</span>)    <span class="hljs-comment"># X 每一行的和</span><br></code></pre></td></tr></table></figure>
<p>为什么 axis=0 时沿着列来计算?</p>
<p>axis这个参数代表沿着这个轴进行运算, 为0的话就是行这个维度</p>
<p>所以它代表的就是沿着行这个方向进行运算, 沿着行就是对每列逐列地进行运算</p>
<blockquote>
<p>另一种思考方法就是, 传入axis的轴代表我们要把这个轴压缩掉, 我们不要这个轴</p>
<p>如果传入0就代表第0个轴(行这个维度)我们压缩掉, 得到的结果就是按列进行运算</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">np.prod(X)             <span class="hljs-comment"># 求所有元素的乘积</span><br>np.mean(X)             <span class="hljs-comment"># 求平均值</span><br>np.median(X)           <span class="hljs-comment"># 求中位数</span><br>np.percentile(X, q=<span class="hljs-number">50</span>) <span class="hljs-comment"># 求百分位数</span><br>np.var(X)              <span class="hljs-comment"># 求方差</span><br>np.std(X)              <span class="hljs-comment"># 求标准差</span><br></code></pre></td></tr></table></figure>
<p><br></p>
<h4 id="索引-arg"><a href="#索引-arg" class="headerlink" title="索引 arg"></a>索引 arg</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">np.<span class="hljs-built_in">min</span>(x)      <span class="hljs-comment"># 获取x中的最小值</span><br>np.argmin(x)   <span class="hljs-comment"># 获取x中最小值所在位置</span><br>np.argmax(x)   <span class="hljs-comment"># 获取x中最大值所在位置</span><br></code></pre></td></tr></table></figure>
<p>很多数学公式也都有这种表示, arg加上一个运算</p>
<h4 id="排序和使用索引"><a href="#排序和使用索引" class="headerlink" title="排序和使用索引"></a>排序和使用索引</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python">x = np.arange(<span class="hljs-number">16</span>)<br>np.random.shuffle(x)    <span class="hljs-comment"># 乱序处理, 洗牌, 改变x本身</span><br>np.sort(x)              <span class="hljs-comment"># 排序, 返回排好序的array, 不改变x本身</span><br>x.sort()                <span class="hljs-comment"># 排序, 改变x本身</span><br><br><span class="hljs-comment"># 二维矩阵sort</span><br>X = np.random.randint(<span class="hljs-number">10</span>, size=(<span class="hljs-number">4</span>, <span class="hljs-number">4</span>))<br>np.sort(X)              <span class="hljs-comment"># 把每一行都按照顺序排序</span><br>np.sort(X, axis=<span class="hljs-number">1</span>)      <span class="hljs-comment"># axis默认是1, 即沿着列的方向进行排序</span><br>np.sort(X, axis=<span class="hljs-number">0</span>)      <span class="hljs-comment"># 沿着行的方向进行排序 </span><br><br><span class="hljs-comment"># 排序和索引</span><br>np.random.shuffle(x)    <span class="hljs-comment"># 现在x是乱序</span><br>np.argsort(x)			<span class="hljs-comment"># 返回值是一个array, 里面存放着x排好序的索引</span><br><br>np.partition(x, <span class="hljs-number">3</span>)      <span class="hljs-comment"># 和快速排序的partition是一样的</span><br>np.argpartition(x, <span class="hljs-number">3</span>)   <span class="hljs-comment"># 同样排序后索引的位置</span><br></code></pre></td></tr></table></figure>
<p><br></p>
<h4 id="Fancy-Indexing"><a href="#Fancy-Indexing" class="headerlink" title="Fancy Indexing"></a>Fancy Indexing</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">x = np.arange(<span class="hljs-number">16</span>)<br><br><span class="hljs-comment"># 索引某一个值</span><br>x[<span class="hljs-number">3</span>]<br><br><span class="hljs-comment"># 索引某一个区间</span><br>x[<span class="hljs-number">3</span>:<span class="hljs-number">9</span>]<br>x[<span class="hljs-number">3</span>:<span class="hljs-number">9</span>:<span class="hljs-number">2</span>]<br></code></pre></td></tr></table></figure>
<p>但如果我们想要访问3, 5, 8怎么办, 换句话说他们之间不是等间距的步长, 没有规律</p>
<p>我们可能只能这样做</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">[x[<span class="hljs-number">3</span>], x[<span class="hljs-number">5</span>], x[<span class="hljs-number">8</span>]]<br></code></pre></td></tr></table></figure>
<p>然而numpy为我们提供了一个非常简便的操作</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">ind = [<span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>]<br>x[ind]  <span class="hljs-comment"># 这样就可以直接获取索引位置为3, 5, 8的元素</span><br></code></pre></td></tr></table></figure>
<p>这就是Fancy Indexing</p>
<p>索引数组还可以是二维数组</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">ind = np.array([[<span class="hljs-number">0</span>, <span class="hljs-number">2</span>],<br>                [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>]])<br>x[ind]<br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">得到一个二维的矩阵, 对应的就是二维的索引</span><br><span class="hljs-string">每个值都是从一维向量中索引出来的值, </span><br><span class="hljs-string">按照索引矩阵排列的方式我们得到了一个新的这些值对应的二维矩阵</span><br><span class="hljs-string">[[0, 2],</span><br><span class="hljs-string"> [1, 3]]</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br></code></pre></td></tr></table></figure>
<p>Fancy Indexing不仅可以用在一维的向量中, 还可以用在二维的矩阵里</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python">X = x.reshape(<span class="hljs-number">4</span>, -<span class="hljs-number">1</span>) <span class="hljs-comment"># 现在X是一个4*4的方阵</span><br><br>row = np.array([<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>]) <span class="hljs-comment"># 感兴趣的数据点的行所在位置</span><br>col = np.array([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]) <span class="hljs-comment"># 感兴趣的数据点的列所在索引</span><br><span class="hljs-comment"># 其实我们感兴趣的是3个点, 他们的坐标是[0, 1] [1, 2] [2, 3]</span><br>X[row, col]   <span class="hljs-comment"># return [1, 6, 11]</span><br>X[<span class="hljs-number">0</span>, col]     <span class="hljs-comment"># return [1, 2, 3] 对第0行的这些坐标感兴趣</span><br><br>col = [<span class="hljs-literal">True</span>, <span class="hljs-literal">False</span>, <span class="hljs-literal">True</span>, <span class="hljs-literal">True</span>] <span class="hljs-comment"># 如果存储bool值, 则代表对为True的列感兴趣, 而对为False的列不感兴趣</span><br>X[<span class="hljs-number">1</span>:<span class="hljs-number">3</span>, col]<br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">对中间两行的0,2,3列感兴趣</span><br><span class="hljs-string">[[4, 6, 7],</span><br><span class="hljs-string"> [8, 10, 11]]</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br></code></pre></td></tr></table></figure>
<p>使用布尔数组这种方式是非常重要的, 因为我们经常对表格中的数据进行批量比较, 而比较的结果就是这样一个布尔数组</p>
<h4 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">x = np.arange(<span class="hljs-number">10</span>)<br>x &lt; <span class="hljs-number">3</span>     <span class="hljs-comment"># 把x中所有的元素都去和3进行比较, 最终返回一个布尔向量/矩阵</span><br><span class="hljs-comment"># [True, True, True, False ....]</span><br><span class="hljs-comment"># 由此可以进行一些复杂的运算</span><br><span class="hljs-number">2</span> * x == <span class="hljs-number">24</span> - <span class="hljs-number">4</span> * x   <span class="hljs-comment"># x是一维数组而不是数, 得到的结果依然是布尔矩阵</span><br></code></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">np.<span class="hljs-built_in">sum</span>(x&lt;=<span class="hljs-number">3</span>)<br>np.count_nonzero(x&lt;=<span class="hljs-number">3</span>) <span class="hljs-comment"># 计算x中&lt;=3的元素个数</span><br>np.<span class="hljs-built_in">any</span>(x == <span class="hljs-number">0</span>)  <span class="hljs-comment"># 如果x中有任意一个0, 返回都是true</span><br>np.<span class="hljs-built_in">all</span>(x &gt;= <span class="hljs-number">0</span>)<br><br>np.<span class="hljs-built_in">sum</span>(X%<span class="hljs-number">2</span> == <span class="hljs-number">0</span>) <span class="hljs-comment"># 计算有几个偶数</span><br>np.<span class="hljs-built_in">sum</span>(X%<span class="hljs-number">2</span> == <span class="hljs-number">0</span>, axis=<span class="hljs-number">1</span>) <span class="hljs-comment"># 沿着列的方向进行计算</span><br>np.<span class="hljs-built_in">sum</span>(~ (x==<span class="hljs-number">0</span>) ) <span class="hljs-comment"># 计算x不等于0的个数, ~为位运算的取反符号</span><br>np.<span class="hljs-built_in">sum</span>((x &gt; <span class="hljs-number">3</span>) &amp; (x &lt; <span class="hljs-number">10</span>)) <span class="hljs-comment"># 计算 3&lt;x&lt;10 的个数</span><br></code></pre></td></tr></table></figure>
<p>注意使用的是 &amp; 而不是 &amp;&amp;, 数组中每一个都相当于一位, 所以用位运算符</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">x[x &lt; <span class="hljs-number">5</span>]  <span class="hljs-comment"># 查看x中小于5的元素值</span><br></code></pre></td></tr></table></figure>
<p>x&lt;5先返回一个布尔矩阵, 记录我们想要位置的索引, 在把索引矩阵传入x的索引中, 就得到了所有小于5的值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">X[X[:,-<span class="hljs-number">1</span>]%<span class="hljs-number">3</span> == <span class="hljs-number">0</span>, :] <span class="hljs-comment"># 取出X最后一列被3整除的行</span><br></code></pre></td></tr></table></figure>
<p>X[:, -1] %3 == 0 返回一个布尔向量, 记录有哪几行的最后的值被3整除</p>
<p>之后作为行索引传入, 列索引我们全都要</p>
<blockquote>
<p>更高级的表格处理很多时候使用 Pandas</p>
<p>但在scikit-learn中的函数接收的都是numpy的矩阵</p>
<p>所以通常我们都是用Pandas对数据进行预处理</p>
<p>预处理之后再转换成numpy的矩阵送给机器学习算法</p>
</blockquote>
<p><br></p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/Blog/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/">人工智能</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/Blog/tags/python3/">python3</a>
                    
                      <a class="hover-with-bg" href="/Blog/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/">机器学习</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/Blog/2020/04/20/machine-learning-2/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">python3入门机器学习(2)-kNN算法</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/Blog/2020/04/04/stat-203/">
                        <span class="hidden-mobile">统计自整理</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/Blog/js/events.js" ></script>
<script  src="/Blog/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/Blog/js/local-search.js" ></script>



  
    <script  src="/Blog/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
        typing(title);
      
    })(window, document);
  </script>





  

  
    <!-- MathJax -->
    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']]
        },
        loader: {
          load: ['ui/lazy']
        },
        options: {
          renderActions: {
            findScript: [10, doc => {
              document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
                const display = !!node.type.match(/; *mode=display/);
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
                const text = document.createTextNode('');
                node.parentNode.replaceChild(text, node);
                math.start = { node: text, delim: '', n: 0 };
                math.end = { node: text, delim: '', n: 0 };
                doc.math.push(math);
              });
            }, '', false],
            insertedScript: [200, () => {
              document.querySelectorAll('mjx-container').forEach(node => {
                let target = node.parentNode;
                if (target.nodeName.toLowerCase() === 'li') {
                  target.parentNode.classList.add('has-jax');
                }
              });
            }, '', false]
          }
        }
      };
    </script>

    <script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js" ></script>

  











<!-- 主题的启动项 保持在最底部 -->
<script  src="/Blog/js/boot.js" ></script>


</body>
</html>
