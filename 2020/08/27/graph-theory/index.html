

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/Blog/img/favicon.ico">
  <link rel="icon" href="/Blog/img/favicon.ico">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Daolin">
  <meta name="keywords" content="">
  
    <meta name="description" content="连通分量 最小生成树 最短路径">
<meta property="og:type" content="article">
<meta property="og:title" content="图论">
<meta property="og:url" content="https://daolinzhou.github.io/Blog/2020/08/27/graph-theory/">
<meta property="og:site_name" content="Daolin&#39;s Repository">
<meta property="og:description" content="连通分量 最小生成树 最短路径">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/graph.png">
<meta property="article:published_time" content="2020-08-27T18:02:36.000Z">
<meta property="article:modified_time" content="2020-10-19T05:43:40.649Z">
<meta property="article:author" content="Daolin">
<meta property="article:tag" content="数据结构">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://daolinzhou.github.io/Blog/intro/graph.png">
  
  
  <title>图论 - Daolin&#39;s Repository</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/Blog/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"daolinzhou.github.io","root":"/Blog/","version":"1.8.14","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/Blog/local-search.xml"};
  </script>
  <script  src="/Blog/js/utils.js" ></script>
  <script  src="/Blog/js/color-schema.js" ></script>
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.1.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/Blog/">
      <strong>Daolin&#39;s Repo</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/Blog/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/Blog/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/Blog/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/Blog/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/Blog/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/Blog/intro/imprinting2.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="图论">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2020-08-27 11:02" pubdate>
        2020年8月27日 上午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      17k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      139 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">图论</h1>
            
            <div class="markdown-body">
              <link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><p><a href="https://daolinzhou.github.io/Blog/2019/08/20/Connected-component/">连通分量</a></p>
<p><a href="https://daolinzhou.github.io/Blog/2019/08/25/Minimum-Span-Trees/">最小生成树</a></p>
<p><a href="https://daolinzhou.github.io/Blog/2019/08/28/shortest-path/">最短路径</a></p>
<span id="more"></span>
<h1 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h1><h2 id="图的种类"><a href="#图的种类" class="headerlink" title="图的种类"></a>图的种类</h2><p>图大致可以分为4种, 从两个维度进行划分(方向, 权值)</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">有向图</th>
<th style="text-align:center">无向图</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>有权图</strong></td>
<td style="text-align:center">有向有权图</td>
<td style="text-align:center">无向有权图</td>
</tr>
<tr>
<td style="text-align:center"><strong>无权图</strong></td>
<td style="text-align:center">有向无权图</td>
<td style="text-align:center">无向无权图</td>
</tr>
</tbody>
</table>
</div>
<p>一个图可能有自环边或平行边. 而没有自环边或平行边的图叫作<strong>简单图</strong></p>
<p><img src="/Blog/intro/graph/simple_graph.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p>图的度(degree)</p>
<p>对于无向图来说, 一个点的度就是这个点邻边的数量</p>
<p><br></p>
<h2 id="图的表示"><a href="#图的表示" class="headerlink" title="图的表示"></a>图的表示</h2><p>图一般有2种表示方法, 邻接表和邻接矩阵</p>
<p><br></p>
<p>邻接矩阵:</p>
<p><img src="/Blog/intro/graph/simple_graph_1.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>邻接表:</p>
<p><img src="/Blog/intro/graph/simple_graph_2.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p>但是邻接表也是有性能瓶颈的, <strong>建图</strong>和<strong>查看两点是否相邻</strong>两个操作时间复杂度高</p>
<blockquote>
<p> 重点就是<strong>查看两点是否相邻</strong>的复杂度高, 建图的过程中也判断两点是否相邻</p>
</blockquote>
<p>然而这个缺点是可以想办法改进的.</p>
<p>那就是不用链表(LinkedList) 而使用哈希表(HashSet)或者红黑树(TreeSet)</p>
<p>使用哈希表 HashSet: O(1)</p>
<p>使用红黑树 TreeSet: O(logV) </p>
<p><br></p>
<p>一般情况下使用哈希表就可以了, 但是如果为了保证顺序性, 则需要使用红黑树实现.</p>
<p><img src="/Blog/intro/graph/simple_graph_3.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p><br></p>
<h2 id="深度优先遍历的应用"><a href="#深度优先遍历的应用" class="headerlink" title="深度优先遍历的应用"></a>深度优先遍历的应用</h2><h3 id="无向图的联通分量个数"><a href="#无向图的联通分量个数" class="headerlink" title="无向图的联通分量个数"></a>无向图的联通分量个数</h3><p><img src="/Blog/intro/graph/simple_graph_4.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>无向图的联通分量: 一个图的所有节点不一定都是连接起来的. 相连接的一部分就被称为是一个连通分量</p>
<blockquote>
<p>联通分量这个概念在有向图中有些区别</p>
</blockquote>
<p>代码: <a target="_blank" rel="noopener" href="https://github.com/DaoLinZhou/GrapyTheory/blob/master/src/dfs/CC.java">联通分量</a></p>
<p><br></p>
<h3 id="路径问题"><a href="#路径问题" class="headerlink" title="路径问题"></a>路径问题</h3><p>两点在同一联通分量, 意味着两点间有路径</p>
<p>那么路径怎么求?</p>
<p>方法就是以一个点作为起始点进行深度优先遍历.</p>
<p>代码: <a target="_blank" rel="noopener" href="https://github.com/DaoLinZhou/GrapyTheory/blob/master/src/dfs/SingleSourcePath.java">单源路径</a> <a target="_blank" rel="noopener" href="https://github.com/DaoLinZhou/GrapyTheory/blob/master/src/dfs/Path.java">两点路径</a></p>
<p><br></p>
<h3 id="检测无向图中的环"><a href="#检测无向图中的环" class="headerlink" title="检测无向图中的环"></a>检测无向图中的环</h3><p>和检测从某一点到另外一点是否有路径是非常像的.</p>
<p>求解路径的话起点和终点是不同的. 但是对于环检测来说, 起点和终点是相同的.</p>
<p><img src="/Blog/intro/graph/undirected_loop.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p>这个例子中是从0节点开始又返回0节点. 然而实际上, 不一定返回0节点.</p>
<p><img src="/Blog/intro/graph/undirected_loop_1.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>例如这张图, 虽然从0起始, 但返回1节点</p>
<p>逻辑就是: 深度优先遍历, 找到一个已经被访问过的节点, <strong>并且这个节点不是当前节点的上一个节点</strong></p>
<p>代码: <a target="_blank" rel="noopener" href="https://github.com/DaoLinZhou/GrapyTheory/blob/master/src/dfs/CycleDetection.java">无向图环检测</a></p>
<p><br></p>
<h3 id="二分图检测"><a href="#二分图检测" class="headerlink" title="二分图检测"></a>二分图检测</h3><p><img src="/Blog/intro/graph/bipartite_graph.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>这张图就是一张典型的二分图(二部图)</p>
<p>这张图有这样的性质:</p>
<ul>
<li>顶点 V 可以分成不相交的两部分 (蓝色和绿色)</li>
<li>所有边的两个端点隶属于不同的部分</li>
</ul>
<p>然而我们得到的图不可能是这样明确分好了的样子.</p>
<p><img src="/Blog/intro/graph/bipartite_graph_1.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>左边的图和右边的图是等价的. (<strong>图同构</strong>)</p>
<p>然而如果我们得到的右边的图, 如何判断它是否是二分图? </p>
<p>依然可以用 dfs 实现, 只不过在使用 dfs 的过程中, 要进行一个染色的操作</p>
<p><br></p>
<p><br></p>
<blockquote>
<p>图同构</p>
<p><img src="/Blog/intro/graph/sgraph.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>我们能找到一个映射, 传入左边图的顶点标号, 输出右边图的顶点标号</p>
<p>可以看到每个点都连接对应的那些点</p>
<p>如果说两个图同构, 关键是能找到这样一组映射, 让他们变成一样的图.</p>
<p>证明两个图同构是一个NP难的问题?</p>
<p>对于简单图, 其实可以看每个点的度. 同构图的各个顶点的度一定相等. </p>
<p>例如图一有2个点的度为3. 则通构图2也一定有且只有2个点度为3</p>
</blockquote>
<p><br></p>
<blockquote>
<p><img src="/Blog/intro/graph/bipartite_graph_1.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>虽然两个图等价, 但是右边的图明显更清晰, 因为没有边交叉.</p>
<p>对于这样没有边交叉的图我们叫做<strong>平面图</strong></p>
<p>然而有一些图不能做成平面图</p>
<p><img src="/Blog/intro/graph/sgraph_1.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
</blockquote>
<p><br></p>
<p><br></p>
<h2 id="FloodFill-算法"><a href="#FloodFill-算法" class="headerlink" title="FloodFill 算法"></a>FloodFill 算法</h2><p><img src="/Blog/intro/graph/floodfill.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>听着厉害,  FloodFill是一种根据某种规则遍历图 (如上图, 二维网格) 的方式</p>
<p><br></p>
<p><img src="/Blog/intro/graph/floodfill_1.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p><a target="_blank" rel="noopener" href="https://github.com/DaoLinZhou/CppCommonLibrary/blob/master/leetcode/0752_OpentheLock/Solution.h">leetcode 752</a> 这道题就可以抽象为一个图论问题. 使用floodfill解决.</p>
<p><img src="/Blog/intro/graph/floodfill_2.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<h3 id="一道智力题"><a href="#一道智力题" class="headerlink" title="一道智力题"></a>一道智力题</h3><p><img src="/Blog/intro/graph/floodfill_3.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>从一个状态出发, 经过若干步操作. 每一步操作都会到达一个新的状态</p>
<p>这个新的状态其实就是图中的一个顶点</p>
<p>而我们肯定希望步骤越少越好, 所以可以使用bfs</p>
<blockquote>
<p>有一个细节: 每一个顶点对应的状态可以用一个整数表示, 这是因为两个水桶都是小于10的.</p>
<p>所以可以把x当作十位数, y当作个位数</p>
<p>这叫<strong>状态压缩</strong>: 把多个元素表达的状态压缩为较少(甚至一个)元素表达的状态</p>
</blockquote>
<p><br></p>
<p><br></p>
<h2 id="桥"><a href="#桥" class="headerlink" title="桥"></a>桥</h2><h3 id="什么是桥"><a href="#什么是桥" class="headerlink" title="什么是桥"></a>什么是桥</h3><p><img src="/Blog/intro/graph/bridge.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>这个图中有一个桥, 就是3-5这条边</p>
<p>这条边有什么特殊的地方?</p>
<blockquote>
<p> 对于这个无向图来说, 如果删除这条边, 整个图的联通分量数量变化. 则这条边被称为<strong>桥(Bridge)</strong></p>
</blockquote>
<p>桥反映着图中最脆弱的关系</p>
<p><br></p>
<p>一个图中可以有多个桥</p>
<p><img src="/Blog/intro/graph/bridge_1.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p>一棵树的所有边都是桥</p>
<p><img src="/Blog/intro/graph/bridge_2.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<h3 id="寻找桥的算法"><a href="#寻找桥的算法" class="headerlink" title="寻找桥的算法"></a>寻找桥的算法</h3><p><img src="/Blog/intro/graph/bridge.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>桥似乎和环有关系</p>
<p>然而和判断一张图是否有环不同, 判断一张图是否有环是整张图的树形.</p>
<p>桥是一条边的属性</p>
<p> <img src="/Blog/intro/graph/bridge_3.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p>然而怎么看 v-w 这条边是不是桥?</p>
<p><img src="/Blog/intro/graph/bridge_4.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>先从简单的例子入手, 从0深度遍历到1, 如何判断0-1是不是桥? 看通过1是否能从另外一条路回到0. </p>
<p><img src="/Blog/intro/graph/bridge_5.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>继续dfs, 此时深度遍历到了1-3这条边. 同样判断1-3这条边是不是桥就是看通过3能否从另外一条路回到1</p>
<p>然而不一定回到1, 看通过3, 如果能从另外一条路回到0的话, 也意味着1-3这条边不是桥</p>
<p><br></p>
<p><img src="/Blog/intro/graph/bridge.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>如何判断 v-w 是不是桥</p>
<p>看通过 w, 能否从另外一条路回到v或者v之前的顶点</p>
<p>因此要极度DFS的顺序</p>
<p>order[v] 表示顶点 v 在DFS 的访问顺序</p>
<p><img src="/Blog/intro/graph/bridge_6.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>如果判断3-2这条边是不是桥, 只需要看通过2这个顶点能否通过另外一条路回到 3 或者 3 之前的顶点(1 或 0)</p>
<p>同理判断3-5是不是桥, 只需要看通过5这个顶点,  能否通过另外一条路回到3 或者 3 之前的顶点(1 或 0)</p>
<p><br></p>
<p>那么如何判断通过w能从另外一条路回到v或者v之前的顶点? </p>
<p>我们要再记录一条新的信息, 对于每一个顶点, 记录能到达的最小ord</p>
<p>使用 low[v] 表示 DFS 过程中, 顶点 v 能到达的最小 ord 值</p>
<p><br></p>
<p>顶点2可以到达0, 所以low[2] = 0.  </p>
<p><img src="/Blog/intro/graph/bridge_7.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>DFS回退的过程中, 再顶点3看到通过2可以到达0所在的顶点, 所以low[3] = 0</p>
<p><img src="/Blog/intro/graph/bridge_8.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p>同理 </p>
<p><img src="/Blog/intro/graph/bridge_9.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a><a target="_blank" rel="noopener" href="https://github.com/DaoLinZhou/GrapyTheory/blob/master/src/bridge/FindBridges.java">实现</a></h3><p><br></p>
<p><br></p>
<p>寻找桥的算法用的是DFS遍历, 那么是否可以用BFS进行遍历?</p>
<p>不可以</p>
<h3 id="DFS遍历树"><a href="#DFS遍历树" class="headerlink" title="DFS遍历树"></a>DFS遍历树</h3><p><img src="/Blog/intro/graph/bridge_10.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/graph/bridge_11.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>蓝色的边叫做前向边(即最终生成的遍历树上的边), 红色的边叫做后向边(最终不在遍历树上的边)</p>
<p>DFS遍历树有什么性质? 图中非遍历树上的边可以指向自己的祖先节点. </p>
<p>我们恰恰是利用这个特性才能找到桥.</p>
<p>2这个节点能到达0, 所以low[2]的值是0, </p>
<p><br></p>
<h3 id="BFS遍历树"><a href="#BFS遍历树" class="headerlink" title="BFS遍历树"></a>BFS遍历树</h3><p><img src="/Blog/intro/graph/bridge_12.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>此时2-3边和4-6边就不是后向边. 而是被称为横叉边</p>
<p>它不会指向自己的祖先节点</p>
<p>所以BFS无法完成寻找桥这个算法的, 必须用DFS.</p>
<p><img src="/Blog/intro/graph/bridge_13.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p><br></p>
<h2 id="割点"><a href="#割点" class="headerlink" title="割点"></a>割点</h2><h3 id="什么是割点"><a href="#什么是割点" class="headerlink" title="什么是割点"></a>什么是割点</h3><p><img src="/Blog/intro/graph/cut_point.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>和桥的定义非常类似:</p>
<p>如果删除了一个顶点, (顶点邻边也删除) 整个图联通分量数量变化, 则这个顶点称为<strong>割点(Cut Points / Articulation Points)</strong></p>
<blockquote>
<p>如果说”桥”代表整张图最脆弱的边的话, “割点”就代表整张图中最脆弱的点</p>
<p>由于我们会将这样的点叫做割点, 有时我们也会将桥叫成割边(Cut Edges) </p>
</blockquote>
<p><br></p>
<h3 id="寻找割点的算法"><a href="#寻找割点的算法" class="headerlink" title="寻找割点的算法"></a>寻找割点的算法</h3><p>寻找割点的算法和寻找桥的算法是非常像的, 毕竟这两个定义本身就是非常像的</p>
<p>一个是对一类特殊边的定义, 一个是对一类特殊点的定义</p>
<p><img src="/Blog/intro/graph/cut_point_1.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>回忆寻找桥的算法:</p>
<p>对于边 v-w , 如果满足 low[w] &gt; ord[v], 则 v-w 是桥</p>
<p><br></p>
<p>对于顶点的判断是怎样的?</p>
<p>比如看3这个顶点是不是一个割点? 对于3-5 这条边 low[5] = 4</p>
<p>这意味着通过5这个顶点到达最小的顶点是4, 比 ord[3] = 2 要大</p>
<p>显然通过5这个顶点回不到3, 更回不到3的祖先顶点. 所以一旦删掉3这个顶点, 就无法通过5回去, 联通分量就会发生变化</p>
<p>因此对于这个条件同样适合判断割点.</p>
<p><br></p>
<p><img src="/Blog/intro/graph/cut_point_1.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>但是只是这个条件不够. </p>
<p><strong>如果点 v 有一个孩子节点 w, 满足 low[w] &gt;= ord[v]​ 则 v 是割点</strong></p>
<p>为什么? </p>
<p>例如 5 这个顶点. 5-4 这条边 low[4] == ord[5] == 4</p>
<p>此时我们可以说5是割点. </p>
<p>low[4] = 4 代表通过4这个顶点可以返回的最小的ord值是4, 而ord值为4的点是5. 所以通过4这个顶点我们最多可以返回到5这个顶点. 一旦我们把5删掉</p>
<p>就相当于把和5相邻的所有边都删了我们通过4本来有一条路能回到顶点. 由于和5相邻的所有的边都删了, 它就再也回不到5这个顶点了</p>
<p>而low[4]记录的是回去最小ord值的顶点, 5这个顶点删除了, 就回不到5及5的上一级节点 </p>
<p>这样的情况下我们就可以说, 5是一个割点.</p>
<p><br></p>
<p><img src="/Blog/intro/graph/cut_point_1.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>然而这个条件还有bug. 如果添加等号的话, 起始点(根节点)就会出问题</p>
<p>此时就要对根节点进行特殊讨论.</p>
<p>对于根节点来说, 如果它有一个以上的孩子, 则根节点是割点</p>
<h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a><a target="_blank" rel="noopener" href="https://github.com/DaoLinZhou/GrapyTheory/blob/master/src/bridge/FindCutPoints.java">实现</a></h3><blockquote>
<p>是看DFS遍历树中, 根节点有多少个孩子. 而不是根节点有多少邻边</p>
<p><img src="/Blog/intro/graph/cut_point_2.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>这个图中根节点就不是割点</p>
<p><br></p>
<p><img src="/Blog/intro/graph/cut_point_3.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>这个图中根节点是割点</p>
</blockquote>
<p><br></p>
<p><br></p>
<p>寻找桥和割点的算法只是在DFS的基础上多记录一些信息就可以得到结果</p>
<blockquote>
<p>算法就是维护变量的语义, 一旦清晰变量的语义, 就可以通过这些语义组织出我们想要的逻辑</p>
</blockquote>
<p><br></p>
<p><br></p>
<h2 id="哈密尔顿回路和哈密尔顿路径"><a href="#哈密尔顿回路和哈密尔顿路径" class="headerlink" title="哈密尔顿回路和哈密尔顿路径"></a>哈密尔顿回路和哈密尔顿路径</h2><p>图论领域, 回路和路径两个概念是分开的</p>
<p>路径的起始点和终止点不一样, 而回路的起始点和终止点一样</p>
<p><br></p>
<h3 id="哈密尔顿回路"><a href="#哈密尔顿回路" class="headerlink" title="哈密尔顿回路"></a>哈密尔顿回路</h3><p>在一张图中, 从一个点出发, 沿着边行走, <strong>经过每个顶点恰好一次, 之后再回到出发点</strong></p>
<p><img src="/Blog/intro/graph/hamilton.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>这张图就有哈密尔顿回路.</p>
<p><br></p>
<p><img src="/Blog/intro/graph/hamilton_1.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>这张图就没有哈密尔顿回路</p>
<p><br></p>
<p><img src="/Blog/intro/graph/hamilton_2.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>如果我们把正12面体建模</p>
<p><img src="/Blog/intro/graph/hamilton_3.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>右边的平面图和左边的立体图是<strong>同构</strong>的</p>
<p>这个图是由哈密尔顿回路的.</p>
<p><br></p>
<p>对于这类问题, 数学上目前找不到充分必要条件.</p>
<p><br></p>
<p>这个问题也很像一个计算机领域一个非常著名的问题: 旅行推销员问题 (Travelling Salesman Problem, <strong>TSP</strong>)</p>
<p>旅行推销员问题是指: 给定一系列城市和每个城市间的距离, 求解访问每一座城市一次并回到起始城市的最短路径</p>
<p>这是一个带权图, 完全图</p>
<p><br></p>
<p><br></p>
<h3 id="求解哈密尔顿回路"><a href="#求解哈密尔顿回路" class="headerlink" title="求解哈密尔顿回路"></a>求解哈密尔顿回路</h3><p>我们没有非常好的数学性质来解决这个问题. 所以解决这个问题的方法就非常暴力了. 换句话说就是遍历所有的可能性</p>
<p><img src="/Blog/intro/graph/hamilton_4.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<h3 id="实现求解哈密尔顿回路"><a href="#实现求解哈密尔顿回路" class="headerlink" title="实现求解哈密尔顿回路"></a><a target="_blank" rel="noopener" href="https://github.com/DaoLinZhou/GrapyTheory/blob/master/src/path/HamiltonLoop.java">实现求解哈密尔顿回路</a></h3><p><br></p>
<p><br></p>
<h3 id="哈密尔顿路径"><a href="#哈密尔顿路径" class="headerlink" title="哈密尔顿路径"></a>哈密尔顿路径</h3><p>对于哈密尔顿路径来说, 起始点很重要.</p>
<p><img src="/Blog/intro/graph/hamilton_1.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>例如这张图, 如果起始点为0的话则有哈密尔顿路径, 起始点为1的话没有哈密尔顿路径.</p>
<p>因此我们需要指定起始点, 但给定起始点是否有哈密尔顿路径</p>
<h3 id="实现求解哈密尔顿路径"><a href="#实现求解哈密尔顿路径" class="headerlink" title="实现求解哈密尔顿路径"></a><a target="_blank" rel="noopener" href="https://github.com/DaoLinZhou/GrapyTheory/blob/master/src/path/HamiltonPath.java">实现求解哈密尔顿路径</a></h3><p><br></p>
<p><br></p>
<h2 id="状态压缩"><a href="#状态压缩" class="headerlink" title="状态压缩"></a>状态压缩</h2><p>其实之前也介绍过状态压缩</p>
<p>把二维坐标用一个数字表示就是状态压缩的一个例子</p>
<p>两个桶的水量用一个两位数表示</p>
<p><br></p>
<p>而求哈密尔顿路径也可以使用状态压缩.</p>
<p>visited数组可以使用一个数来表示, visited数组用来记录每一个顶点是否被遍历过</p>
<p>假设图有4个顶点的话.</p>
<p><img src="/Blog/intro/graph/stat_comp.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>我们可以把它想象成是一个二进制数 </p>
<p><img src="/Blog/intro/graph/stat_comp_1.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>就像在<a href="https://daolinzhou.github.io/Blog/2020/07/31/bloom-filter/">布隆过滤器</a>中做的一样. 不过由于求哈密尔顿路径是指数级的复杂度. 所以图的节点个数不能太多, 因此使用 int 或 long 就够用了, 这样最多可以存储32/64个节点的访问状态. </p>
<p><br></p>
<p><br></p>
<h2 id="记忆化搜索"><a href="#记忆化搜索" class="headerlink" title="记忆化搜索"></a>记忆化搜索</h2><p>对 visited 进行状态压缩提升 的效率有限, 主要是为记忆化搜索, 它把visited的状态压缩成了一个int值.</p>
<p><img src="/Blog/intro/graph/stat_comp_2.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>记忆化搜索的时间复杂度更低, 当有大量重复搜索时 使用记忆化搜索效率更高(通常在竞赛中数据做过手脚, 使得有大量重复)</p>
<p>如果没有大量重复, 使用回溯法的效率会更好</p>
<p><br></p>
<p><br></p>
<h2 id="欧拉回路和欧拉路径"><a href="#欧拉回路和欧拉路径" class="headerlink" title="欧拉回路和欧拉路径"></a>欧拉回路和欧拉路径</h2><p>回忆: 哈密尔顿回路</p>
<p>从一个点出发, 沿着边走, <strong>经过每个顶点恰好一次</strong>, 之后再回到出发点</p>
<p><br></p>
<p>欧拉回路: </p>
<p>从一个点出发, 沿着边走, <strong>经过每个边恰好一次</strong>, 之后在回到出发点</p>
<p><img src="/Blog/intro/graph/euler_loop.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>欧拉回路遍历所有的边, 而每一个边都是被顶点相连接的, 所以对于欧拉回路来说肯定遍历了所有的顶点. 这是否意味着对于一个图来说, 如果有欧拉回路就一定有哈密尔顿回路?</p>
<p>不是的, 虽然肯定遍历所有点, 但无法保证经过所有点恰好一次</p>
<p><img src="/Blog/intro/graph/euler_loop_1.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p><img src="/Blog/intro/graph/euler_loop_2.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>很长时间没有人能解决这个问题, 欧拉解决问题的思路: 证明这个问题没有解</p>
<p>其实这张图的边是非常少的, 使用计算机回溯求解就可以算出来.</p>
<p><br></p>
<h3 id="欧拉回路存在的性质"><a href="#欧拉回路存在的性质" class="headerlink" title="欧拉回路存在的性质"></a>欧拉回路存在的性质</h3><p><img src="/Blog/intro/graph/euler_loop_3.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>由于我们寻找的是一个回路, 所以对这张图的每一个点来说, 肯定要进这个点一次, 然后再出这个点一次. </p>
<p>这一进一出就相当于耗费了两条边</p>
<p>由于欧拉回路每条边只能访问一次, 沿着一条边进一个点, 再沿着一条边出一个点后, 这两条边就不能再走了</p>
<p><br></p>
<p>对于欧拉回路来说, 我们期望每条边都走一遍, 然后回到原点, 所以每个点都必须有进有出</p>
<p>因此, <strong>每一个点相邻边数 (即每个点的度) 必须是偶数</strong></p>
<p><img src="/Blog/intro/graph/euler_loop_3.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>这张图中4个点的度都是奇数, 所以就不可能存在欧拉回路</p>
<p><br></p>
<p>换句话说, 欧拉找到的性质是这样的</p>
<p>对于<strong>无向联通图</strong>, <strong>每个点的度是偶数 &lt;==&gt; 图存在欧拉回路</strong></p>
<p><br></p>
<p>之前只证明了backword: 图存在欧拉回路 =&gt; 每个点的度是偶数</p>
<p>接下来证明forward: 每个点的度是偶数 =&gt; 图存在欧拉回路</p>
<p><br></p>
<p><img src="/Blog/intro/graph/euler_loop_4.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>对于这张图来说, 所有的顶点的度都是偶数</p>
<p>首先从任意一点出发, 随便找一个环. 由于图是联通的, 同时每个点的度都是偶数, 所以肯定能找到一个环</p>
<p>如果这个环是原图, 则已经找到了欧拉回路.</p>
<p>否则, 剩下的边一定和我们找到的环相连, 且所有顶点的度依然是偶数, 即依然存在环</p>
<p>而两个相连的环一定可以组成一个新环.</p>
<p>(当遍历到新环时, 先走新环, 之后会回到这个点, 在走旧环)</p>
<p>直到得到所有边构成的环</p>
<p><br></p>
<p><br></p>
<h3 id="寻找欧拉回路的三个算法"><a href="#寻找欧拉回路的三个算法" class="headerlink" title="寻找欧拉回路的三个算法"></a>寻找欧拉回路的三个算法</h3><p><img src="/Blog/intro/graph/euler_loop_5.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>以这张图为例</p>
<h4 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h4><p>方法1就是用回溯法和哈密尔顿回路使用的回溯法本质是一样的, 时间复杂度时指数级的</p>
<p><br></p>
<h4 id="Fleury-算法"><a href="#Fleury-算法" class="headerlink" title="Fleury 算法"></a>Fleury 算法</h4><p>方法2是多项式级别的复杂度.</p>
<p>Fleury算法某种程度上讲是一种贪心算法</p>
<p><img src="/Blog/intro/graph/euler_loop_5.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>假设先走A-B这条边, A-B这条边就无法再次使用了, 此时我们把A-B这条边删去</p>
<p><img src="/Blog/intro/graph/euler_loop_6.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>此时如果是回溯法会尝试走B-C. 然而实际上不能走B-C这条边.</p>
<p>Fleury算法想办法避免了这个回溯的过程. Fleury算法说 B-C 这条边是一个<strong>桥</strong></p>
<p>如果把B-C删掉的话, 此时整张图就分割成了两部分</p>
<p>所以此时Fleury算法说我们不能走这个桥</p>
<p><br></p>
<blockquote>
<p>Fleury算法说, 如果有多条边可以选的话, 不走桥, 随便选一条其他路就可以了</p>
<p>这也是说 Fleury 算法有贪心性质的原因</p>
</blockquote>
<p>尽管如此, 对于Fleury算法来说, 用这个原则在每个顶点上选择路为什么能找到欧拉回路是需要证明的</p>
<blockquote>
<p>这里不做证明, 毕竟这个算法的性能不是最优的. 了解即可</p>
<p>这也是贪心算法的难点. 思考”怎么贪”是容易的, 但是证明”这么贪”是正确的很难</p>
<p>只有满足”贪心选择性质”的问题才能使用贪心算法解决</p>
</blockquote>
<p><br></p>
<p>因此 Fleury 就要对每一个邻边判断一下桥. 而且寻找桥的过程是不能预处理的.</p>
<p>因为每走过一条边就要删除这条边. 图是在时刻变化的.</p>
<p>每次走过一条边, 对于新的图判断有没有桥. 遍历所有的点是 $O(V+E)$ 级别的. 判断图有没有桥是 $O(V+E)$ 级别的. 因此这个算法的时间复杂度是$O((V+E)^2)$ 级别的</p>
<p>由于寻找欧拉回路是在一个联通图上完成的. 所以时间复杂度可以简写为$O(E^2)$</p>
<p><br></p>
<p><br></p>
<h4 id="Hierholzer-算法"><a href="#Hierholzer-算法" class="headerlink" title="Hierholzer 算法"></a>Hierholzer 算法</h4><p>这个算法和之前证明为什么每一个顶点的度是偶数就存在欧拉回路的<strong>构造性证明</strong>方式是完全一样的.</p>
<p><br></p>
<p><img src="/Blog/intro/graph/euler_loop_5.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>具体来讲, 从A出发, 随便走即可, 最终肯定走出一个环. 假设走A-B-C-A. 之后删除掉这些边</p>
<p><img src="/Blog/intro/graph/euler_loop_7.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>此时剩下的边一定形成环, 并且和之前找到的环有一个公共点</p>
<p>由于有这个公共点, 我们只需要把剩下的环找到, 和原先的环形成一个大的环</p>
<p>这个算法的时间复杂度是 $O(V+E)$ 级别的. 不过由于是在联通图中, 我们说它是 $O(E)$ 级别也是没有问题的</p>
<p><br></p>
<p><br><img src="/Blog/intro/graph/euler_loop_5.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>Hierholzer的实现需要使用两个栈 (其实一个栈就够了)</p>
<p>curPath: 当前已经走的路径</p>
<p>loop: 存在当前图中找到的欧拉回路</p>
<p><img src="/Blog/intro/graph/euler_loop_8.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>先找到一个环, 此时已经无路可走了, 就把 curPath 中的节点挪到 loop 这个栈中</p>
<p>在挪的过程中, 如果我们发现某个点还能拓展去找其他的环, 我们再去走那个环</p>
<p><img src="/Blog/intro/graph/euler_loop_9.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>而B这个顶点有其他的邻边, 所以从B这个顶点出发还可以再找到环, B-D-E-B又是一个环</p>
<p><img src="/Blog/intro/graph/euler_loop_10.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>此时B不能再走到任何位置了.</p>
<p><img src="/Blog/intro/graph/euler_loop_11.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>此时curPath空了, 说明所有的点都遍历完了</p>
<p>每个边走了一次, 回退一次, 所以算法的复杂度时 O(E) 级别的</p>
<p><br></p>
<h4 id="实现Hierholzer算法"><a href="#实现Hierholzer算法" class="headerlink" title="实现Hierholzer算法"></a><a target="_blank" rel="noopener" href="https://github.com/DaoLinZhou/GrapyTheory/blob/master/src/path/EulerLoop.java">实现Hierholzer算法</a></h4><p><br></p>
<h3 id="欧拉路径"><a href="#欧拉路径" class="headerlink" title="欧拉路径"></a>欧拉路径</h3><p>从一个点出发, 沿着边行走, 经过每个边恰好一次, 之后来到结束点, 结束点和起始点可以不一样.</p>
<p><br></p>
<p>欧拉回路的求法是先找出一个环. 换句话说就是先找到一个起始点和终止点相同的路径.</p>
<p>而欧拉路径也可以用同样的思想, 先找到起始点到终止点的一条路径. 逆推每个点, 如果这个点还有其余相邻的边, 则说明这个点是某个环的一部分. </p>
<p>而找到起始点到终止点的一条路径的代码其实和在欧拉路径找环的代码完全一致. 因为从起始点出发, 只有到达终止点才会导致没有相邻边可以访问(因为终止点的度为奇数). 只不过起始点不能从0开始.</p>
<p><br></p>
<p>怎么判断起始点和终止点. 起始点和终止点的度肯定为奇数, 其余的点则为偶数. 因为起始点只出不进, 终止点只进不出</p>
<blockquote>
<p> 欧拉路径存在的性质:</p>
<p>对于无向联通图, <strong>除了两个点</strong>每个点的度是偶数 &lt;==&gt; 图存在欧拉路径</p>
</blockquote>
<h4 id="求欧拉路径"><a href="#求欧拉路径" class="headerlink" title="求欧拉路径"></a><a target="_blank" rel="noopener" href="https://github.com/DaoLinZhou/GrapyTheory/blob/master/src/path/EulerPath.java">求欧拉路径</a></h4><p><br></p>
<p><br></p>
<h2 id="有向图"><a href="#有向图" class="headerlink" title="有向图"></a>有向图</h2><p>有向图就是每一个边都带有方向的图</p>
<p><img src="/Blog/intro/graph/direct_graph.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>此时可以从0走到1, 但不能从1走到0</p>
<p><img src="/Blog/intro/graph/direct_graph_1.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<h3 id="有向图的环检测"><a href="#有向图的环检测" class="headerlink" title="有向图的环检测"></a>有向图的环检测</h3><p>有向图中, “环”这个概念是由非常重要的概念的</p>
<p><img src="/Blog/intro/graph/direct_graph.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>和无向图的环检测类似, 依然是如果找到一个之前点之前访问过, 就说明有环. 不过有一点不一样. 因为在有向图中, 遍历过不代表形成环</p>
<p>例如上图 0-1-2-4, 之后退回成 0-1尝试走3, 那么2-4就不在当前路径上, 所以要添加一个标记, 表示在当前路径上</p>
<p>环是回到一个当前路径上的点, 而不仅仅是一个已经遍历过的点.</p>
<p><br></p>
<p>橙色圈代表在当前路径上</p>
<p><img src="/Blog/intro/graph/direct_graph_2.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>回退到1</p>
<p><img src="/Blog/intro/graph/direct_graph_3.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/graph/direct_graph_4.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>此时所有点都访问过, 且没找到同一路径上点, 所以整张图没有环</p>
<p><br></p>
<p>假设3-0之间有一条边.</p>
<p><img src="/Blog/intro/graph/direct_graph_5.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>那么此时通过3就能回到0, 而0是一个被标记了的点, 所以图中有环</p>
<h4 id="实现有向图环检测"><a href="#实现有向图环检测" class="headerlink" title="实现有向图环检测"></a><a target="_blank" rel="noopener" href="https://github.com/DaoLinZhou/GrapyTheory/blob/master/src/dfs/DirectedCycleDetection.java">实现有向图环检测</a></h4><p><br></p>
<h3 id="为什么有向图环检测非常重要"><a href="#为什么有向图环检测非常重要" class="headerlink" title="为什么有向图环检测非常重要?"></a>为什么有向图环检测非常重要?</h3><p>因为在很多应用中, 我们要确保有向图无环</p>
<p>例如: 程序模块的引用.</p>
<p>编程中一个很重要的问题就是: <strong>循环引用</strong></p>
<p>从编译器的角度, 要想检测到有循环引用其实本质就是做有向图换检测</p>
<p><br></p>
<p><strong>有向无环图</strong>是非常有意义的, 通常我们为它起一个名字(DAG: Directed Acyclic Graph)</p>
<p><br></p>
<p><br></p>
<h3 id="有向图的度"><a href="#有向图的度" class="headerlink" title="有向图的度"></a>有向图的度</h3><p>有向图的度和无向图的度不太一样</p>
<p>无向图中, 一个顶点的度是这个点相邻的边数</p>
<p><img src="/Blog/intro/graph/direct_graph_6.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>对于这个图, 顶点1的度是3</p>
<p><br></p>
<p>而对于有向图中, 边是包含有方向的</p>
<p><img src="/Blog/intro/graph/direct_graph.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>所以看和1相邻的边, 虽然还是有3条, 但是这3条边方向各部相同.</p>
<p>有两条边是从1出去的边. 有一条边是进入1的边. 这两种边是截然不同的</p>
<p>因此在有向图中, 更为细分的, 把度分为 <strong>入度(indegree)</strong> 和 <strong>出度(outdegree)</strong></p>
<p>所谓<strong>入度</strong>, 就是进入顶点的边</p>
<p>所谓<strong>出度</strong>, 就是从顶点出去的边</p>
<p><br></p>
<p><img src="/Blog/intro/graph/direct_graph.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>对于这个图来说</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>顶点</th>
<th>入度(indegree)</th>
<th>出度(outdegree)</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>2</td>
<td>2</td>
<td>1</td>
</tr>
<tr>
<td>3</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>4</td>
<td>1</td>
<td>0</td>
</tr>
</tbody>
</table>
</div>
<p><br></p>
<p>欧拉回路依赖与每个顶点的度, 而有向图中, 入度和出度都没有了, 那么我们怎么求解欧拉回路?</p>
<p><br></p>
<p><br></p>
<h3 id="有向图求解欧拉回路"><a href="#有向图求解欧拉回路" class="headerlink" title="有向图求解欧拉回路"></a>有向图求解欧拉回路</h3><p>无向图存在欧拉回路的充分必要条件: 每个点的度数为偶数</p>
<p>这是因为对于每个顶点一进一出, 必定是2的倍数</p>
<p>所以有向图的欧拉回路的充分必要条件: <strong>每个点的入度等于出度</strong></p>
<p><br></p>
<p>如果一个图有欧拉回路, 在求解欧拉回路的过程中, 那么当一个点的出度为0, 说明找到一个环, 无法继续向下走 (在无向图中是度为0代表找到一个环)</p>
<h4 id="求有向图欧拉回路"><a href="#求有向图欧拉回路" class="headerlink" title="求有向图欧拉回路"></a><a target="_blank" rel="noopener" href="https://github.com/DaoLinZhou/GrapyTheory/blob/master/src/path/DirectedEulerLoop.java">求有向图欧拉回路</a></h4><p><br></p>
<h3 id="有向图的欧拉路径"><a href="#有向图的欧拉路径" class="headerlink" title="有向图的欧拉路径"></a>有向图的欧拉路径</h3><p>无向图存在欧拉路径的充分必要条件: 处理两个点的度为奇数, 其余每个点的度数为偶数</p>
<p><br></p>
<p>有向图存在欧拉路径的充分必要条件:</p>
<p>除了两个点, 其余每个点的入度等于出度. 这两个点, 一个入度比出度大一(终止点); 一个出度比入度大一(起始点)</p>
<h4 id="求有向图欧拉路径"><a href="#求有向图欧拉路径" class="headerlink" title="求有向图欧拉路径"></a><a target="_blank" rel="noopener" href="https://github.com/DaoLinZhou/GrapyTheory/blob/master/src/path/DirectedEulerPath.java">求有向图欧拉路径</a></h4><p><br></p>
<p>哈密尔顿回路和哈密尔顿路径在无向图中用的是穷举法. 这点在有向图中也是一样的. 所以原本哈密尔顿回路的算法不需要做任何改变就可以作用在有向图中</p>
<p><br></p>
<p><br></p>
<h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><p>拓扑排序是只存在于有向图中的算法</p>
<p><img src="/Blog/intro/graph/direct_graph.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>我们可以把这张图想象成一个一个的任务.</p>
<p>要完成任务1, 就要先完成任务0, 要完成任务2, 要先完成任务1, 3. 要完成任务4, 就要先完成任务2.</p>
<p>因此我们就要找到一个顺序去完成任务. 这就是拓扑排序</p>
<p><br></p>
<p><img src="/Blog/intro/graph/direct_graph_7.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>首先要找到入度为0的点, 入度为0的点必须先进行访问</p>
<p>之后删除这个顶点(以及这个顶点相连接的边), 同时更新顶点的度.</p>
<p><br></p>
<p><img src="/Blog/intro/graph/direct_graph_8.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>现在这幅图中, 还没有被排序的顶点中入度为0的点是1. 所以接下来对顶点1进行访问</p>
<p><img src="/Blog/intro/graph/direct_graph_9.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p>之后再找没有排序的顶点中入度为0的点, 访问顶点3.</p>
<p><img src="/Blog/intro/graph/direct_graph_10.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p>之后同理, 最终得到结果</p>
<p><img src="/Blog/intro/graph/direct_graph_11.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p>0-1-3-2-4 就是这张图的拓扑排序的结果</p>
<p><br></p>
<p>拓扑排序在真正实现时并不需要删除点, 只要假象删除掉了即可</p>
<p><br></p>
<p>拓扑排序的结果不唯一, 例如同时有3个顶点的入度为0时, 此时先访问那个时无所谓的.</p>
<p>然而拓扑排序也有可能是无解的. </p>
<p><img src="/Blog/intro/graph/direct_graph_12.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>例如上图, 图中没有任何一个点的入度为0 (图中有环)</p>
<p>因此, 拓扑排序有一个附加作用: 可以用于<strong>有向图的环检测</strong></p>
<p>如果拓扑排序完后, 还有点没有访问, 就说明图中有环</p>
<p><br></p>
<p>只有有向无环图 DAG 才可以进行拓扑排序</p>
<h3 id="拓扑排序实现"><a href="#拓扑排序实现" class="headerlink" title="拓扑排序实现"></a><a target="_blank" rel="noopener" href="https://github.com/DaoLinZhou/GrapyTheory/blob/master/src/topo/TopoSort.java">拓扑排序实现</a></h3><p>这个算法是最常规的拓扑排序算法.</p>
<p><br></p>
<h3 id="拓扑排序的另一个算法"><a href="#拓扑排序的另一个算法" class="headerlink" title="拓扑排序的另一个算法"></a>拓扑排序的另一个算法</h3><p>O(V+E)</p>
<p>这个算法有局限, 不实用. 然而了解这个算法的思路有助于理解<strong>有向图的强联通分量.</strong></p>
<p><br></p>
<p><strong>深度优先后序遍历</strong></p>
<p>对于一个节点, 首先遍历完其所有相邻节点之后, 再遍历它自身</p>
<p><img src="/Blog/intro/graph/direct_graph.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>这张图, 深度优先后序遍历的结果是 4-2-3-1-0 (无论再顶点1时访问2还是访问3, 结果都不变)</p>
<p>而这张图的拓扑排序结果是 0-1-3-2-4, 正好是深度优先后序遍历的逆序</p>
<p>这个逆序的关系并不是偶然</p>
<p>这就是求解拓扑排序的另外一个算法.</p>
<p><br></p>
<p>一个图的深度优先后序遍历的逆序就是拓扑排序的结果</p>
<p><br></p>
<h3 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h3><p>关键点是: 对于一个节点, <strong>首先遍历完其所有相邻节点之后</strong>, 再遍历它自身</p>
<p><strong>所以一个节点的后序节点一定出现在这个节点的前面</strong></p>
<p><br></p>
<p>例如对于1来说, 节点2, 3, 4一定出现在1的前面, 只有遍历完234, 才会遍历1. </p>
<p>同理对于节点2, 节点4一定出现在它前面.</p>
<p>对于节点3, 节点2, 4一定出现在它前面</p>
<p>而对这个序列求逆的话. <strong>就说明对于一个节点, 它的前置节点一定出现在它的前面</strong></p>
<p><br></p>
<p>然而这个算法有个坑. <strong>这个算法无法做环检测</strong>. 即使有环, 依然可以对它进行深度优先遍历. 依然可以求逆序.</p>
<p>因此要想使用这个算法就要保证图是一个DAG (有向无环图)</p>
<h3 id="第二种拓扑排序实现"><a href="#第二种拓扑排序实现" class="headerlink" title="第二种拓扑排序实现"></a><a target="_blank" rel="noopener" href="https://github.com/DaoLinZhou/GrapyTheory/blob/master/src/topo/TopoSort2.java">第二种拓扑排序实现</a></h3><p><br></p>
<p><br></p>
<h2 id="有向图的强联通分量"><a href="#有向图的强联通分量" class="headerlink" title="有向图的强联通分量"></a>有向图的强联通分量</h2><p><img src="/Blog/intro/graph/directed_cc.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>这个图中, 从1可以到达4但是不能从4到达1.</p>
<p>所以虽然看起来所有顶点都是连接的. 但是它不像无向图那样, 任意两点之间都互相可达.</p>
<p><br></p>
<h3 id="强联通分量"><a href="#强联通分量" class="headerlink" title="强联通分量"></a>强联通分量</h3><p><strong>强联通分量</strong>: 在一个强联通分量中, 任何两点都相互可达</p>
<p><img src="/Blog/intro/graph/directed_cc.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>虽然这张图中好像是联通的. 但是由于它不能满足<strong>任意两点互相可达</strong>, 所以它不是强联通的.</p>
<p><br></p>
<p><img src="/Blog/intro/graph/directed_cc_1.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>这个有向图中, 其实有3个强联通分量. (上图已经用颜色区分)</p>
<p>在每个强联通分量内部任何两点都相互可达</p>
<p><br></p>
<p><img src="/Blog/intro/graph/directed_cc_2.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>这三个强联通分量内部的点是互相可达的. 但是区域于区域之间不是互相可达的</p>
<p>从一个区域只能去另一个区域, 但是无法回来</p>
<p>因此我们可以<strong>把每个强联通分量想象成一个点</strong></p>
<p>强联通分量之间如果从一个强联通分量的点可以到达另外一个强联通分量的点的话, 就做一条边. 这样任意一个有向图都可以将其规约成一个新的有向图.</p>
<p><img src="/Blog/intro/graph/directed_cc_3.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>这个新的有向图是将所有强联通分量看作一个点</p>
<blockquote>
<p>这个新的有向图一定是一个DAG. 一定是一个有向无环图</p>
<p>反证法: 假设如果有环</p>
<p><img src="/Blog/intro/graph/directed_cc_4.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>那么这就意味着这些区域也是两两可达的, 而这些区域间的每个蓝色点又是互相可达的, 所以所有点可以通过这个环互相可达. 所以这些点应该属于一个强联通分量. 因此我们的图就是错的. 因为我们的图把所有的强联通分量都看作是一个顶点. 矛盾</p>
</blockquote>
<p><br></p>
<p><img src="/Blog/intro/graph/directed_cc_3.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>求解强联通分量, 就相当于求这A-B-C..强联通分量中都有哪些顶点</p>
<p><br></p>
<h4 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路:"></a>算法思路:</h4><p><img src="/Blog/intro/graph/directed_cc_3.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>我们可以先对E这个点进行DFS遍历, 这个遍历过程中可以访问到的点一定都局限在E这个区域中.</p>
<p>因为E这个区域到达不了其他区域.</p>
<p>之后我们在对D这个区域进行DFS, 由于E已经被遍历过了, 所以D不会到E. 因此遍历过程中访问的点都局限在D中</p>
<p>以此类推, 再遍历C, B, A区域中的点</p>
<p><br></p>
<p>我们是按照什么顺序进行遍历这些区域?</p>
<p>是按照新的区域拓扑排序的逆序进行遍历的.</p>
<p>由于这个新的图是DAG, 所以一定存在拓扑排序</p>
<p><br></p>
<p><img src="/Blog/intro/graph/directed_cc_3.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>然而这个新的图是我们假想出来的, 有没有可能我们先找到E这个区域中的点. 用dfs遍历完, 再找到D区域中的点, 用dfs遍历… …</p>
<p><br></p>
<h4 id="Kosaraju算法"><a href="#Kosaraju算法" class="headerlink" title="Kosaraju算法"></a>Kosaraju算法</h4><p><img src="/Blog/intro/graph/directed_cc_3.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>重新整理一下思路:</p>
<p>我们希望找到一个<strong>访问节点的顺序</strong>, 使得我们先对E进行深度遍历, 再对D进行深度遍历… …</p>
<p>而对D中一个节点进行DFS就相当于对整个联通分量D进行了遍历. 因此节点的访问顺序并不一定要让一个联通分量的节点聚集在一起</p>
<p><br></p>
<p><img src="/Blog/intro/graph/directed_cc_3.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>举个例子:</p>
<p>上图中E有1个节点, D有4个节点, C有2个节点, B有3个节点, A有一个节点</p>
<p>一个可能的访问顺序:</p>
<figure class="highlight clean"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs clean">E1 -&gt; D1 -&gt; C1 -&gt; D2 -&gt; B1 -&gt; A1 -&gt; C2 -&gt; D3 -&gt; D4 -&gt; B2 -&gt; B3<br></code></pre></td></tr></table></figure>
<p>这个顺序是我随便写的, </p>
<p>假设我们先访问E1. 就对联通分量E进行了遍历. 所有E内的节点都访问过了.(只有一个E1)</p>
<p>之后访问D1, 联通分量D内所有节点(D1 - D4) 就都被访问过了.</p>
<p>同理访问C1, 联通分量C内所有节点(C1, C2) 也就被访问过了</p>
<p>之后轮到D2, 然而我们之前在访问D1时, 就对D1-D4进行了遍历, 所以直接跳过D2即可</p>
<p>之后访问B1, 联通分量B内所有的节点(B1-B3也都访问过了)</p>
<p>… …</p>
<p><br></p>
<p>例子虽然是随便写的, 但它遵循一个规律. 在这个访问顺序中:</p>
<p><strong>有一个</strong>E中的节点排在<strong>所有</strong>DCBA节点之前. 所以我们可以先遍历E在遍历其他联通分量</p>
<p><strong>有一个</strong>D中的节点排在<strong>所有</strong>CBA节点之前. 所以我们可以在遍历CBA之前先遍历联通分量D</p>
<p><strong>有一个</strong>C中的节点排在<strong>所有</strong>BA节点之前. 所以我们可以在遍历BA之前先遍历联通分量C</p>
<p><br></p>
<p>到这里就能知道我们到底想要一个怎样的访问顺序了. 问题是怎么得到这个访问顺序?</p>
<p>是否可以对原图进行后序DFS得到这个访问顺序?</p>
<p><img src="/Blog/intro/graph/directed_cc_3.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>如果我们对原图进行DFS.</p>
<p>A节点肯定排在最后, 之后是某一个B节点… …</p>
<p>换句话说:</p>
<p><strong>有一个</strong>A中的节点排在<strong>所有</strong>BCDE节点之后.</p>
<p><strong>有一个</strong>B中的节点排在<strong>所有</strong>CDE节点之后.</p>
<p><strong>有一个</strong>C中的节点排在<strong>所有</strong>DE节点之后.</p>
<p><strong>有一个</strong>D中的节点排在<strong>所有</strong>E节点之后.</p>
<p>如果取逆序的话就是:</p>
<p><strong>有一个</strong>A中的节点排在<strong>所有</strong>BCDE节点之前.</p>
<p><strong>有一个</strong>B中的节点排在<strong>所有</strong>CDE节点之前.</p>
<p><strong>有一个</strong>C中的节点排在<strong>所有</strong>DE节点之前.</p>
<p><strong>有一个</strong>D中的节点排在<strong>所有</strong>E节点之前.</p>
<p>这和我们想要的结果就非常相似了.</p>
<p><br></p>
<p>我们想要的结果是</p>
<p><strong>有一个</strong>E中的节点排在<strong>所有</strong>DCBA节点之前</p>
<p><strong>有一个</strong>D中的节点排在<strong>所有</strong>CBA节点之前</p>
<p><strong>有一个</strong>C中的节点排在<strong>所有</strong>BA节点之前</p>
<p>… …</p>
<p>很显然节点的顺序反了.</p>
<p><img src="/Blog/intro/graph/directed_cc_3.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>如果把联通分量当作节点, 进行拓扑排序的顺序是A-B-C-D-E</p>
<p>这和我们用原图进行后序DFS再取逆序的结果的顺序是一样的, 有一个A节点排在BCDE之前, 有一个B节点排在CDE之前… …</p>
<p>(这点其实也比较好理解, 假设后序深度遍历进入C, C中节点两两互通, 所以<strong>后序深度遍历</strong>一定会走出C, 走向D或E, 之后回溯C, 访问C中的某个节点, 具体是哪个节点, 当然看从哪个节点进入C, 这个节点一定最后访问, 因为是后序遍历)</p>
<p><br></p>
<p>所以一个自然的想法就是改变图, 使得新图的拓扑排序结果是 E-D-C-B-A.</p>
<p>这个改变图的方法就是<strong>翻转这张图</strong>, 翻转这张图后再进行拓扑排序的结果就是对原图进行拓扑排序的逆序</p>
<p><br></p>
<p>因此: <strong>翻转这张图后, 后序遍历的逆是我们想要的访问节点的顺序</strong></p>
<p>得到访问的顺序后, 就按照这个顺序对<strong>原图</strong>进行DFS即可</p>
<p><br></p>
<h3 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a><a target="_blank" rel="noopener" href="https://github.com/DaoLinZhou/GrapyTheory/blob/master/src/dfs/SCC.java">实现</a></h3><p><img src="/Blog/intro/graph/directed_cc_13.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p><br></p>
<h2 id="网络流"><a href="#网络流" class="headerlink" title="网络流"></a>网络流</h2><h3 id="网络流模型和最大流问题"><a href="#网络流模型和最大流问题" class="headerlink" title="网络流模型和最大流问题"></a>网络流模型和最大流问题</h3><h4 id="什么是网络流模型"><a href="#什么是网络流模型" class="headerlink" title="什么是网络流模型?"></a>什么是网络流模型?</h4><p><img src="/Blog/intro/graph/net_stream.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>这个图是一个有向图. 如果我们说一个<strong>有向图</strong>是网络流的话, 有一些限定.</p>
<ul>
<li>必须有一个源点 (入度为0)</li>
<li>必须有一个汇点 (出度为0)</li>
<li>边上有非负权值, 表示容量</li>
</ul>
<p>上图中 0 就是源点, 通常标记为 s . 5 就是汇点, 通常标记为 t</p>
<p><br></p>
<p>网络流的边的权值和最短路径边的权值不一样. 最短路径的边的权值是距离, 所以我们求最短距离</p>
<p>而网络流模型边的权值代表容量. 这个有向图我们可以想象成一个水管通路的模型.</p>
<p>源点 s 可以看作水龙头, 水会通过边留到其他点. 每条边可以看作是一条管道. 边的权值就代表容量, 说明每条边最大承载水流量</p>
<p>所有的水会汇入汇点 t.</p>
<p><br></p>
<p>然而实际我们关心的是<strong>流量</strong>, <strong>容量</strong>只是表示了一个上限, 流量要满足这个限制. 因此实际我们表示网络流是这样表示的</p>
<p><img src="/Blog/intro/graph/net_stream_1.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>前面蓝色的数代表流量, 后面的数代表容量. 初始时, 流量都为0, 而容量是固定的.</p>
<p><br></p>
<p>如果从源点到汇点, 走 0-1-2-5 这条路径, 只运输一单位的货物. 此时在这条路径中每条边的流量就要+1</p>
<p><img src="/Blog/intro/graph/net_stream_2.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>如果再走 0-1-3-2-5 这条路径, 每条边的流量再+1</p>
<p><img src="/Blog/intro/graph/net_stream_3.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>此时 3-2 这条边流量为1, 容量为1, 这条边就不能承载更多了流量了. 如果我们再想发一批货物的话, 再这个网络流中就不能走 3-2 这条边了.</p>
<p><br></p>
<p><img src="/Blog/intro/graph/net_stream_3.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>很明显网络流有一些限制</p>
<ol>
<li>容量限制, 每条边的流量值必须小于等于流量值</li>
<li>平衡限制, 除了原点和汇点, 对于每一个点, 流入量等于流出量 </li>
</ol>
<p>因此从源点流出的流量一定最终等于汇入汇点的流量</p>
<p><br></p>
<h4 id="什么是最大流问题"><a href="#什么是最大流问题" class="headerlink" title="什么是最大流问题?"></a>什么是最大流问题?</h4><p>最大流问题就是在这个网络流模型中, 最大流量是多少</p>
<p>就是说在满足这些限制的条件下, 我们从源点最多能发出多少流量, 既满足容量限制, 又满足平衡限制, 最终汇聚到汇点</p>
<p><br></p>
<p><br></p>
<h3 id="Ford-Fulkerson思想"><a href="#Ford-Fulkerson思想" class="headerlink" title="Ford-Fulkerson思想"></a>Ford-Fulkerson思想</h3><p>这不是一个算法, 这是一个思想. Ford-Fulkerson 本身是一个算法框架, 基于这个算法框架我们可以有不同的实现.</p>
<p> 以这个规模更小的图为例</p>
<p><img src="/Blog/intro/graph/net_stream_4.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p>如果我们要求解最大流量, 那么当我们找到一条路径之后, 这条路径可以承载的<strong>最大流量</strong>应该是把这条路径中<strong>最小容量的边填满</strong></p>
<p><img src="/Blog/intro/graph/net_stream_5.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>对于路径 0-2-3, 最小容量=最大流量=2, 我们将这条路径填满</p>
<p><img src="/Blog/intro/graph/net_stream_6.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p>同理也可以把 0-1-3 这条路径填满</p>
<p><img src="/Blog/intro/graph/net_stream_7.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p>如果此时还有从0到3的路径. 那么肯定不能走 0-2 了. 0-2 这条边已经满了, 只能走0-1这条边.</p>
<p>来到1之后不能从1直接走到3.</p>
<p>这是因为1-3这条边的容量也已经满了, 所以只能走1-2这条边, 在从2走到3.</p>
<p>0-1-2-3这条路径最多还可以再容纳1的流量</p>
<p><img src="/Blog/intro/graph/net_stream_8.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p>然而路径也不是随便找的. 例如我们如果先找 0-1-2-3 这条路径.</p>
<p><img src="/Blog/intro/graph/net_stream_9.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>此时就无法继续向下找了. 也就是说这么走只能处理3个单位的流量. 显然这不是这张图的最大流量</p>
<p><br></p>
<p><img src="/Blog/intro/graph/net_stream_9.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>既然3这个流量不是最大流量, 那么就是说我们还能找到其他的方式添加流量.</p>
<p>依然从0出发, 0-2这条路径容量为2, 流量为0, 还能容纳2的流量. 那么我们就从0走到2</p>
<p><img src="/Blog/intro/graph/net_stream_10.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>但是对于这2单位的流量从2走到3的流量满了. 但是1-2这条边向2这条边流入3单位的流量</p>
<p>现在从 0-2 流入2单位流量, 不满足平衡限制. 因此我们可以尝试让1-2这条边少流入2单位流量</p>
<p> 这其实相当于从2节点逆流回1节点2单位流量</p>
<p><img src="/Blog/intro/graph/net_stream_11.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>从1节点流入2节点3单位流量再从2节点流回1节点2单位流量 <strong>等同于</strong> 1节点流入2节点1单位流量</p>
<p>虽然从2到1没有边, 但由于从1-2有流量, 那么从0走到2多于的这部分流量可以和从1-2这部分流量抵消</p>
<p>而1-3还能容纳2单位流量, 我们就走这条边</p>
<p><img src="/Blog/intro/graph/net_stream_12.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>此时走这样一条路径就从源点到汇点多输入了2单位流量.</p>
<p><br></p>
<p>这就是Ford-Fulkerson思想, 依然是想从原点出发找一条路径, 只要这条路径可以容纳新的流量, 那么我们就向整个网络流中注入新的流量</p>
<p>只不过整个过程中我们<strong>不能只看容量</strong>, 如果在一条边中存在流量, 那么就意味着新的流量可以和已经有的流量进行抵消.</p>
<p>我们称2-1这条边为反向边 1-2这条边称为正向边, 反向边的容量=正向边的流量.</p>
<p><img src="/Blog/intro/graph/net_stream_13.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>实际上在整个网络流模型中找新的路径尝试添加新的流量实在左边这张图上工作的.</p>
<p>这个图通常被称为<strong>残量图(Residual Graph)</strong></p>
<p><strong>如果原图的 v-w 容量为c 流量为f. 那么残量图中的v-w的权值为c-f, w-v的权值为f</strong></p>
<p><img src="/Blog/intro/graph/net_stream_14.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>这个路径就叫增广路径</p>
<p><br></p>
<p>Ford-Fulkerson 思想就是从原始的图出发创建出这样一个残量图. 在残量图中不断地找增广路径. 直到没有增广路径为止.</p>
<p><br></p>
<p>Ford-Fulkerson就是说在残量图中找增广路径, 但具体怎么找增广路径它没说, 使用不同方式找增广路径, 时间复杂度也不同.</p>
<p><br></p>
<p><br></p>
<h3 id="Edmonds-Karp算法"><a href="#Edmonds-Karp算法" class="headerlink" title="Edmonds-Karp算法"></a>Edmonds-Karp算法</h3><p>初始时先求出残量图</p>
<p><img src="/Blog/intro/graph/net_stream_15.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>而 Edmonds-Karp 就是使用 BFS 寻找增广路径</p>
<p>因为我们随便找到一条增广路径即可, 问题就是在残量图中从源点到汇点的路径. 本质是一个寻找路径的问题, 只不过权值为0的边不能走而已. </p>
<p>循环使用BFS寻找增广路径, 更新残量图, 直到找不到新的增广路径</p>
<p><br></p>
<p>算法流程</p>
<ol>
<li>通过网络流模型图构建残量图</li>
<li>在残量图中找增广路径</li>
<li>获取路径中的最大流量(最小容量)</li>
<li>更新残量图的流量, 更新最大流</li>
<li>重复2-4直到找不到新的增广路径</li>
</ol>
<h4 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a><a target="_blank" rel="noopener" href="https://github.com/DaoLinZhou/GrapyTheory/blob/master/src/netflow/MaxFlow.java">算法实现</a></h4><p><br></p>
<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>Ford-Fulkerson思想: $O(maxflow \cdot E)$ </p>
<p>每寻找一个增广路径, 至少流量+1. 最坏情况下, 要找maxflow个路径. 每一次要扫描一变所有边和点. O(V+E), 而连通图中V是E的低阶项, 所以省略V</p>
<p>Edmods-Karp算法: $O(V \cdot E^2)$</p>
<p>这个算法复杂度的分析较难.</p>
<p><br></p>
<p>Edmods-Karp算法 通常比 Ford-Fulkerson思想 性能高, 因为maxflow通常取决于每条边的权值. 而图的规模可能很小. 大部分情况下$maxflow &gt; V\cdot E$</p>
<p><br></p>
<p><br></p>
<h3 id="最大流算法建模"><a href="#最大流算法建模" class="headerlink" title="最大流算法建模"></a>最大流算法建模</h3><p>最大流算法可以解决很多问题, 这里介绍一个最经典的问题.</p>
<p>假设现在有棒球比赛. 5个队伍进行比赛, 比赛的某一时刻的比分如下</p>
<p><img src="/Blog/intro/graph/net_stream_16.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>底特律队胜49场, 负86场, 且还要进行27场比赛, 底特律要和纽约队进行3场比赛, 和baltimore队进行4场比赛. 问底特律队有没有机会得冠?</p>
<p>理想情况下底特律队剩余的27场比赛全都赢, 也就是底特律队拿下76场胜利. 而其余的队伍的胜利都小于76场. 这样底特律队才能赢.</p>
<p><br></p>
<p>如何用最大流解决这个问题?</p>
<p>我们假设最好的情况, 底特律队的剩余27场都赢了.</p>
<p>而0-3这4个队伍的其余比赛都输了.</p>
<p>然而0-3这4个队伍互相之间还有27场比赛, 就意味着要<strong>分配</strong>27次胜利给这4个队伍.</p>
<p>我们把每组可能的比赛情况当作一个节点.</p>
<p><img src="/Blog/intro/graph/net_stream_17.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>New York 和 Baltimore 要进行3场比赛, 所以说要分配3场胜利给”New York和Baltimore这场比赛”. 而”New York 和 Baltimore” 再分这3场胜利.</p>
<p>而这场比赛最多分给New York 三场胜利. 最多分给Baltimore3场胜利. (但不可能两个队都获得3场胜利, 因为我们只分给NY-Bal这场比赛3次胜利)</p>
<p><img src="/Blog/intro/graph/net_stream_18.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>同理其余队伍的胜利分配可以用边表示出来.</p>
<p><img src="/Blog/intro/graph/net_stream_19.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>然而我们希望没有队伍的胜利场次大于底特律.</p>
<p>也就是说纽约队最多只能胜利1场, Baltimore最多获得5场胜利, 波士顿对最多应7场, 多伦多最多获得13场胜利</p>
<p><img src="/Blog/intro/graph/net_stream_20.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>我们看这个网络的最大流是多少. 如果这个网络流的最大流是27的话, 就说明对于这27场比赛, 可以分配27场胜利给0-3 Team, 使得它们的胜场比底特律队小.</p>
<p>反之就说明无法分配, 也就是说底特律肯定赢不了.</p>
<p><br></p>
<blockquote>
<p>然而我有一个观点, 对于这个特定的问题</p>
<p><img src="/Blog/intro/graph/net_stream_20.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>2-3 这层其实是没有用的, 因为3层肯定能完整地接收2层传来的所有资源.</p>
<p>为什么不这样计算?</p>
<p>要分配27场胜利给4个队伍.(1-2)层</p>
<p>而4个队伍最多只能接收26场胜利(3-4)层 (如果不允许队伍的胜场大于76)</p>
<p>所以肯定无法分配.</p>
</blockquote>
<p>网络流是一个分配资源的模型.</p>
<p><br></p>
<p><br></p>
<h2 id="匹配问题"><a href="#匹配问题" class="headerlink" title="匹配问题"></a>匹配问题</h2><h3 id="最大匹配和完全匹配"><a href="#最大匹配和完全匹配" class="headerlink" title="最大匹配和完全匹配"></a>最大匹配和完全匹配</h3><p><img src="/Blog/intro/graph/match.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>这是一个<strong>无向图</strong>算法, 但解决问题的思路和有向图相关</p>
<p>同时这个图也是一个二分图</p>
<p>假设左边是男士, 右边是女士, 边代表男士与女士有成亲的可能,</p>
<p>那么对于这张图我们最多可以让多少张合适的新人成婚?</p>
<p><br></p>
<p>还有其他例子: 选导师</p>
<p><img src="/Blog/intro/graph/match_1.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>红色的边就是其中一种匹配方案, 且是最大匹配方案, 我们无法在这张图中找到4组匹配.</p>
<p>通常解决我们不去考虑匹配方案, 我们最关心的还是最大匹配的结果(数字). 因此找到一组最大匹配的方案就可以了</p>
<p><br></p>
<p>这张图有8个节点, 但最大匹配数只有3, 而不是4, 说明有顶点没有被匹配.</p>
<p>如果添加一条边 1-7</p>
<p><img src="/Blog/intro/graph/match_2.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>最大匹配就是4, 此时所有的点都被匹配了, 这就是完全匹配</p>
<p><br></p>
<blockquote>
<p>完全匹配一定是最大匹配</p>
<p>最大匹配不一定是完全匹配</p>
</blockquote>
<p>而我们看一张图有没有完全匹配就是先找到最大匹配, 如果所有点都被匹配了, 说明是完全匹配.</p>
<p>因此最大匹配和完全匹配的算法其实是一致的.</p>
<p><br></p>
<p><br></p>
<h3 id="使用最大流算法解决匹配问题"><a href="#使用最大流算法解决匹配问题" class="headerlink" title="使用最大流算法解决匹配问题"></a>使用最大流算法解决匹配问题</h3><p>最大流算法是分配资源的模型</p>
<p>那么对于匹配问题来说什么是资源? 资源就是节点, 或者说资源是边(点与点之间的联系)(或者说关系)</p>
<p><img src="/Blog/intro/graph/match_3.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p>我们设立源点汇点, 将二分图(二分图可以分为两个部分)的一部分连接源点, 一部分连接汇点</p>
<p><img src="/Blog/intro/graph/match_4.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>将无向边改为有向边, 让和源点连接的点指向和汇点连接的点</p>
<blockquote>
<p> 将无向图问题转化成有向图问题. </p>
</blockquote>
<p><img src="/Blog/intro/graph/match_5.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>我们让(“<strong>关系</strong>“这个资源)从s流向t. 而每条边的<strong>容量只设为1</strong>.也就是说每个点的资源只能流向另外一个点.</p>
<p>换句话说, 一个点只能和另一个点有<strong>关系</strong>.</p>
<p>这样这幅图的最大流就是最大匹配数</p>
<p><br></p>
<h4 id="算法实现-1"><a href="#算法实现-1" class="headerlink" title="算法实现"></a><a target="_blank" rel="noopener" href="https://github.com/DaoLinZhou/GrapyTheory/blob/master/src/match/BipartiteMatching.java">算法实现</a></h4><p><br></p>
<h4 id="leetcode-例题"><a href="#leetcode-例题" class="headerlink" title="leetcode 例题"></a>leetcode 例题</h4><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/broken-board-dominoes/">https://leetcode-cn.com/problems/broken-board-dominoes/</a></p>
<p>这道题中, 同样要分析一下什么是资源. 一个格子可以和它上下左右4个方向的相邻格子建立联系. 这就是资源, 我们要分配格子间的联系.</p>
<p><img src="/Blog/intro/graph/match_6.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>换句话说, 一个白色的格子可以和它周围4个黑色的各自建立联系.</p>
<p>如果进行分配, 那么就是让资源从源点s流入白色格子, 再流入它周围的4个黑色格子. 再流入汇点t.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br>    <span class="hljs-type">int</span>[][] d = &#123;&#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;, &#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;&#125;;<br>    <span class="hljs-type">int</span> n, m;<br>    Set&lt;Integer&gt; brokenBlocks;<br>    WeightedGraph g;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">domino</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span>[][] broken)</span> &#123;<br>        <span class="hljs-built_in">this</span>.n = n;<br>        <span class="hljs-built_in">this</span>.m = m;<br>        brokenBlocks = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        g = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeightedGraph</span>(n*m+<span class="hljs-number">2</span>, <span class="hljs-literal">false</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> n*m;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> n*m + <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span>[] block : broken)&#123;<br>            brokenBlocks.add(getIndex(block[<span class="hljs-number">0</span>], block[<span class="hljs-number">1</span>]));<br>        &#125;<br><br>        <span class="hljs-comment">// 建图</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; m; j++)&#123;<br>                <span class="hljs-keyword">if</span>(!isNotBroken(i, j) || (i+j)%<span class="hljs-number">2</span> != <span class="hljs-number">0</span>)<br>                    <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-comment">// 把白色格子和周围黑色的格子连接</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] direction : d) &#123;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> i + direction[<span class="hljs-number">0</span>];<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> j + direction[<span class="hljs-number">1</span>];<br>                    <span class="hljs-keyword">if</span> (inArea(x, y) &amp;&amp; isNotBroken(x, y)) &#123;<br>                        g.addEdge(getIndex(i, j), getIndex(x, y), <span class="hljs-number">1</span>);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">BipartiteMatching</span> <span class="hljs-variable">bm</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BipartiteMatching</span>(g);<br>        <span class="hljs-keyword">return</span> bm.maxMatching();<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isNotBroken</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span>&#123;<br>        <span class="hljs-keyword">return</span> !brokenBlocks.contains(getIndex(x, y));<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getIndex</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span>&#123;<br>        <span class="hljs-keyword">return</span> x*m + y;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">inArea</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span>&#123;<br>        <span class="hljs-keyword">return</span> x &gt;= <span class="hljs-number">0</span> &amp;&amp; x &lt; n &amp;&amp; y &gt;= <span class="hljs-number">0</span> &amp;&amp; y &lt; m;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><br></p>
<p>然而这么实现需要导入很多自己写类.</p>
<p>如果对最大流算法熟悉的话, 可以直接在broken这个数组的基础上直接写一个最大流算法而不建图. // TODO</p>
<p><br></p>
<p><br></p>
<h3 id="匈牙利算法"><a href="#匈牙利算法" class="headerlink" title="匈牙利算法"></a>匈牙利算法</h3><p>使用最大流算法求解最大匹配并不是求解匹配问题的唯一算法</p>
<p>匈牙利算法不借助有向图, 也不借助网络流模型, 看可不可以直接通过这个无向图解决问题.</p>
<p><img src="/Blog/intro/graph/match_3.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>毕竟通过这个无向图搭建出来的网络流模型本身就是一个特殊的网络流模型(每条边的容量只为1)</p>
<p>匈牙利算法就是看看能否直接在这个图上选边</p>
<p><br></p>
<h4 id="匈牙利算法的流程"><a href="#匈牙利算法的流程" class="headerlink" title="匈牙利算法的流程"></a>匈牙利算法的流程</h4><p>匈牙利算法就是从左边还没有匹配的点出发, 看能不能添加新的匹配</p>
<p><img src="/Blog/intro/graph/match_3.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>关键是怎么寻找当前图是否有新的匹配</p>
<p>先从0出发, 从0直接到4, 4也是一个没有匹配的点, 两个没有匹配的点相连, 他们肯定可以是一组匹配, 将他们匹配上, 标记为蓝色</p>
<p><img src="/Blog/intro/graph/match_7.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>看左边没匹配的点, 从1出发到达4, 而4是右侧已经匹配的点. 对于右侧已经匹配的点, 我们寻找新的匹配的过程就是在找一个路径, 此时我们不遍历4的所有相邻顶点, 而是直接走到和4匹配的这个点0</p>
<p><img src="/Blog/intro/graph/match_8.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>对于左边这个点, 我们可以寻找和它相邻的任意一个顶点(没有遍历过), 和0相邻的顶点中4已经被遍历过了, 而6还没有被遍历过, 所以来到6. 而6是一个未匹配的点. 此时匹配就结束了</p>
<p><img src="/Blog/intro/graph/match_9.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p>我们找到的是这样一个路径</p>
<p><img src="/Blog/intro/graph/match_10.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>这个路径的特点是: 首尾都是没有被匹配的点.而中间的点是匹配的点. 且这两个点存在匹配边. 而收尾两个顶点是非匹配的顶点, 所以1-4, 0-6这两条边一定是非匹配的边</p>
<p>此时我们断开4-0之间的边, 转而连接1-4, 0-6这两条边, 同时1, 6两个点也设置为匹配</p>
<p>这样就相当于让原来只有一个匹配变成有两个匹配</p>
<p><img src="/Blog/intro/graph/match_11.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p>下面从点2出发再按照刚才的原则, 寻找一个路径.</p>
<p>从2找到6, 而6是一个已经匹配了的顶点. 对于匹配的顶点转到和它对应的匹配点. 于是来到顶点0</p>
<p><img src="/Blog/intro/graph/match_12.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>下面遍历0的所有相邻顶点, 对于0的相邻顶点, 6已经遍历过了, 而4还没有遍历过. 于是来到4. 而4又是一个已经匹配过的顶点, 对于已经匹配的顶点来到它对应的匹配点. 于是来到顶点1. 对于1 遍历它的相邻顶点, 4已经遍历过了, 7是一个未遍历的点. 于是来到7</p>
<p>而7是一个未匹配的点, 至此寻找路径结束了.</p>
<p>  <img src="/Blog/intro/graph/match_13.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>此时找到的路径是</p>
<p><img src="/Blog/intro/graph/match_14.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>依然是起始顶点和结尾顶点都是<strong>未匹配</strong>的顶点. 中间4个顶点是两两配对形成匹配边的</p>
<p>此时五条边的关系为 : 01010 (0 代表 未匹配, 1 代表匹配). 我们要把它变为: 10101, 这样就增加了一条边</p>
<p>之后把这条路径的收尾两个顶点标为匹配</p>
<p><br></p>
<p><img src="/Blog/intro/graph/match_15.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>这里增广路径的概念和网络流中的增广路径不一样</p>
<p>有增广路径, 意味着最大匹配数可以加一</p>
<p><br></p>
<p><img src="/Blog/intro/graph/match_16.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>最后从3找到7, 然而无法沿着这条路径找到一个未匹配的结尾点. 所以找不到<strong>增广路径</strong>. 无法通过这条路径让整张图的匹配数加一.</p>
<p><img src="/Blog/intro/graph/match_16.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>此时从3寻找其他路径, 3匹配5.</p>
<p><br></p>
<p>至此左边再没有节点, 匹配算法结束. 这就是匈牙利算法</p>
<p>从左侧一个尚未匹配的点出发, 不断寻找<strong>可以增广的交替路</strong></p>
<p>如何找这样一个增广路径?</p>
<p>BFS, 或者 DFS.</p>
<p>然而右侧的点不需要寻路. 如果右侧的点是未匹配的点, 算法结束, 如果是已经匹配的点, 则直接跳到它对应的匹配点.</p>
<p><br></p>
<p><br></p>
<p>匈牙利算法复杂度初始遍历所有点, 对左侧所有点进行广度优先遍历$V*(V+E) = O(VE)$ 连通图V&lt;E</p>
<p><br></p>
<h4 id="BFS-匈牙利算法实现"><a href="#BFS-匈牙利算法实现" class="headerlink" title="BFS 匈牙利算法实现"></a><a target="_blank" rel="noopener" href="https://github.com/DaoLinZhou/GrapyTheory/blob/master/src/match/HungarianBFS.java">BFS 匈牙利算法实现</a></h4><h4 id="DFS-匈牙利算法实现"><a href="#DFS-匈牙利算法实现" class="headerlink" title="DFS 匈牙利算法实现"></a><a target="_blank" rel="noopener" href="https://github.com/DaoLinZhou/GrapyTheory/blob/master/src/match/HungarianDFS.java">DFS 匈牙利算法实现</a></h4>
            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/Blog/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">算法与数据结构</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/Blog/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/Blog/2020/09/08/Computing-System/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">计算机底层</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/Blog/2020/08/02/skip-list/">
                        <span class="hidden-mobile">跳跃表</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/Blog/js/events.js" ></script>
<script  src="/Blog/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/Blog/js/local-search.js" ></script>



  
    <script  src="/Blog/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
        typing(title);
      
    })(window, document);
  </script>





  

  
    <!-- MathJax -->
    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']]
        },
        loader: {
          load: ['ui/lazy']
        },
        options: {
          renderActions: {
            findScript: [10, doc => {
              document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
                const display = !!node.type.match(/; *mode=display/);
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
                const text = document.createTextNode('');
                node.parentNode.replaceChild(text, node);
                math.start = { node: text, delim: '', n: 0 };
                math.end = { node: text, delim: '', n: 0 };
                doc.math.push(math);
              });
            }, '', false],
            insertedScript: [200, () => {
              document.querySelectorAll('mjx-container').forEach(node => {
                let target = node.parentNode;
                if (target.nodeName.toLowerCase() === 'li') {
                  target.parentNode.classList.add('has-jax');
                }
              });
            }, '', false]
          }
        }
      };
    </script>

    <script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js" ></script>

  











<!-- 主题的启动项 保持在最底部 -->
<script  src="/Blog/js/boot.js" ></script>


</body>
</html>
