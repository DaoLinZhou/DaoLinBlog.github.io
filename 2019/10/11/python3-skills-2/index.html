

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/Blog/img/favicon.ico">
  <link rel="icon" href="/Blog/img/favicon.ico">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Daolin">
  <meta name="keywords" content="">
  
    <meta name="description" content="文件I&#x2F;O相关读写文本文件1234# t这里代表以文本文件格式, python会在内部自动进行编解码# 默认情况下就是这个模式, 所有不写t也行f &#x3D; open(&quot;a.txt&quot;, &quot;wt&quot;, encoding&#x3D;&amp;#x27;gbk&amp;#x27;)f.write(&amp;#x27;我爱python&amp;#x27;) 这也是为什么python3 不用手动进行编解码的原因 同时">
<meta property="og:type" content="article">
<meta property="og:title" content="python3编程技巧(二)">
<meta property="og:url" content="https://daolinzhou.github.io/Blog/2019/10/11/python3-skills-2/">
<meta property="og:site_name" content="Daolin&#39;s Repository">
<meta property="og:description" content="文件I&#x2F;O相关读写文本文件1234# t这里代表以文本文件格式, python会在内部自动进行编解码# 默认情况下就是这个模式, 所有不写t也行f &#x3D; open(&quot;a.txt&quot;, &quot;wt&quot;, encoding&#x3D;&amp;#x27;gbk&amp;#x27;)f.write(&amp;#x27;我爱python&amp;#x27;) 这也是为什么python3 不用手动进行编解码的原因 同时">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/wavformat.png">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/pythonIO.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/useage.PNG">
<meta property="article:published_time" content="2019-10-12T02:52:23.000Z">
<meta property="article:modified_time" content="2019-11-29T04:24:59.690Z">
<meta property="article:author" content="Daolin">
<meta property="article:tag" content="python3">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://daolinzhou.github.io/Blog/intro/wavformat.png">
  
  
  <title>python3编程技巧(二) - Daolin&#39;s Repository</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/Blog/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"daolinzhou.github.io","root":"/Blog/","version":"1.8.14","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/Blog/local-search.xml"};
  </script>
  <script  src="/Blog/js/utils.js" ></script>
  <script  src="/Blog/js/color-schema.js" ></script>
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.1.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/Blog/">
      <strong>Daolin&#39;s Repo</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/Blog/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/Blog/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/Blog/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/Blog/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/Blog/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/Blog/intro/eye.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="python3编程技巧(二)">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2019-10-11 19:52" pubdate>
        2019年10月11日 晚上
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      15k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      124 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">python3编程技巧(二)</h1>
            
            <div class="markdown-body">
              <link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><h1 id="文件I-O相关"><a href="#文件I-O相关" class="headerlink" title="文件I/O相关"></a>文件I/O相关</h1><h2 id="读写文本文件"><a href="#读写文本文件" class="headerlink" title="读写文本文件"></a>读写文本文件</h2><figure class="highlight python"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># t这里代表以文本文件格式, python会在内部自动进行编解码</span><br><span class="hljs-comment"># 默认情况下就是这个模式, 所有不写t也行</span><br>f = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;a.txt&quot;</span>, <span class="hljs-string">&quot;wt&quot;</span>, encoding=<span class="hljs-string">&#x27;gbk&#x27;</span>)<br>f.write(<span class="hljs-string">&#x27;我爱python&#x27;</span>)<br></code></pre></td></tr></table></figure>
<p>这也是为什么python3 不用手动进行编解码的原因</p>
<p>同时python3 的字符串默认就是unicode字符串, 同样不用向python2那样在字符串前面加u</p>
<p><br></p>
<h2 id="处理二进制文件-wav举例"><a href="#处理二进制文件-wav举例" class="headerlink" title="处理二进制文件(wav举例)"></a>处理二进制文件(wav举例)</h2><p>这里以处理wav音频文件为例</p>
<p><img src="/Blog/intro/wavformat.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> struct<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br><span class="hljs-comment"># 获取subchunk == name的位置和subchunk的size</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">find_subchunk</span>(<span class="hljs-params">f, name</span>):<br>    <span class="hljs-comment"># 如图所示, 前12位是我们不需要的</span><br>    f.seek(<span class="hljs-number">12</span>)<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        <span class="hljs-comment"># 读取subchunk的id和size</span><br>        chunk_name = f.read(<span class="hljs-number">4</span>)<br>        <br>        <span class="hljs-comment"># 使用struct的unpack把二进制转换为int</span><br>        <span class="hljs-comment"># 因为int是4个字节, 而如图chunk的size也是4个字节</span><br>        chunk_size, = struct.unpack(<span class="hljs-string">&#x27;i&#x27;</span>, f.read(<span class="hljs-number">4</span>))<br><br>        <span class="hljs-keyword">if</span> chunk_name == name:<br>            <span class="hljs-comment"># 返回当前位置, 和size</span><br>            <span class="hljs-keyword">return</span> f.tell(), chunk_size<br><br>        <span class="hljs-comment"># 0 代表从头, 1 代表当前点, 2 代表文件结尾</span><br>        <span class="hljs-comment"># 从当前位置开始定位, 定位到下一个subchunk的位置</span><br>        f.seek(chunk_size, <span class="hljs-number">1</span>)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br><br>    <span class="hljs-comment"># b 表示二进制</span><br>    f = <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;test.wav&#x27;</span>, <span class="hljs-string">&#x27;rb&#x27;</span>)<br><br>    <span class="hljs-comment"># 获取data的信息的位置和大小</span><br>    offset, size = find_subchunk(f, <span class="hljs-string">b&#x27;data&#x27;</span>)<br>	<br>    <span class="hljs-comment"># 使用numpy创建缓冲</span><br>    buf = np.zeros(size//<span class="hljs-number">2</span>, dtype=np.short)<br><br>    <span class="hljs-comment"># 把所有信息读到buffer</span><br>    f.readinto(buf)<br>    <br>    <span class="hljs-comment"># 对buf中, 所有元素进行/=16</span><br>    <span class="hljs-comment"># 具体的表现则是声音变小</span><br>    buf //= <span class="hljs-number">16</span><br><br>    <span class="hljs-comment"># 新建文件</span><br>    f2 = <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;out.wav&#x27;</span>, <span class="hljs-string">&#x27;wb&#x27;</span>)<br>    <br>    <span class="hljs-comment"># 重新定位到开头</span><br>    f.seek(<span class="hljs-number">0</span>)<br><br>    <span class="hljs-comment"># 先把前面的信息副职过去</span><br>    info = f.read(offset)<br>    f2.write(info)<br>    <span class="hljs-comment"># 把处理好的data写入f2</span><br>    buf.tofile(f2)<br><br>    f2.close()<br>    f.close()<br><br>    <span class="hljs-comment"># 二进制模式下返回bytes, 而不是str</span><br>    <span class="hljs-comment"># info = f.read(100)</span><br>    <span class="hljs-comment"># print(info)</span><br></code></pre></td></tr></table></figure>
<p>得到的新的wav文件的声音就比原本的声音小</p>
<p><br></p>
<h2 id="如何设置文件缓冲"><a href="#如何设置文件缓冲" class="headerlink" title="如何设置文件缓冲"></a>如何设置文件缓冲</h2><p>将文件写入到硬件设备时, 使用系统调用, 这类I/O操作的时间很长, 为了减少IO操作的次数, 文件通常使用缓冲区(就是等有足够多的数据之后才进行系统调用). 文件的缓冲行为分为: <strong>全缓冲, 行缓冲, 无缓冲</strong></p>
<p><br></p>
<p><strong>全缓冲</strong>: </p>
<p>缓冲区的大小是固定的, 当缓冲区满了后会进行<strong>系统调用</strong>(system call), 通过系统调用把内存中的内容写到硬盘中</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看a.bin尾部的内容</span><br><span class="hljs-built_in">tail</span> -f a.bin<br></code></pre></td></tr></table></figure>
<p>监听a.bin这个文件的变化</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">f = <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;a.bin&#x27;</span>, <span class="hljs-string">&#x27;wb&#x27;</span>)<br>f.write(<span class="hljs-string">b&#x27;abcefg&#x27;</span>)<br></code></pre></td></tr></table></figure>
<p>然而此时tail并没有显示任何信息, 说明abcefg并没有真实的写入磁盘, 而是进入缓冲区当中, 且没有填满缓冲区</p>
<p>缓冲区的大小是多大呢? 这个和磁盘相关.</p>
<p>如果在驱动信息中找不到, 则会使用 io.DEFAULT_BUFFER_SIZE, 即8192</p>
<p>这里假设缓冲区为4096</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">f.write(<span class="hljs-string">b&#x27;+&#x27;</span>*<span class="hljs-number">4090</span>) <span class="hljs-comment"># 之前已经写了6个字节, 在写4090个</span><br></code></pre></td></tr></table></figure>
<p>依然没有任何信息, 但是如果</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">f.write(<span class="hljs-string">b&#x27;-&#x27;</span>)<br></code></pre></td></tr></table></figure>
<p>此时就会写入到文件中, 也就是说如果写入的字节超过缓冲区范围就会往文件中进行写入</p>
<p>而无缓冲就是把缓冲区设为0, 让缓冲区无法容纳任何东西, 使得每个字节都要写入文件</p>
<p><strong><em>注意</em></strong>上面的操作都是使用<strong>二进制</strong>进行读取的</p>
<p><br></p>
<p>如果我们使用字符流进行读取却有些不一样</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">f2 = <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;a.txt&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>)<br>f2.write(<span class="hljs-string">&#x27;abc&#x27;</span>*<span class="hljs-number">5000</span>)<br></code></pre></td></tr></table></figure>
<p>文件依然没有被写入</p>
<p>原因如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(f))  <span class="hljs-comment"># &lt;class &#x27;_io.BufferedWriter&#x27;&gt;</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(f2)) <span class="hljs-comment"># &lt;class &#x27;_io.TextIOWrapper&#x27;&gt;</span><br><br><span class="hljs-built_in">print</span>(f2.buffer) <br><span class="hljs-comment"># &lt;_io.BufferedWriter name=&#x27;E:\\py_WorkSpace\\PySkills\\read_write_file\\a.txt&#x27;&gt;</span><br><br><span class="hljs-comment"># 就变成以二进制打开文件了, 这说明文本模式打开是基于二进制打开的</span><br></code></pre></td></tr></table></figure>
<p><strong>三层模型</strong></p>
<p><img src="/Blog/intro/pythonIO.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>如图所示,  TextIOWrapper是基于BufferedWriter实现的, </p>
<p>BufferedWriter是处理二进制用的, 而TextIO是处理文本文件用的, 可以看出TextIO的主要作用是进行编解码.</p>
<p>在BufferedWriter之下是raw, raw是无缓冲直接写入</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 层次在上面的总是可以调用底层的方法</span><br><span class="hljs-comment"># 这么做就是跳过缓冲区, 直接写入</span><br>f.buffer.raw.write(<span class="hljs-string">b&#x27;b&#x27;</span>)<br></code></pre></td></tr></table></figure>
<p><br></p>
<p>而TextIO也有缓冲, 说明是两级缓冲, 而我们之前写5000 个依然没有反应说明是没有填满缓冲, 根据测试, 这一级的缓冲区的大小为8192</p>
<p><br></p>
<p><strong>行缓冲</strong></p>
<p>行缓冲就是遇到换行(\n)就进行写入, 它也有size, 如果没有遇到换行但是size满了也进行写入</p>
<p>linux的终端就是<strong>行缓冲</strong>文件</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">tty		<span class="hljs-comment"># 查看终端对应的文件</span><br></code></pre></td></tr></table></figure>
<p>会返回一个文件的path</p>
<p>这个文件不是普通的文件, 它在linux中叫做char设备</p>
<p>而我们直接对这个文件进行写入,  默认情况下这种tty设备就是<strong>行缓冲</strong></p>
<p><strong><em>注意</em></strong> 行缓冲只能对文本模式生效, 而不是二进制</p>
<p><br></p>
<p><strong>手动指定缓冲区大小</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">f = <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;test.txt&#x27;</span>, <span class="hljs-string">&#x27;wb&#x27;</span>, buffering=<span class="hljs-number">8192</span>)<br></code></pre></td></tr></table></figure>
<p><strong>注意</strong>: 文本模式有两级缓冲, 文本模式下指定的缓冲是buffered那级, 而不是最上面那一层的</p>
<p>无缓冲就是把buffering设为0</p>
<p>行缓冲则是在文本模式下(因为行缓冲只对文本模式有用), 把buffering设为1</p>
<p>如果大于1则将其设置为缓冲区的大小</p>
<p><br></p>
<h2 id="如何将文件映射到内存"><a href="#如何将文件映射到内存" class="headerlink" title="如何将文件映射到内存"></a>如何将文件映射到内存</h2><p><br></p>
<p><strong>实际用途:</strong></p>
<ol>
<li><p>在访问某些二进制文件时, 希望能把文件映射到内存中, 可以实现随机访问 (例如linux中的 framebuffer 设备文件)</p>
</li>
<li><p>某些嵌入式设备, 寄存器被编址到内存地址空间, 我们可以映射 /dev/mem 某范围, 去访问这些寄存器</p>
</li>
<li>如果多个进程映射同一个文件, 还能实现进程通信的目的</li>
</ol>
<p><br></p>
<p>linux的 framebuffer 是对整个屏幕显示的抽象, 屏幕的显示是由像素点构成的, 每个像素点可能由4个字节表示颜色rgba, 而这个framebuffer就是1920 <em> 1080 </em> 4 这么大的文件, 对这个文件进行读写就可以修改屏幕的显示. 对于这种文件通过数组进行访问会比read/write方便很多</p>
<p><br></p>
<p><strong>解决方案:</strong></p>
<p>使用标准库中mmap.mmap() 函数, 将文件映射到进程的内存地址</p>
<p><br></p>
<p>创建一个大小为1兆, 内容全0的二进制文件</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-built_in">dd</span>命令用于读取、转换并输出数据</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">/dev/zero 是一个特殊文件, 它里面内容全0</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">指定每块的大小为1024(bs), 一共有1024个块(count)</span><br>dd if=/dev/zero of=demo.bin bs=1024 count=1024<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">-x 代表以16进制</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">以16进制的方式查看二进制文件demo.bin</span><br>od -x demo.bin<br></code></pre></td></tr></table></figure>
<p><br></p>
<p>使用例子</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> mmap<br><br>f = <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;demo.bin&#x27;</span>, <span class="hljs-string">&#x27;r+b&#x27;</span>)<br><span class="hljs-comment"># 0 代表把整个文件都映射进内存</span><br>m = mmap.mmap(f.fileno(), <span class="hljs-number">0</span>)<br><br><span class="hljs-comment"># 普通的write方式写入</span><br>m.write(<span class="hljs-string">b&#x27;abc&#x27;</span>)<br><br><span class="hljs-comment"># 用数组的随机访问进行写入</span><br>m[<span class="hljs-number">5</span>] = <span class="hljs-number">78</span><br>m[<span class="hljs-number">8</span>:<span class="hljs-number">16</span>] = <span class="hljs-string">b&#x27;\xff&#x27;</span> * <span class="hljs-number">8</span><br></code></pre></td></tr></table></figure>
<p>centos中 /dev/fb0 就是对屏幕的抽象, 而我们要通过映射更改屏幕的显示</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> mmap<br><br>f = <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;/dev/fb0&#x27;</span>, <span class="hljs-string">&#x27;r+b&#x27;</span>)<br>size = <span class="hljs-number">8294400</span><br><span class="hljs-comment"># 第一个参数要传入文件描述符,而不是file对象 ,这是系统底层的要求</span><br>m = mmap.mmap(f.fileno(), size)<br><br><span class="hljs-comment"># 给一半的屏幕写入白色, \xff就是255, \x00就是0, rgba中, rgb都为255, a为0</span><br>m[:size//<span class="hljs-number">2</span>] = <span class="hljs-string">b&#x27;\xff\xff\xff\x00&#x27;</span> * (size // <span class="hljs-number">4</span> // <span class="hljs-number">2</span>)<br><br>m.close()<br>f.close()<br></code></pre></td></tr></table></figure>
<p><br></p>
<h2 id="访问文件的状态"><a href="#访问文件的状态" class="headerlink" title="访问文件的状态"></a>访问文件的状态</h2><p>系统调用: 标准库<strong>os</strong>模块中的系统调用<strong>stat</strong>获取文件状态</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><br>fd = os.<span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;a.txt&#x27;</span>, os.O_RDONLY) <span class="hljs-comment"># 获取文件描述符, 就是一个数字</span><br>s = os.stat(<span class="hljs-string">&#x27;a.txt&#x27;</span>) 	<span class="hljs-comment"># 传入路径</span><br>os.stat(fd)			<span class="hljs-comment"># 传入文件描述符</span><br><br><span class="hljs-comment"># 文件表述符是给系统调用使用的</span><br>os.read(fd, <span class="hljs-number">10</span>)		<span class="hljs-comment"># 系统调用, 读取10个字节</span><br></code></pre></td></tr></table></figure>
<p><br></p>
<p>快捷函数:标准库os.path下的一些函数</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-built_in">os</span>.<span class="hljs-built_in">path</span>.isdir(<span class="hljs-string">&#x27;test&#x27;</span>)<br><br><span class="hljs-built_in">os</span>.<span class="hljs-built_in">path</span>.isfile(<span class="hljs-string">&#x27;a.txt&#x27;</span>)<br><br><span class="hljs-built_in">os</span>.<span class="hljs-built_in">path</span>.getsize(<span class="hljs-string">&#x27;a.txt&#x27;</span>)<br></code></pre></td></tr></table></figure>
<p><br></p>
<h2 id="如何使用临时文件"><a href="#如何使用临时文件" class="headerlink" title="如何使用临时文件"></a>如何使用临时文件</h2><p>例如: 某项目中, 我们每采集数据1G数据就对它做分析, 最终只保留分析结果. 而这样大量的临时数据如果常驻内存会消耗大量资源. 所以我们可以使用临时文件存储这些临时数据 ( 外部存储 ).</p>
<p>临时文件不用命名, 且关闭后会自动删除</p>
<p><br></p>
<p>解决方案 : 使用标准库中的 <strong>TemporaryFile</strong> 以及 <strong>NamedTemporaryFile</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> tempfile <span class="hljs-keyword">import</span> TemporaryFile, NamedTemporaryFile<br><br><span class="hljs-comment"># 指定目录创建临时文件, 因为默认目录的大小可能会不够用</span><br><span class="hljs-comment"># 操作系统级别的临时文件, 系统调用的open打开的</span><br>tf = TemporaryFile(<span class="hljs-built_in">dir</span>=<span class="hljs-string">&#x27;/&#x27;</span>)<br>tf.write(<span class="hljs-string">b&#x27;*&#x27;</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>)<br>tf.write(<span class="hljs-string">b&#x27;*&#x27;</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>)<br>tf.write(<span class="hljs-string">b&#x27;*&#x27;</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>)<br>tf.write(<span class="hljs-string">b&#x27;*&#x27;</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>)<br><br><span class="hljs-comment"># 用法和普通文件一样,</span><br><span class="hljs-comment"># 但我们无法在文件系统中访问到它 例如:ls</span><br>tf.seek(<span class="hljs-number">0</span>)<br>tf.read(<span class="hljs-number">512</span>)<br><br><span class="hljs-comment"># 自动删除这个文件</span><br>tf.close()<br><br><span class="hljs-comment">#######################################</span><br><br><span class="hljs-comment"># 能创建出带名字的临时文件</span><br><span class="hljs-comment"># 不是系统级别,</span><br><span class="hljs-comment"># 无论创建临时文件的名字还是自动帮你删除这个文件</span><br><span class="hljs-comment"># 都是由python库实现的, 而不是由操作系统实现</span><br><span class="hljs-comment"># 多进程都想访问统一个临时文件时可以使用</span><br>ntf = NamedTemporaryFile()<br><br><span class="hljs-comment"># 存储的位置</span><br>ntf.name()<br><br><span class="hljs-comment"># 当构造器delete为True时(默认)会自动删除文件, 可以修改为False来不删除</span><br>ntf.close()<br></code></pre></td></tr></table></figure>
<p><br></p>
<h1 id="类与对象相关"><a href="#类与对象相关" class="headerlink" title="类与对象相关"></a>类与对象相关</h1><h2 id="如何派生内置不可变类型并修改其实例化行为"><a href="#如何派生内置不可变类型并修改其实例化行为" class="headerlink" title="如何派生内置不可变类型并修改其实例化行为"></a>如何派生内置不可变类型并修改其实例化行为</h2><p>例如: 自定义一种新类型的元组, 对于传入的可迭代对象, 我们只保留其中int类型且值大于0的元素</p>
<p>先尝试这样实现</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">IntTuple</span>(<span class="hljs-title class_ inherited__">tuple</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, iterable</span>):<br>        <span class="hljs-comment"># 过滤iterable</span><br>        f_it = (e <span class="hljs-keyword">for</span> e <span class="hljs-keyword">in</span> iterable <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(e, <span class="hljs-built_in">int</span>) <span class="hljs-keyword">and</span> e &gt; <span class="hljs-number">0</span>)<br>        <span class="hljs-built_in">super</span>(IntTuple, self).__init__(f_it)<br></code></pre></td></tr></table></figure>
<p>但是运行时会发现出现问题,  因为父类object的init方法没有参数</p>
<p>也就是说很有可能tuple没有实现init方法</p>
<p><br></p>
<p>如果打印self则会发现元组已经存在, 那么这个self到底是谁来创建的?</p>
<p><br></p>
<p>通常我们把一个类的init方法成为这个类的构造器, 但这实际上是不准确的, 我们在创建一个类的实例时, 实际上会调用两个方法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__new__</span>(<span class="hljs-params">cls, *args</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;In A.__new__&quot;</span>, cls, args)<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">object</span>.__new__(cls)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, *args</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;In A.__init__&quot;</span>, args)<br>        <br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-comment"># a1 = A(1, 2)</span><br>    a = A.__new__(A, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br>    A.__init__(a, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure>
<p>其实在python中所有类的实例都是由object的new方法创建的, 如果不实现new, 调用的依然是父类object的new方法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># list的初始化</span><br>l = <span class="hljs-built_in">list</span>.__new__(<span class="hljs-built_in">list</span>)<br><span class="hljs-built_in">list</span>.__init__(l, <span class="hljs-string">&#x27;abc&#x27;</span>)<br><br><span class="hljs-comment"># tuple的初始化</span><br>t = <span class="hljs-built_in">tuple</span>.__new__(<span class="hljs-built_in">tuple</span>, <span class="hljs-string">&quot;abc&quot;</span>)<br><span class="hljs-comment"># new 之后元组就初始化完成了, tuple根本就没实现init</span><br><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">tuple</span>.__init <span class="hljs-keyword">is</span> <span class="hljs-built_in">object</span>.__init__)  <span class="hljs-comment"># True</span><br></code></pre></td></tr></table></figure>
<p>对于特殊情况(例如: tuple) 我们可以在new的时候直接初始化好</p>
<p>因此我们可以这么实现</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">IntTuple</span>(<span class="hljs-title class_ inherited__">tuple</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__new__</span>(<span class="hljs-params">cls, iterable</span>):<br>        <span class="hljs-comment"># 过滤iterable</span><br>        f_it = (e <span class="hljs-keyword">for</span> e <span class="hljs-keyword">in</span> iterable <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(e, <span class="hljs-built_in">int</span>) <span class="hljs-keyword">and</span> e &gt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>().__new__(cls, f_it)<br>    <br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    t = IntTuple([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;e&#x27;</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">9</span>, [<span class="hljs-string">&#x27;x&#x27;</span>, <span class="hljs-string">&#x27;y&#x27;</span>], <span class="hljs-number">3</span>])<br>    <span class="hljs-built_in">print</span>(t)<br></code></pre></td></tr></table></figure>
<p><br></p>
<h2 id="如何为创建大量实例节省内存"><a href="#如何为创建大量实例节省内存" class="headerlink" title="如何为创建大量实例节省内存"></a>如何为创建大量实例节省内存</h2><p>定义类的slots内置属性, 声明实例有哪些属性 (关闭动态绑定)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Player1</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, uid, name, level</span>):<br>        self.uid = uid<br>        self.name = name<br>        self.level = level<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Player2</span>:<br>    __slots__ = [<span class="hljs-string">&#x27;uid&#x27;</span>, <span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;level&#x27;</span>]<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, uid, name, level</span>):<br>        self.uid = uid<br>        self.name = name<br>        self.level = level<br></code></pre></td></tr></table></figure>
<p>上面两个类中, Player2实例使用的空间会更小</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    p1 = Player1(<span class="hljs-string">&#x27;0001&#x27;</span>, <span class="hljs-string">&#x27;Jim&#x27;</span>, <span class="hljs-number">20</span>)<br>    p2 = Player2(<span class="hljs-string">&#x27;0001&#x27;</span>, <span class="hljs-string">&#x27;Jim&#x27;</span>, <span class="hljs-number">20</span>)<br><br>    <span class="hljs-comment"># 查看一下 p1 比 p2 多出哪些东西</span><br>    <span class="hljs-comment"># dir(p1) 会以列表的形式打印p1的所有属性</span><br>    <span class="hljs-comment"># 对两个集合作差就可以得出我们要的结果</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">set</span>(<span class="hljs-built_in">dir</span>(p1)) - <span class="hljs-built_in">set</span>(<span class="hljs-built_in">dir</span>(p2)))<br>    <span class="hljs-comment"># &#123;&#x27;__weakref__&#x27;, &#x27;__dict__&#x27;&#125;</span><br>	<span class="hljs-comment"># p1 比 p2 多了两个属性, __weakref__ 和 __dict__</span><br></code></pre></td></tr></table></figure>
<p>weakref 是弱引用, 在这里它的开销并不大. 主要占用内存的是dict</p>
<p>p1中的三个属性都是动态创建的</p>
<p>而实例内部就是通过dict来维护动态绑定的属性</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 等价语句</span><br>p1.z = <span class="hljs-number">300</span><br>p1.__dict__[<span class="hljs-string">&#x27;z&#x27;</span>] = <span class="hljs-number">300</span><br><br><span class="hljs-comment"># 删除属性</span><br>p1.__dict__.pop(<span class="hljs-string">&#x27;x&#x27;</span>)<br></code></pre></td></tr></table></figure>
<p><br></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sys<br><br><span class="hljs-comment"># 这个函数可以查看内置类型占用多少空间</span><br>res = sys.getsizeof(p1.__dict__)<br><span class="hljs-built_in">print</span>(res)<br><br>res2 = sys.getsizeof(p1.name) + sys.getsizeof(p1.level) + sys.getsizeof(p1.uid)<br><span class="hljs-built_in">print</span>(res2)<br><br><span class="hljs-comment"># res1 和 res2 分别为 112, 133</span><br></code></pre></td></tr></table></figure>
<p>可以看出存储的数据是133个字节, 而维护他们的字典是112个字节, 近乎浪费一半的空间. </p>
<p>如果实例个数较少, 牺牲些空间换取动态绑定属性的特性还是值得的. 但如果实例的个数非常多, 就会造成非常大的浪费</p>
<p>而关闭动态添加数据就是用 slots 提前声明号实例中能有哪些属性, 提前分配好空间</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-comment"># tracemalloc 用于跟踪内存使用</span><br><br>    <span class="hljs-comment"># start 启用跟踪</span><br>    tracemalloc.start()<br><br>    <span class="hljs-comment"># 要跟踪的代码</span><br>    la = [Player1(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100000</span>)]<br>    lb = [Player2(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100000</span>)]<br><br>    <span class="hljs-comment"># end 停止跟踪</span><br>    snapshot = tracemalloc.take_snapshot()<br><br>    <span class="hljs-comment"># 查看内存占用最多的语句位置</span><br>    top_stats = snapshot.statistics(<span class="hljs-string">&#x27;lineno&#x27;</span>)<br>    <span class="hljs-keyword">for</span> stat <span class="hljs-keyword">in</span> top_stats[:<span class="hljs-number">10</span>]:<br>        <span class="hljs-built_in">print</span>(stat)<br></code></pre></td></tr></table></figure>
<p><img src="/Blog/intro/useage.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>占用最多内存的是在Player1中第一次动态绑定时的语句</p>
<p>而两次列表解析的效率差不多.  由于Player2没有动态绑定, 所以没有绑定的消耗. </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-comment"># tracemalloc 用于跟踪内存使用</span><br><br>    <span class="hljs-comment"># start 启用跟踪</span><br>    tracemalloc.start()<br><br>    <span class="hljs-comment"># 要跟踪的代码, 下面两行每次只打开一个运行</span><br>    <span class="hljs-comment"># la = [Player1(1, 2, 3) for _ in range(100000)]</span><br>    <span class="hljs-comment"># lb = [Player2(1, 2, 3) for _ in range(100000)]</span><br><br>    <span class="hljs-comment"># end 停止跟踪</span><br>    snapshot = tracemalloc.take_snapshot()<br><br>    <span class="hljs-comment"># 查看整个文件的内存使用情况</span><br>    top_stats = snapshot.statistics(<span class="hljs-string">&#x27;filename&#x27;</span>)<br>    <span class="hljs-keyword">for</span> stat <span class="hljs-keyword">in</span> top_stats[:<span class="hljs-number">10</span>]:<br>        <span class="hljs-built_in">print</span>(stat)<br></code></pre></td></tr></table></figure>
<p>Player1 使用 16.8 M, Player2 使用 7056 K. 大大节省了内存</p>
<p><br></p>
<h2 id="如何让类支持with的自动开启和关闭-支持上下文管理"><a href="#如何让类支持with的自动开启和关闭-支持上下文管理" class="headerlink" title="如何让类支持with的自动开启和关闭 / 支持上下文管理"></a>如何让类支持with的自动开启和关闭 / 支持上下文管理</h2><p>这里是一个简易的Telnet客户端</p>
<blockquote>
<p>telnet是一种网络协议, 默认使用23端口, 和ssh类似但是是明文的, 不安全 所以默认不能使用root权限账号</p>
<p>如果想要连接远程服务器, 则服务器需要安装</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum -y install telnet-server.x86_64<br>yum -y install telnet.x86_64<br>yum -y install xinetd.x86_64<br><br>设置开机自启：<br>systemctl enable xinetd.service<br>systemctl enable telnet.socket<br><br>开启service：<br>systemctl start telnet.socket<br>systemctl start xinetd<br></code></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> getpass<br><span class="hljs-keyword">import</span> telnetlib<br><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> deque<br><span class="hljs-keyword">from</span> sys <span class="hljs-keyword">import</span> stdout, stdin<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TelnetClient</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, host, port=<span class="hljs-number">23</span></span>):<br>        self.host = host<br>        self.port = port<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">connect</span>(<span class="hljs-params">self</span>):<br>        self.tn = telnetlib.Telnet(self.host, self.port)<br>        self.history = deque([])<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">cleanup</span>(<span class="hljs-params">self</span>):<br>        self.tn.close()<br>        self.tn = <span class="hljs-literal">None</span><br><br>        <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;history.txt&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>            f.writelines(self.history)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">login</span>(<span class="hljs-params">self</span>):<br>        self.tn.read_until(<span class="hljs-string">b&#x27;login: &#x27;</span>)<br>        user = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;Enter your remote account: &quot;</span>)<br>        self.tn.write(user.encode(<span class="hljs-string">&#x27;utf8&#x27;</span>) + <span class="hljs-string">b&quot;\n&quot;</span>)<br><br>        self.tn.read_until(<span class="hljs-string">b&#x27;Password: &#x27;</span>)<br>        password = getpass.getpass()<br>        self.tn.write(password.encode(<span class="hljs-string">&#x27;utf8&#x27;</span>) + <span class="hljs-string">b&quot;\n&quot;</span>)<br>        out = self.tn.read_until(<span class="hljs-string">b&#x27;$ &#x27;</span>)<br>        stdout.write(out.decode(<span class="hljs-string">&#x27;utf8&#x27;</span>))<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">interact</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>            cmd = stdin.readline()<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> cmd:<br>                <span class="hljs-keyword">break</span><br>            self.history.append(cmd)<br>            self.tn.write(cmd.encode(<span class="hljs-string">&#x27;utf8&#x27;</span>))<br>            out = self.tn.read_until(<span class="hljs-string">b&#x27;$ &#x27;</span>).decode(<span class="hljs-string">&#x27;utf8&#x27;</span>)<br><br>            stdout.write(out[<span class="hljs-built_in">len</span>(cmd)+<span class="hljs-number">1</span>:])<br>            stdout.flush()<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    client = TelnetClient(<span class="hljs-string">&#x27;服务器ip&#x27;</span>)<br>    client.connect()<br>    client.login()<br>    client.interact()<br>    client.cleanup()<br></code></pre></td></tr></table></figure>
<p>这里可以看到从创建client到使用它, 再到关闭一共要五行代码(main中)</p>
<p>而我们的目标是让这个类支持with自动打开和关闭(即支持上下文管理)</p>
<p><br></p>
<p>举个with的简单例子</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;test.txt&quot;</span>, <span class="hljs-string">&#x27;w&#x27;</span>) <span class="hljs-keyword">as</span> f:<br></code></pre></td></tr></table></figure>
<p>注意: 这里并不是把open的返回值直接给f, 这里等同于下面语句</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">F = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;test.txt&quot;</span>, <span class="hljs-string">&#x27;w&#x27;</span>)<br><span class="hljs-keyword">with</span> F <span class="hljs-keyword">as</span> f:<br></code></pre></td></tr></table></figure>
<p>而 f 则是通过 F 的内置enter方法得到的</p>
<p>由于 F 的 enter 方法返回的是 self 所以 f 就是 F, 但这取决于enter的实现</p>
<p>而退出则会自动调用 F 的 exit 内置方法执行清理工作</p>
<p>因此我们只要把 connect 和 cleanup 分别改为 enter 和 exit</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">__enter__</span>(<span class="hljs-params">self</span>):<br>    self.tn = telnetlib.Telnet(self.host, self.port)<br>    self.history = deque([])<br>    <br>    <span class="hljs-comment"># 返回的值赋值给as后的变量</span><br>    <span class="hljs-keyword">return</span> self<br><br><span class="hljs-comment"># 如果执行出现异常, 同样会调用此方法, 三个参数都是异常的描述</span><br><span class="hljs-comment"># 如果正常退出, 则这三个参数都是None</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">__exit__</span>(<span class="hljs-params">self, exc_type, exc_val, exc_tb</span>):<br>    self.tn.close()<br>    self.tn = <span class="hljs-literal">None</span><br><br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;history.txt&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>        f.writelines(self.history)<br><br>    <span class="hljs-comment"># 返回真说明异常已经被处理完毕, 不再抛给上一层</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-keyword">with</span> TelnetClient(<span class="hljs-string">&#x27;服务器ip&#x27;</span>) <span class="hljs-keyword">as</span> client:<br>        client.login()<br>        client.interact()<br></code></pre></td></tr></table></figure>
<p><br></p>
<h2 id="创建可管理的对象属性"><a href="#创建可管理的对象属性" class="headerlink" title="创建可管理的对象属性"></a>创建可管理的对象属性</h2><p>通常我们在面向对象的编程中, 不建议直接对属性进行操作, 而是应该实用Getter和Setter来操作</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> math<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, radius</span>):<br>        self.radius = radius<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_radius</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> self.radius<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">set_radius</span>(<span class="hljs-params">self, radius</span>):<br>        self.radius = radius<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_area</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> self.radius ** <span class="hljs-number">2</span> * math.pi<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">set_area</span>(<span class="hljs-params">self, S</span>):<br>        self.radius = math.sqrt(S / math.pi)<br>        <br>c = Circle(<span class="hljs-number">1111</span>)<br>c.set_radius(<span class="hljs-number">32.95</span>)<br></code></pre></td></tr></table></figure>
<p>而在python中可以使用property函数为类创建可管理属性, 传入的参数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, radius</span>):<br>        self.radius = radius<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_radius</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;get R&quot;</span>)<br>        <span class="hljs-keyword">return</span> self.radius<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">set_radius</span>(<span class="hljs-params">self, radius</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;set R&quot;</span>)<br>        self.radius = radius<br><br>    <span class="hljs-comment"># 使用方法2</span><br>    <span class="hljs-comment"># 可以通过c.S来读取, 必须要和方法名一样</span><br><span class="hljs-meta">    @property</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">S</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> self.radius ** <span class="hljs-number">2</span> * math.pi<br><br>    <span class="hljs-comment"># 可以通过c.S = xxx 来访问</span><br>    <span class="hljs-comment"># S指的就是上面那个方法的名字</span><br><span class="hljs-meta">    @S.setter</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">S</span>(<span class="hljs-params">self, s</span>):<br>        self.radius = math.sqrt(s / math.pi)<br><br>    <span class="hljs-comment"># 使用方法1</span><br>    <span class="hljs-comment"># 虽然这里R是一个类属性, 但我们对R进行操作时</span><br>    <span class="hljs-comment"># 调用的是操作radius的方法, 因此一个类属性就可以</span><br>    R = <span class="hljs-built_in">property</span>(get_radius, set_radius)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    c = Circle(<span class="hljs-number">5.712</span>)<br>    c.R = <span class="hljs-number">31.89</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;this is print &quot;</span>, c.R)<br>    <span class="hljs-comment"># 设置S后R的值改变了</span><br>    c.S = <span class="hljs-number">99.88</span><br>    <span class="hljs-built_in">print</span>(c.S)<br>    <span class="hljs-built_in">print</span>(c.R)<br></code></pre></td></tr></table></figure>
<p><br></p>
<h2 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h2><p>python中运算符实际上是调用的类中的内置函数</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">运算符</th>
<th style="text-align:center">函数</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">==</td>
<td style="text-align:center">eq</td>
</tr>
<tr>
<td style="text-align:center">!=</td>
<td style="text-align:center">ne</td>
</tr>
<tr>
<td style="text-align:center">&lt;</td>
<td style="text-align:center">lt</td>
</tr>
<tr>
<td style="text-align:center">&gt;</td>
<td style="text-align:center">gt</td>
</tr>
<tr>
<td style="text-align:center">&lt;=</td>
<td style="text-align:center">le</td>
</tr>
<tr>
<td style="text-align:center">&gt;=</td>
<td style="text-align:center">ge</td>
</tr>
</tbody>
</table>
</div>
<p><br></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> total_ordering<br><br><span class="hljs-comment"># 使用total_ordering, 运算符只要重载两个就行</span><br><span class="hljs-comment"># 一个是__eq__, 之后再随便重载一个就行 lt, le, gt, ge</span><br><span class="hljs-comment"># 其余的它会自动帮你实现</span><br><span class="hljs-meta">@total_ordering</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rect</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, w, h</span>):<br>        self.w = w<br>        self.h = h<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">area</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> self.w * self.h<br><br>    <span class="hljs-comment"># 相当于java中的toString</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__str__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Rect:(%s, %s)&#x27;</span> % (self.w, self.h)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__eq__</span>(<span class="hljs-params">self, other</span>):<br>        <span class="hljs-keyword">return</span> self.area() == other.area()<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__le__</span>(<span class="hljs-params">self, other</span>):<br>        <span class="hljs-keyword">return</span> self.area() &lt;= other.area()<br><br><br>rect1 = Rect(<span class="hljs-number">6</span>, <span class="hljs-number">9</span>)<br>rect2 = Rect(<span class="hljs-number">7</span>, <span class="hljs-number">8</span>)<br><span class="hljs-built_in">print</span>(rect1 &lt; rect2)<br><span class="hljs-built_in">print</span>(rect1 &gt; rect2)  <span class="hljs-comment"># 由于我们没有重载对于方法, 会被翻译成 rect2 &lt; rect1</span><br></code></pre></td></tr></table></figure>
<p><br></p>
<p>更进一步, 可以让父类实现这些比较方法, 子类之间就可以互相比较了</p>
<p><br></p>
<h2 id="使用描述符对实例属性作类型检查"><a href="#使用描述符对实例属性作类型检查" class="headerlink" title="使用描述符对实例属性作类型检查"></a>使用描述符对实例属性作类型检查</h2><p>对属性进行类型检查的方法有很多种, 例如在getter&amp;setter中进行检查, 这里主要讲述什么是描述符, 以及如何用它检查类型 </p>
<p><br></p>
<p>当一个类包含set, get, delete内置函数其中之一, 那它就是描述符</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Attr</span>:<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, key, _<span class="hljs-built_in">type</span></span>):<br>        self.key = key<br>        self._<span class="hljs-built_in">type</span> = _<span class="hljs-built_in">type</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__set__</span>(<span class="hljs-params">self, instance, value</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;in __set__&#x27;</span>)<br>        <span class="hljs-comment"># set时判断属性类型</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">isinstance</span>(value, self._<span class="hljs-built_in">type</span>):<br>            <span class="hljs-keyword">raise</span> TypeError(<span class="hljs-string">&#x27;must be %s&#x27;</span> % self._<span class="hljs-built_in">type</span>)<br>        instance.__dict__[self.key] = value<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__get__</span>(<span class="hljs-params">self, instance, cls</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;in __get__&#x27;</span>, instance, cls)<br>        <span class="hljs-keyword">return</span> instance.__dict__[self.key]<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__delete__</span>(<span class="hljs-params">self, instance</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;in __del__&#x27;</span>, instance)<br>        <span class="hljs-keyword">del</span> instance.__dict__[self.key]<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>:<br>    <span class="hljs-comment"># 对这些属性的访问都会被描述符所捕获</span><br>    name = Attr(<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-built_in">str</span>)<br>    age = Attr(<span class="hljs-string">&#x27;age&#x27;</span>, <span class="hljs-built_in">int</span>)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    p = Person()<br>    p.name = <span class="hljs-string">&#x27;daolin&#x27;</span><br>    p.age = <span class="hljs-number">33</span><br></code></pre></td></tr></table></figure>
<p><br></p>
<h2 id="如何在环状数据结构中管理内存"><a href="#如何在环状数据结构中管理内存" class="headerlink" title="如何在环状数据结构中管理内存"></a>如何在环状数据结构中管理内存</h2><p><br></p>
<p>python中的垃圾回收机制</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__del__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;in __del__&#x27;</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>	<span class="hljs-comment"># 引用计数为2    </span><br>    a = A()<br>    a2 = a<br>    <br>    a2 = <span class="hljs-literal">None</span><br>    a = <span class="hljs-number">1</span><br>    <span class="hljs-comment"># 当一个对象的引用数量为 0 时, 就会被自动回收</span><br></code></pre></td></tr></table></figure>
<p><br></p>
<p>然而当出现循环引用时</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 双向链表</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, data</span>):<br>        self.data = data<br>        self.left = <span class="hljs-literal">None</span><br>        self.right = <span class="hljs-literal">None</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">add_right</span>(<span class="hljs-params">self, node</span>):<br>        self.right = node<br>        node.left = self<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__str__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Node:&lt;%s&gt;&#x27;</span> % self.data<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__del__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;in __del__: delete %s&#x27;</span> % self)<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">create_linklist</span>(<span class="hljs-params">n</span>):<br>    head = current = Node(<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>, n+<span class="hljs-number">1</span>):<br>        node = Node(i)<br>        current.add_right(node)<br>        current = node<br>    <span class="hljs-keyword">return</span> head<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    head = create_linklist(<span class="hljs-number">1000</span>)<br>    <span class="hljs-comment"># 引用计数依然大于0, 对于不会执行del</span><br>    head = <span class="hljs-literal">None</span><br><br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1000</span>):<br>        time.sleep(<span class="hljs-number">1</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;run...&#x27;</span>)<br>    <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;wait...&#x27;</span>)<br></code></pre></td></tr></table></figure>
<p><br></p>
<p>而解决方法就是使用弱引用, weakref.ref(), 弱引用不会计算在引用计数里. </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> weakref<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, data</span>):<br>        self.data = data<br>        self._left: Node = <span class="hljs-literal">None</span><br>        self.right: Node = <span class="hljs-literal">None</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">add_right</span>(<span class="hljs-params">self, node</span>):<br>        self.right = node<br>        <span class="hljs-comment"># 把左节点改为弱引用, 所有的元素引用计数就都为1了</span><br>        node._left = weakref.ref(self)<br><br>    <span class="hljs-comment"># 左节点通过self._left()获取引用</span><br>    <span class="hljs-comment"># 右节点通过self.right获取引用</span><br>    <span class="hljs-comment"># 为了对称, 根据上面学过的知识, 通过property让他们使用方法一样</span><br><span class="hljs-meta">    @property</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">left</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-comment"># 弱引用通过()返回真正的引用</span><br>        <span class="hljs-keyword">return</span> self._left()<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__str__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Node:&lt;%s&gt;&#x27;</span> % self.data<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__del__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;in __del__: delete %s&#x27;</span> % self)<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">create_linklist</span>(<span class="hljs-params">n</span>):<br>    head = current = Node(<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>, n+<span class="hljs-number">1</span>):<br>        node = Node(i)<br>        current.add_right(node)<br>        current = node<br>    <span class="hljs-keyword">return</span> head<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    head = create_linklist(<span class="hljs-number">1000</span>)<br>    <span class="hljs-built_in">print</span>(head.right, head.right.left)<br>    head = <span class="hljs-literal">None</span><br></code></pre></td></tr></table></figure>
<p><br></p>
<h2 id="如何通过方法名调用类的方法"><a href="#如何通过方法名调用类的方法" class="headerlink" title="如何通过方法名调用类的方法"></a>如何通过方法名调用类的方法</h2><p>有两种方式:</p>
<ol>
<li>通过getattr获取方法对象, 之后调用</li>
<li>通过标准库operator下的methodcaller调用</li>
</ol>
<p>这两种方法有什么不同</p>
<p><br></p>
<p>getattr:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">s = <span class="hljs-string">&#x27;123abc987&#x27;</span><br><span class="hljs-comment"># 获取s的find方法对象, 如果没有这个方法则赋值为None(第三个参数)</span><br>method = <span class="hljs-built_in">getattr</span>(s, <span class="hljs-string">&#x27;find&#x27;</span>, <span class="hljs-literal">None</span>)<br><span class="hljs-comment"># 传参调用, 从index为3的位置寻找abc</span><br>method(<span class="hljs-string">&#x27;abc&#x27;</span>, <span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure>
<p><br></p>
<p>methodcaller</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">s = <span class="hljs-string">&#x27;123abc987&#x27;</span><br>method = <span class="hljs-string">&#x27;find&#x27;</span><br><span class="hljs-comment"># 先告诉它要调用那个方法, 以及传参</span><br>caller = methodcaller(method, <span class="hljs-number">3</span>)<br><span class="hljs-comment"># 之后才传入调用的对象, 通常要判断一下这个对象中是否有这个方法</span><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">hasattr</span>(s, method):<br>	caller(s)<br></code></pre></td></tr></table></figure>
<p><br></p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/Blog/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/Blog/tags/python3/">python3</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/Blog/2019/10/20/git-common-command/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">git学习笔记</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/Blog/2019/09/27/python3-skills-1/">
                        <span class="hidden-mobile">python3编程技巧(一)</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/Blog/js/events.js" ></script>
<script  src="/Blog/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/Blog/js/local-search.js" ></script>



  
    <script  src="/Blog/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
        typing(title);
      
    })(window, document);
  </script>





  

  
    <!-- MathJax -->
    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']]
        },
        loader: {
          load: ['ui/lazy']
        },
        options: {
          renderActions: {
            findScript: [10, doc => {
              document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
                const display = !!node.type.match(/; *mode=display/);
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
                const text = document.createTextNode('');
                node.parentNode.replaceChild(text, node);
                math.start = { node: text, delim: '', n: 0 };
                math.end = { node: text, delim: '', n: 0 };
                doc.math.push(math);
              });
            }, '', false],
            insertedScript: [200, () => {
              document.querySelectorAll('mjx-container').forEach(node => {
                let target = node.parentNode;
                if (target.nodeName.toLowerCase() === 'li') {
                  target.parentNode.classList.add('has-jax');
                }
              });
            }, '', false]
          }
        }
      };
    </script>

    <script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js" ></script>

  











<!-- 主题的启动项 保持在最底部 -->
<script  src="/Blog/js/boot.js" ></script>


</body>
</html>
