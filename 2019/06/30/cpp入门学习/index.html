

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/Blog/img/favicon.ico">
  <link rel="icon" href="/Blog/img/favicon.ico">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Daolin">
  <meta name="keywords" content="">
  
    <meta name="description" content="C++入门学习包含C++ 基础知识 [TOC]">
<meta property="og:type" content="article">
<meta property="og:title" content="C++入门学习">
<meta property="og:url" content="https://daolinzhou.github.io/Blog/2019/06/30/cpp%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/">
<meta property="og:site_name" content="Daolin&#39;s Repository">
<meta property="og:description" content="C++入门学习包含C++ 基础知识 [TOC]">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/datastructure.png">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/bool.png">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/init.png">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/cIo.png">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/cppio.png">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/namespace.png">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/beforeconst.png">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/const.png">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/constpointer.png">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/constp.png">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/const2p.png">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/const&amp;.png">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/function.png">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/memory.png">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/string.png">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/stringaction.png">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/memory-1557777502848.png">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/obejct.png">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/deletefunction.png">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/objectArray.png">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/copyfunction-1558048558423.png">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/copy.png">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/copypointer.png">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/deepcopy.png">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/deepcopyfunction.png">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/coordinateclass.png">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/example.png">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/sizeofpointer.png">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/thispointer.png">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/constfunction.png">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/whyconstfunction.png">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/thisconst.png">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/protectedextend.png">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/privateextend.png">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/public.png">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/protectextent.png">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/privateextent.png">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/hide.png">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/hide_example.png">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/use_hide.png">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/hide_attr.png">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/use_hide_attr.png">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/virtualextend.png">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/functionpointer.png">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/virtualtable.png">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/circlevirtualtable.png">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/circlenewvirtualtable.png">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/shapeVirtual.png">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/circlevirtual.png">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/purevirtual.png">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/1558983908939.png">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/1558989615257.png">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/1559090043720.png">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/1559090460855.png">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/1559249707992.png">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/1559250494410.png">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/1559287703066.png">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/1559287911981.png">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/1559288051741.png">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/1559342959015.png">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/1559409756258.png">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/1559410471994.png">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/1559411923797.png">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/1559413773666.png">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/1559417380744.png">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/1559421288091.png">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/1559421660209.png">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/1559421726463.png">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/1559507167140.png">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/1559507362989.png">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/1559509776738.png">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/1559510118344.png">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/1560654681063.png">
<meta property="article:published_time" content="2019-07-01T03:15:20.000Z">
<meta property="article:modified_time" content="2019-09-20T19:14:03.524Z">
<meta property="article:author" content="Daolin">
<meta property="article:tag" content="c++">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://daolinzhou.github.io/Blog/intro/datastructure.png">
  
  
  <title>C++入门学习 - Daolin&#39;s Repository</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/Blog/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"daolinzhou.github.io","root":"/Blog/","version":"1.8.14","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/Blog/local-search.xml"};
  </script>
  <script  src="/Blog/js/utils.js" ></script>
  <script  src="/Blog/js/color-schema.js" ></script>
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.1.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/Blog/">
      <strong>Daolin&#39;s Repo</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/Blog/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/Blog/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/Blog/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/Blog/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/Blog/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/Blog/intro/eye.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="C++入门学习">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2019-06-30 20:15" pubdate>
        2019年6月30日 晚上
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      26k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      219 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">C++入门学习</h1>
            
            <div class="markdown-body">
              <link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><h1 id="C-入门学习"><a href="#C-入门学习" class="headerlink" title="C++入门学习"></a>C++入门学习</h1><p>包含C++ 基础知识</p>
<p>[TOC]</p>
<span id="more"></span>
<h2 id="c-基本知识"><a href="#c-基本知识" class="headerlink" title="c++基本知识"></a>c++基本知识</h2><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p><img src="/Blog/intro/datastructure.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>c++中新的数据类型</p>
<p><img src="/Blog/intro/bool.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<h3 id="初始化方法"><a href="#初始化方法" class="headerlink" title="初始化方法"></a>初始化方法</h3><p><img src="/Blog/intro/init.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<h3 id="随用随定义"><a href="#随用随定义" class="headerlink" title="随用随定义"></a>随用随定义</h3><p>​    C语言:    所有变量定义必须位于函数体的最前面</p>
<p>​    C++   :    所有变量随用随定义</p>
<p><br></p>
<h3 id="c-的输入输出方式"><a href="#c-的输入输出方式" class="headerlink" title="c++的输入输出方式"></a>c++的输入输出方式</h3><p>​    <img src="/Blog/intro/cIo.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/cppio.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<h4 id="c-的IO方式"><a href="#c-的IO方式" class="headerlink" title="c++的IO方式"></a>c++的IO方式</h4><p><br></p>
<h5 id="cout-的语法形式"><a href="#cout-的语法形式" class="headerlink" title="cout 的语法形式"></a>cout 的语法形式</h5><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//正确写法</span><br>cout &lt;&lt; x &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;x+y = &quot;</span> &lt;&lt; x+y &lt;&lt;endl;<br><br><span class="hljs-comment">//错误写法</span><br>cout &lt;&lt; x,y,z &lt;&lt; endl;<br></code></pre></td></tr></table></figure>
<p>​    <br></p>
<h5 id="cin-的语法形式"><a href="#cin-的语法形式" class="headerlink" title="cin 的语法形式"></a>cin 的语法形式</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">cin &gt;&gt; x;<br>cin &gt;&gt; x &gt;&gt; y;<br></code></pre></td></tr></table></figure>
<p><br></p>
<h4 id="c-IO方式的优势"><a href="#c-IO方式的优势" class="headerlink" title="c++ IO方式的优势"></a>c++ IO方式的优势</h4><p>​    不用关注占位符</p>
<p>​    不用关注数据类型</p>
<p>​    <strong>不容易出现问题</strong></p>
<p><br></p>
<p>练习:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;  <br><br><span class="hljs-comment">//要求: 提示用户输入一个整数, 将该整数以8, 10, 16进制打印在屏幕上</span><br><span class="hljs-comment">//要求: 提示用户输入一个布尔值, 并将其打印到屏幕上</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>   <span class="hljs-type">int</span> x = <span class="hljs-number">0</span>;<br>   cout &lt;&lt; <span class="hljs-string">&quot;please type number&quot;</span> &lt;&lt; endl;<br>   cin &gt;&gt; x;<br>   cout &lt;&lt; oct &lt;&lt; x &lt;&lt; endl;<br>   cout &lt;&lt; dec &lt;&lt; x &lt;&lt; endl;<br>   cout &lt;&lt; hex &lt;&lt; x &lt;&lt; endl;<br><br>   cout &lt;&lt; <span class="hljs-string">&quot;please type bool (0 or 1)&quot;</span> &lt;&lt; endl;<br>   <span class="hljs-type">bool</span> y = <span class="hljs-literal">false</span>;<br>   cin &gt;&gt; y;<br>   cout &lt;&lt; boolalpha &lt;&lt; y &lt;&lt; endl;<br>   <br>   <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><br></p>
<h3 id="C-的命名空间-namespace"><a href="#C-的命名空间-namespace" class="headerlink" title="C++的命名空间 namespace"></a>C++的命名空间 namespace</h3><p><img src="/Blog/intro/namespace.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p>命名空间关键字:    <strong>namespace</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">namespace</span> A<br>&#123;<br>    <span class="hljs-type">int</span> x = <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f1</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f2</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><span class="hljs-keyword">namespace</span> B<br>&#123;<br>    <span class="hljs-type">int</span> x = <span class="hljs-number">2</span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f1</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f3</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><br></p>
<p>c公司使用A的 x 变量 及 B的 f1() 函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">cout&lt;&lt; A::x &lt;&lt;endl;<br>B::<span class="hljs-built_in">f1</span>();<br></code></pre></td></tr></table></figure>
<p><br></p>
<p>例子</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-comment">//using namespace std;  </span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    std::cout&lt;&lt; <span class="hljs-string">&quot;hello world&quot;</span> &lt;&lt;std::endl;<br>    <span class="hljs-comment">//cout&lt;&lt; &quot;hello world&quot;&quot;&lt;&lt;endl;</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>如果使用命名空间std, 则不需要用 std::cout 的方式, 而是直接用cout</p>
<p><br></p>
<p>例2</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;  <br><br><span class="hljs-keyword">namespace</span> A&#123;<br>    <span class="hljs-type">int</span> x = <span class="hljs-number">1</span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span></span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;A&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">namespace</span> B&#123;<br>    <span class="hljs-type">int</span> x = <span class="hljs-number">2</span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span></span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;B&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cout &lt;&lt; A::x &lt;&lt; endl;<br>    B::<span class="hljs-built_in">fun</span>();<br>&#125;<br></code></pre></td></tr></table></figure>
<p><br></p>
<h3 id="C-语言引用"><a href="#C-语言引用" class="headerlink" title="C++语言引用"></a>C++语言引用</h3><p><br></p>
<h4 id="基本数据类型的引用"><a href="#基本数据类型的引用" class="headerlink" title="基本数据类型的引用"></a>基本数据类型的引用</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">3</span>;<br>    <span class="hljs-type">int</span> &amp;b = a;		<span class="hljs-comment">// 引用必须初始化</span><br>    <br>    b = <span class="hljs-number">10</span>;<br>    cout &lt;&lt; a &lt;&lt; endl;		<span class="hljs-comment">// 打印10</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br></code></pre></td></tr></table></figure>
<p><br></p>
<h4 id="结构体类型的引用"><a href="#结构体类型的引用" class="headerlink" title="结构体类型的引用"></a>结构体类型的引用</h4><p>结构体 : </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span><br>&#123;<br>    <span class="hljs-type">int</span> x;<br>    <span class="hljs-type">int</span> y;<br>&#125;Coor;<br></code></pre></td></tr></table></figure>
<p>使用 : </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>    Coor c1;<br>    Coor &amp;c = c1;<br>	c.x = <span class="hljs-number">10</span>;<br>    c.y = <span class="hljs-number">20</span>;<br>    <br>    cout &lt;&lt; c1.x &lt;&lt; c1.y;	<span class="hljs-comment">//打印 10, 20</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p><br></p>
<h4 id="指针类型的引用"><a href="#指针类型的引用" class="headerlink" title="指针类型的引用"></a>指针类型的引用</h4><p>语法:</p>
<p>​    <strong>类型 *&amp;指针引用名 = 指针;</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>	<span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br>    <span class="hljs-type">int</span> *p = &amp;a;<br>    <span class="hljs-type">int</span> *&amp;q = p;	<span class="hljs-comment">//指针类型的引用</span><br>    *q = <span class="hljs-number">20</span>;<br>    <br>    cout &lt;&lt; a &lt;&lt; endl;		<span class="hljs-comment">//打印20</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><br></p>
<h4 id="引用作为函数参数"><a href="#引用作为函数参数" class="headerlink" title="引用作为函数参数"></a>引用作为函数参数</h4><p>c语言中    调换两个数的函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//声明</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">fun</span><span class="hljs-params">(<span class="hljs-type">int</span> *a, <span class="hljs-type">int</span> *b)</span>&#123;<br>    <span class="hljs-type">int</span> c = <span class="hljs-number">0</span>;<br>    c = *a;<br>    *a = *b;<br>    *b = c;<br>&#125;<br><span class="hljs-comment">//调用</span><br><span class="hljs-type">int</span> x=<span class="hljs-number">10</span>, y=<span class="hljs-number">20</span>;<br>fun(&amp;x, &amp;y);<br></code></pre></td></tr></table></figure>
<p><br></p>
<p>c++语言中    调换两个数的函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//声明</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;a, <span class="hljs-type">int</span> &amp;b)</span></span>&#123;<br>    cout &lt;&lt; &amp;a &lt;&lt; endl;<br>    <span class="hljs-type">int</span> c = <span class="hljs-number">0</span>;<br>    c = a;<br>    a = b;<br>    b = c;<br>&#125;<br><span class="hljs-comment">//调用</span><br><span class="hljs-type">int</span> x=<span class="hljs-number">10</span>, y=<span class="hljs-number">20</span>;<br>cout &lt;&lt; &amp;x &lt;&lt; endl;<br><span class="hljs-built_in">fun</span>(x, y);<br><br><span class="hljs-comment">// 两句打印语句的结果一样, 引用的内存地址和对象的内存地址一样, 所以才能改变原本的值</span><br></code></pre></td></tr></table></figure>
<p><br></p>
<h3 id="控制变化的-Const关键字"><a href="#控制变化的-Const关键字" class="headerlink" title="控制变化的 Const关键字"></a>控制变化的 Const关键字</h3><p><strong>没有const以前</strong></p>
<p><img src="/Blog/intro/beforeconst.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><strong>const</strong> 声明的常量无法更改</p>
<p><img src="/Blog/intro/const.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<h4 id="const与指针类型"><a href="#const与指针类型" class="headerlink" title="const与指针类型"></a>const与指针类型</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> *p = <span class="hljs-literal">NULL</span>;<br><span class="hljs-type">int</span> <span class="hljs-type">const</span> *p = <span class="hljs-literal">NULL</span>;<br></code></pre></td></tr></table></figure>
<p>上面两条语句完全等价    const 修饰 *p</p>
<p>但下面这条语句却与上面两条有区别    const修饰p</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> * <span class="hljs-type">const</span> p = <span class="hljs-literal">NULL</span>;<br></code></pre></td></tr></table></figure>
<p><br></p>
<p>下面两种写法同样完全等价</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> * <span class="hljs-type">const</span> p = <span class="hljs-literal">NULL</span>;<br><span class="hljs-type">int</span> <span class="hljs-type">const</span> * <span class="hljs-type">const</span> p = <span class="hljs-literal">NULL</span>;<br></code></pre></td></tr></table></figure>
<p><br></p>
<h5 id="const-修饰的是-p"><a href="#const-修饰的是-p" class="headerlink" title="const 修饰的是*p"></a>const 修饰的是*p</h5><p>​                所以用 *p进行重新赋值是错误的</p>
<p>​                但是把p指向别处却是可以的</p>
<p><img src="/Blog/intro/constpointer.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<h5 id="const-修饰的是p"><a href="#const-修饰的是p" class="headerlink" title="const 修饰的是p"></a>const 修饰的是p</h5><p>​        所以p指向别处是错误的</p>
<p><img src="/Blog/intro/constp.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<h5 id="const-同时修饰-p-和-p"><a href="#const-同时修饰-p-和-p" class="headerlink" title="const 同时修饰 *p 和 p"></a>const 同时修饰 *p 和 p</h5><p><img src="/Blog/intro/const2p.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<h4 id="Const与引用"><a href="#Const与引用" class="headerlink" title="Const与引用"></a>Const与引用</h4><p>​    <img src="/Blog/intro/const&amp;.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> x = <span class="hljs-number">3</span>;	<span class="hljs-type">int</span> *y = &amp;x;	<span class="hljs-comment">//这种写法是错误的</span><br></code></pre></td></tr></table></figure>
<p>x 只有读权限, 而*y却有读和写的权限 由一个权限大的接收权限小的是存在风险的, 编译器会报错.</p>
<p><br></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> x = <span class="hljs-number">3</span>;	<span class="hljs-type">const</span> <span class="hljs-type">int</span> *y = &amp;x;		<span class="hljs-comment">//这种写法是正确的</span><br></code></pre></td></tr></table></figure>
<p>x 有读写权限, 而*y有读权限 由一个权限小的接收权限大的是可以的</p>
<p><br></p>
<h4 id="const-与-宏定义define"><a href="#const-与-宏定义define" class="headerlink" title="const 与 宏定义define"></a>const 与 宏定义define</h4><p>下面两行代码效果是一样的</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> X 3;	<span class="hljs-comment">// 宏定义, 编译器不会检查语法</span></span><br><br><span class="hljs-type">const</span> x = <span class="hljs-number">3</span>;	<span class="hljs-comment">// 有类型, 编译器会检查语法错误</span><br></code></pre></td></tr></table></figure>
<p><br></p>
<h3 id="typedef的用法"><a href="#typedef的用法" class="headerlink" title="typedef的用法"></a>typedef的用法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span>* a,b,c;	<span class="hljs-comment">//只有a是指针类型, b, c都是int型的, 但是我们希望同时声明abc为指针</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span>* pointer;	<span class="hljs-comment">//定义 int* 为pointer, 可以声明在函数外面, 也可以声明在函数里面</span><br><br>pointer a, b, c;	<span class="hljs-comment">// a, b, c都是int*类型了</span><br></code></pre></td></tr></table></figure>
<p><br></p>
<h3 id="函数返回引用"><a href="#函数返回引用" class="headerlink" title="函数返回引用"></a>函数返回引用</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span>&amp; <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-type">int</span>* p)</span></span>&#123;<br>	*p = <span class="hljs-number">7</span>;<br>	<span class="hljs-keyword">return</span> *p;			<span class="hljs-comment">// 返回的是容器, 而不是存在容器里的值</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-type">int</span> a = <span class="hljs-number">3</span>;<br>	<span class="hljs-type">int</span> b = <span class="hljs-built_in">foo</span>(&amp;a); 	<span class="hljs-comment">//foo(&amp;a) 返回*p, *p 是 a, 这里可以看做是把a这个容器的值赋值给b</span><br>    <span class="hljs-built_in">foo</span>(&amp;a) = <span class="hljs-number">6</span>;		<span class="hljs-comment">//foo(&amp;a) 返回a这个容器, 这里把这个容器赋值成6, 就是把a赋值成6</span><br>    					<span class="hljs-comment">//可以单纯地把foo(&amp;a)看做是一个变量</span><br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span>&amp; <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-type">int</span>* p)</span></span>&#123;<br>    *p = <span class="hljs-number">4</span>;<br>    <span class="hljs-type">int</span> q = *p;<br>    <span class="hljs-keyword">return</span> q;		<span class="hljs-comment">// 这里会返回q这个容器, 但是当退出时这块作用域内定义的变量会被消除, 所以会报错</span><br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span>&amp; <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-type">int</span>* p)</span></span>&#123;<br>    *p = <span class="hljs-number">4</span>;<br>    <span class="hljs-type">int</span>* q = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">9</span>);<br>    <span class="hljs-keyword">return</span> *q;		<span class="hljs-comment">// 这里会返回q所指向的内存块, 而这个内存块是在heap中, 不会因为退出函数而被删除</span><br>    				<span class="hljs-comment">// 所以这么写是正确的, 没有error</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p><br></p>
<h3 id="C-函数特性"><a href="#C-函数特性" class="headerlink" title="C++函数特性"></a>C++函数特性</h3><h4 id="函数默认值"><a href="#函数默认值" class="headerlink" title="函数默认值"></a>函数默认值</h4><h5 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h5><h6 id="有默认参数值的参数必须在参数列表的最右端"><a href="#有默认参数值的参数必须在参数列表的最右端" class="headerlink" title="有默认参数值的参数必须在参数列表的最右端"></a>有默认参数值的参数必须在参数列表的最右端</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j=<span class="hljs-number">5</span>, <span class="hljs-type">int</span> k=<span class="hljs-number">10</span>)</span></span>;	<span class="hljs-comment">//正确</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j=<span class="hljs-number">5</span>, <span class="hljs-type">int</span> k)</span></span>;	<span class="hljs-comment">//这种写法有问题, 不能只给中间参数添加默认值</span><br></code></pre></td></tr></table></figure>
<h6 id="声明时使用默认值-定义时不使用默认值"><a href="#声明时使用默认值-定义时不使用默认值" class="headerlink" title="声明时使用默认值, 定义时不使用默认值"></a>声明时使用默认值, 定义时不使用默认值</h6><p>如果在定义的时候同样添加默认值, 有些编译器会通过, 有些编译器不会通过</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j=<span class="hljs-number">5</span>, <span class="hljs-type">int</span> k=<span class="hljs-number">10</span>)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span> k)</span></span>&#123;<br>    cout &lt;&lt; i &lt;&lt; j &lt;&lt; k;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-comment">//无实参使用默认值, 有实参则覆盖默认值</span><br>    <span class="hljs-built_in">fun</span>(<span class="hljs-number">20</span>);<br>    <span class="hljs-built_in">fun</span>(<span class="hljs-number">20</span>, <span class="hljs-number">30</span>);<br>    <span class="hljs-built_in">fun</span>(<span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><br></p>
<h4 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h4><p>相同作用域下</p>
<p>​    用<strong>同一函数名</strong>定义的多个函数</p>
<p>​        多个函数之间 <strong>参数个数</strong> 或 <strong>参数类型</strong> 不同</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getMax</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> z)</span></span>&#123;<br>    <span class="hljs-comment">//todo</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">getMax</span><span class="hljs-params">(<span class="hljs-type">double</span> x, <span class="hljs-type">double</span> y)</span></span>&#123;<br>    <span class="hljs-comment">//todo</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p><br></p>
<h5 id="编译器如何识别重载函数"><a href="#编译器如何识别重载函数" class="headerlink" title="编译器如何识别重载函数"></a>编译器如何识别重载函数</h5><p>​    如果getMax的名称相同, 在编译好之后, 实际是采用 <strong>名称_参数</strong> 的形式形成了一个新的函数</p>
<p>​    以此来区分所谓的重名函数</p>
<p><strong><em>getMax_int_int_int</em></strong></p>
<p><strong><em>getMax_double_double</em></strong></p>
<p><br></p>
<h4 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h4><p><img src="/Blog/intro/function.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p>相当于节省了 步骤 2 和 4</p>
<p><br></p>
<h5 id="inline-关键字"><a href="#inline-关键字" class="headerlink" title="inline 关键字"></a>inline 关键字</h5><p>内联函数关键字: inline</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">max</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> a=<span class="hljs-number">10</span>, b=<span class="hljs-number">20</span>, m;<br>    m = <span class="hljs-built_in">max</span>(a, b);<br>    cout &lt;&lt; <span class="hljs-string">&quot;max: &quot;</span> &lt;&lt; m &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><br></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> a=<span class="hljs-number">10</span>, b=<span class="hljs-number">20</span>, m;<br>    <span class="hljs-type">int</span> x, y;<br>    <br>    <span class="hljs-comment">//下面这三行就是	m = max(a, b); 的展开</span><br>    x = a; y = b;<br>    <span class="hljs-keyword">if</span>( y &gt; x) x = y;<br>    m = x;			<br>    <br>    cout &lt;&lt; <span class="hljs-string">&quot;max: &quot;</span> &lt;&lt; m &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><br></p>
<h5 id="为什么不把所有的函数都设置成内联函数"><a href="#为什么不把所有的函数都设置成内联函数" class="headerlink" title="为什么不把所有的函数都设置成内联函数?"></a>为什么不把所有的函数都设置成内联函数?</h5><p><br></p>
<ul>
<li><p>内联编译是建议性的, 由编译器决定, 即使使用inline关键字, 也不一定进行内联编译</p>
</li>
<li><p>内联函数逻辑必须简单, 不能包含for while循环等复杂结构, 调用频繁的函数建议使用内联</p>
</li>
<li><p>递归函数无法使用内联方式</p>
</li>
</ul>
<p>  <br></p>
<h3 id="对象-别名-指针-作为参数"><a href="#对象-别名-指针-作为参数" class="headerlink" title="对象, 别名, 指针 作为参数"></a>对象, 别名, 指针 作为参数</h3><p><a target="_blank" rel="noopener" href="https://www.imooc.com/video/8714">https://www.imooc.com/video/8714</a></p>
<p><br></p>
<h3 id="C-内存管理"><a href="#C-内存管理" class="headerlink" title="C++内存管理"></a>C++内存管理</h3><p>内存的本质是什么     -&gt; 资源</p>
<p>谁掌管内存资源         -&gt; 操作系统</p>
<p>我们能做什么         -&gt; 申请/归还</p>
<p>​    <strong><em>申请/归还 内存资源就是内存管理</em></strong></p>
<p><br></p>
<h4 id="内存的申请与释放"><a href="#内存的申请与释放" class="headerlink" title="内存的申请与释放"></a>内存的申请与释放</h4><p><br></p>
<h5 id="new-和-delete"><a href="#new-和-delete" class="headerlink" title="new 和 delete"></a>new 和 delete</h5><p>申请内存     new</p>
<p>释放内存     delete</p>
<p><br></p>
<p>new 和 delete 是运算符 而不是函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> *p = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>;	<span class="hljs-comment">//申请内存</span><br><span class="hljs-comment">// int *p = new int(20);	申请内存, 同时赋值20</span><br><span class="hljs-keyword">delete</span> p;			<span class="hljs-comment">//释放内存 delete + 指针</span><br></code></pre></td></tr></table></figure>
<p><br></p>
<p>申请块内存, 也就是数组</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> *arr = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">10</span>];<br><span class="hljs-comment">//	delete arr;		只delete了arr中的第一个元素</span><br><span class="hljs-keyword">delete</span> []arr;<br></code></pre></td></tr></table></figure>
<p><br></p>
<h5 id="C语言-申请和释放内存"><a href="#C语言-申请和释放内存" class="headerlink" title="C语言 申请和释放内存"></a>C语言 申请和释放内存</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> *<span class="hljs-title function_">malloc</span><span class="hljs-params">(<span class="hljs-type">size_t</span> size)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">free</span><span class="hljs-params">(<span class="hljs-type">void</span> *memblock)</span>;<br></code></pre></td></tr></table></figure>
<p><br></p>
<ul>
<li>使用 new 来申请, 就要使用 delete 来释放, 如果用c语言的方式申请, 就要用C语言的方式释放</li>
</ul>
<p><br></p>
<h5 id="申请内存是否一定成功"><a href="#申请内存是否一定成功" class="headerlink" title="申请内存是否一定成功?"></a>申请内存是否一定成功?</h5><h6 id="申请内存注意事项"><a href="#申请内存注意事项" class="headerlink" title="申请内存注意事项"></a>申请内存注意事项</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> *p = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">1000</span>];<br><span class="hljs-keyword">if</span>(<span class="hljs-literal">NULL</span> == p)&#123;<br>    <span class="hljs-comment">//内存分配失败</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p><br></p>
<h6 id="释放内存主要事项"><a href="#释放内存主要事项" class="headerlink" title="释放内存主要事项"></a>释放内存主要事项</h6><p><img src="/Blog/intro/memory.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>delete 之后 要把p设置成NULL</p>
<p>如果不设置成空, 则 p 依然指向那块内存. 如果我们又一次delete p 则会出现重复回收, 计算机会出现异常.</p>
<p><br></p>
<h2 id="C-封装"><a href="#C-封装" class="headerlink" title="C++封装"></a>C++封装</h2><h3 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h3><p><br></p>
<h4 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h4><p>​    class    关键字</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span><br>&#123;<br>    <span class="hljs-comment">//数据成员(属性)</span><br>    <span class="hljs-type">char</span> name[<span class="hljs-number">20</span>];<br>	<span class="hljs-type">int</span> age;<br>    <span class="hljs-type">int</span> type;<br>    <br>    <span class="hljs-comment">//成员函数(方法)</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">speak</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>;<br>&#125;;	<span class="hljs-comment">//有分号</span><br></code></pre></td></tr></table></figure>
<h4 id="访问限定符"><a href="#访问限定符" class="headerlink" title="访问限定符"></a>访问限定符</h4><p>public      公有</p>
<p>protect    受保护的</p>
<p>private    私有</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TV</span><br>&#123;<br>    <span class="hljs-comment">//希望暴露</span><br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-type">char</span> name[<span class="hljs-number">20</span>];<br>    <span class="hljs-type">int</span> type;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">changeVol</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">power</span><span class="hljs-params">()</span></span>;<br>    <br>    <span class="hljs-comment">//希望隐藏</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> price;<br>    <span class="hljs-type">int</span> age;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p><br></p>
<h4 id="实例化对象"><a href="#实例化对象" class="headerlink" title="实例化对象"></a>实例化对象</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TV</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-type">char</span> name[<span class="hljs-number">20</span>];<br>    <span class="hljs-type">int</span> type;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">changeVol</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">power</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	TV tv;			<span class="hljs-comment">//从栈实例化对象</span><br>    TV tv[<span class="hljs-number">20</span>];		<span class="hljs-comment">//从栈实例化对象</span><br>    				<span class="hljs-comment">//系统会自动回收栈中对象的内存</span><br>    <br>    TV *p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TV</span>();	<span class="hljs-comment">//从堆中实例化对象</span><br>    TV *q = <span class="hljs-keyword">new</span> TV[<span class="hljs-number">20</span>]; <span class="hljs-comment">//从堆中实例化对象</span><br>    <span class="hljs-keyword">delete</span> p;			<span class="hljs-comment">//释放内存</span><br>    <span class="hljs-keyword">delete</span> []q;			<span class="hljs-comment">//释放内存</span><br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><br></p>
<h4 id="对象成员的访问"><a href="#对象成员的访问" class="headerlink" title="对象成员的访问"></a>对象成员的访问</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	TV tv;			<span class="hljs-comment">//从栈实例化对象, 用 &quot;.&quot; 来访问其属性和方法</span><br>    tv.type = <span class="hljs-number">0</span>;	<br>    tv.<span class="hljs-built_in">changeVol</span>();<br>    <br>    TV *p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TV</span>();	<span class="hljs-comment">//从堆中实例化对象, 用 &quot;-&gt;&quot; 来访问其属性和方法</span><br>    p -&gt; type = <span class="hljs-number">0</span>;<br>    p -&gt; <span class="hljs-built_in">changeVol</span>();<br>    <span class="hljs-keyword">delete</span> p;<br>    p = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><br></p>
<h3 id="String-类型"><a href="#String-类型" class="headerlink" title="String 类型"></a>String 类型</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    string name = <span class="hljs-string">&quot;ZhangSan&quot;</span>;<br>    <span class="hljs-function">string <span class="hljs-title">hobby</span><span class="hljs-params">(<span class="hljs-string">&quot;football&quot;</span>)</span></span>;<br>    cout &lt;&lt; name &lt;&lt; hobby &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>String 的初始化方式</p>
<p><img src="/Blog/intro/string.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/stringaction.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++">string s1 = <span class="hljs-string">&quot;hello&quot;</span>;<br><span class="hljs-function">string <span class="hljs-title">s2</span><span class="hljs-params">(<span class="hljs-string">&quot;world&quot;</span>)</span></span>;<br>string s3 = s1 + s2;<br>string s4 = <span class="hljs-string">&quot;hello&quot;</span> + s2;<br>string s5 = <span class="hljs-string">&quot;hello&quot;</span> + s2 + <span class="hljs-string">&quot;world&quot;</span>;<br>string s6 = s1 + <span class="hljs-string">&quot;world&quot;</span>;<br>string s7 = <span class="hljs-string">&quot;hello&quot;</span> + <span class="hljs-string">&quot;world&quot;</span>;		<span class="hljs-comment">//只有这种用法是错误的, 双引号之间不能直接相加, 必须有变量</span><br></code></pre></td></tr></table></figure>
<p><br></p>
<h4 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h4><p>​    字符串只能与字符串用 “+” 号连接, 不能与 int char … 用 加号连接</p>
<p><br></p>
<p><br></p>
<h3 id="类内定义与内联函数的关系"><a href="#类内定义与内联函数的关系" class="headerlink" title="类内定义与内联函数的关系"></a>类内定义与内联函数的关系</h3><p>内联函数上文中有介绍</p>
<h4 id="类内定义"><a href="#类内定义" class="headerlink" title="类内定义"></a>类内定义</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> _age)</span></span>&#123;age = _age&#125;<br>    <span class="hljs-type">int</span> <span class="hljs-built_in">getAge</span>()&#123;<span class="hljs-keyword">return</span> age;&#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">study</span><span class="hljs-params">()</span></span>&#123;&#125;<br><span class="hljs-keyword">private</span>:<br>    string name;<br>    <span class="hljs-type">int</span> age;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>像上面这样把函数定义在类的内部是类内定义</p>
<p><strong>类内定义的函数编译器会将其优先编译成内联函数</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> _age)</span></span>&#123;age = _age&#125;<br>    <span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-built_in">getAge</span>()&#123;<span class="hljs-keyword">return</span> age;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">study</span><span class="hljs-params">()</span></span>&#123;&#125;<br><span class="hljs-keyword">private</span>:<br>    string name;<br>    <span class="hljs-type">int</span> age;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p><br></p>
<h3 id="类外定义"><a href="#类外定义" class="headerlink" title="类外定义"></a>类外定义</h3><p>成员函数的函数体写在类的外面</p>
<p>类外定义有两种形式</p>
<ul>
<li>同文件类外定义</li>
<li>分文件类外定义</li>
</ul>
<p><br></p>
<h4 id="同文件类内定义"><a href="#同文件类内定义" class="headerlink" title="同文件类内定义"></a>同文件类内定义</h4><p>Car.cpp</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">changeSpeed</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Car::run</span><span class="hljs-params">()</span></span>&#123;&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Car::stop</span><span class="hljs-params">()</span></span>&#123;&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Car::changeSpeed</span><span class="hljs-params">()</span></span>&#123;&#125;<br></code></pre></td></tr></table></figure>
<p>​    <br></p>
<h4 id="分文件类外定义"><a href="#分文件类外定义" class="headerlink" title="分文件类外定义"></a>分文件类外定义</h4><p>专业一点都用分文件类外定义</p>
<p><br></p>
<p>Car.h</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Car</span>&#123;</span><br>public:<br>    <span class="hljs-type">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>;<br>    <span class="hljs-type">void</span> <span class="hljs-title function_">stop</span><span class="hljs-params">()</span>;<br>    <span class="hljs-type">void</span> <span class="hljs-title function_">changeSpeed</span><span class="hljs-params">()</span>;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>Car.cpp</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Car.h&quot;</span>	<span class="hljs-comment">//一定要引入</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Car::run</span><span class="hljs-params">()</span></span>&#123;&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Car::stop</span><span class="hljs-params">()</span></span>&#123;&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Car::changeSpeed</span><span class="hljs-params">()</span></span>&#123;&#125;<br></code></pre></td></tr></table></figure>
<p><br></p>
<h2 id="对象的结构"><a href="#对象的结构" class="headerlink" title="对象的结构"></a>对象的结构</h2><h3 id="内存分区"><a href="#内存分区" class="headerlink" title="内存分区"></a>内存分区</h3><p><img src="/Blog/intro/memory-1557777502848.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p>栈区:    内存由系统来进行控制, 分配与回收不用程序员关心</p>
<p>堆区:    必须由程序员 delete 回收</p>
<p><br></p>
<p><img src="/Blog/intro/obejct.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p>每个对象都会占用一段内存, 用于存储各自的数据. </p>
<p>逻辑代码只有一份, 占用代码区. 需要的时候贡所有的代码使用.</p>
<p><br></p>
<h3 id="对象的初始化"><a href="#对象的初始化" class="headerlink" title="对象的初始化"></a>对象的初始化</h3><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><ul>
<li>​    构造函数在对象实例化时被自动调用, 被调用且仅被调用一次</li>
<li>​    构造函数与类名同名</li>
<li>​    构造函数没有返回值</li>
<li>​    构造函数可以重载</li>
<li>​    实例化对象仅能用到一个构造函数</li>
<li>​    当用户没有定义构造函数时, 编译器会自动生成一个构造函数</li>
</ul>
<p><br></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>&#123;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-built_in">Student</span>(string name)&#123;m_strName = name&#125;;	<span class="hljs-comment">//构造函数</span><br><span class="hljs-keyword">private</span>:<br>	string m_strName;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p><br></p>
<h4 id="构造函数初始化列表"><a href="#构造函数初始化列表" class="headerlink" title="构造函数初始化列表"></a>构造函数初始化列表</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>&#123;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-built_in">Student</span>():<span class="hljs-built_in">m_strName</span>(<span class="hljs-string">&quot;Jim&quot;</span>), <span class="hljs-built_in">m_iAge</span>(<span class="hljs-number">10</span>)&#123;&#125;<br><span class="hljs-keyword">private</span>:<br>	string m_strName;<br>	<span class="hljs-type">int</span> m_iAge;<br>&#125;;	<br></code></pre></td></tr></table></figure>
<p><br></p>
<p>构造函数后 <strong>:属性名(值)</strong> 来声明初始化列表, 多个属性之间用逗号间隔</p>
<p>​            赋值只能用括号</p>
<p><br></p>
<h5 id="初始化列表特性"><a href="#初始化列表特性" class="headerlink" title="初始化列表特性"></a>初始化列表特性</h5><ul>
<li>​    初始化列表优先于构造函数执行</li>
<li>​    初始化列表只能用于构造函数</li>
<li>​    初始化列表可以同时初始化多个数据成员, 效率高, 速度快</li>
</ul>
<h5 id="初始化列表存在的必要性"><a href="#初始化列表存在的必要性" class="headerlink" title="初始化列表存在的必要性"></a>初始化列表存在的必要性</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// Circle(int p)&#123;m_dPI=p;&#125;		这么做是错误的, 不能给常量再赋值</span><br>    <span class="hljs-built_in">Circle</span>(<span class="hljs-type">int</span> p):<span class="hljs-built_in">m_dPI</span>(p)&#123;&#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">const</span> <span class="hljs-type">double</span> m_dPI;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>如果分文件定义, 则定义构造函数时不用写初始化列表,</p>
<p>​                实现构造函数时需要些初始化列表</p>
<p><br></p>
<p><br></p>
<h4 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Student</span>()<br>    &#123;cout &lt;&lt; <span class="hljs-string">&quot;Student&quot;</span>;&#125;	<span class="hljs-comment">//构造函数</span><br><span class="hljs-keyword">private</span>:<br>    string m_strName;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    Student stu1;			<span class="hljs-comment">// 打印 Student</span><br>    Student stu2 = stu1;	<span class="hljs-comment">// 没打印 Student</span><br>    <span class="hljs-function">Student <span class="hljs-title">stu3</span><span class="hljs-params">(stu1)</span></span>;		<span class="hljs-comment">// 没打印 Student</span><br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>上面三次实例化中, 只调用了一次 cout &lt;&lt; “Student”;</p>
<p>这里没有调用默认的构造函数而是调用拷贝构造函数</p>
<p><br></p>
<h5 id="定义格式"><a href="#定义格式" class="headerlink" title="定义格式"></a>定义格式</h5><p>类名 (const 类名 &amp;变量名)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Student</span>()<br>    &#123;cout &lt;&lt; <span class="hljs-string">&quot;Student&quot;</span>;&#125;	<span class="hljs-comment">//构造函数</span><br>    <span class="hljs-built_in">Student</span>(<span class="hljs-type">const</span> Student &amp;stu)&#123;&#125;<br><span class="hljs-keyword">private</span>:<br>    string m_strName;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p><br></p>
<h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><ol>
<li>如果没有自定义的拷贝构造函数则系统自动生成一个默认的拷贝构造函数</li>
<li>当采用直接初始化或复制初始化实例化对象时系统自动调用拷贝构造函数</li>
<li>拷贝构造函数的参数是确定的，不能重载    </li>
</ol>
<p><br></p>
<p><br></p>
<h3 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h3><p>析构函数在对象销毁时自动调用</p>
<h4 id="定义格式-1"><a href="#定义格式-1" class="headerlink" title="定义格式"></a>定义格式</h4><p>​    ~类名()</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Student</span>()<br>    &#123;cout &lt;&lt; <span class="hljs-string">&quot;Student&quot;</span>;&#125;	<span class="hljs-comment">//构造函数</span><br>    ~<span class="hljs-built_in">Student</span>()&#123;cout &lt;&lt; <span class="hljs-string">&quot;~Student&quot;</span>;&#125;			<span class="hljs-comment">//析构函数</span><br><span class="hljs-keyword">private</span>:<br>    string m_strName;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p><img src="/Blog/intro/deletefunction.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>析构函数的作用就是 <strong>释放内存</strong></p>
<h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><ol>
<li>如果没有自定义的析构函数则系统自动生成</li>
<li>析构函数在对象销毁时调用</li>
<li>析构函数没有返回值, 不能有参数, 不可能重载</li>
</ol>
<p><br></p>
<p><br></p>
<h3 id="对象数组"><a href="#对象数组" class="headerlink" title="对象数组"></a>对象数组</h3><p><br></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Coordinate</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> m_iX;<br>    <span class="hljs-type">int</span> m_iY;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    Coordinate coord[<span class="hljs-number">3</span>];		<span class="hljs-comment">// 在栈上实例化</span><br>    coord[<span class="hljs-number">1</span>].m_iX = <span class="hljs-number">10</span>;<br>    Coordinate *p = <span class="hljs-keyword">new</span> Coordinate[<span class="hljs-number">3</span>];	<span class="hljs-comment">// 在堆中实例化</span><br>    p[<span class="hljs-number">0</span>].m_iX = <span class="hljs-number">0</span>;		p -&gt; m_iY = <span class="hljs-number">20</span>;<br>    <span class="hljs-keyword">delete</span> []p;<br>    p = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><br></p>
<p><img src="/Blog/intro/objectArray.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p>p指向第一个元素</p>
<p>p++ 后 指针就指向了第二个元素</p>
<p>此时p[0]访问的也是第二个元素</p>
<p>p— 后 指针会回到第一个元素</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    Coordinate *p = <span class="hljs-keyword">new</span> Coordinate[<span class="hljs-number">3</span>];	<span class="hljs-comment">//执行所有对象的构造函数</span><br>    p-&gt;m_iY = <span class="hljs-number">12</span>;<br>    p-&gt;m_iX = <span class="hljs-number">7</span>;<br>    p[<span class="hljs-number">1</span>].m_iY = <span class="hljs-number">9</span>;<br>    (++p)-&gt;m_iX = <span class="hljs-number">10</span>;	<span class="hljs-comment">//p指向第二个元素</span><br>    p += <span class="hljs-number">1</span>;				<span class="hljs-comment">//p指向第三个元素</span><br>    p-&gt;m_iX = <span class="hljs-number">15</span>;<br>    p-&gt;m_iY = <span class="hljs-number">20</span>;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++)&#123;<br>        cout &lt;&lt; p-&gt;m_iX &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; p-&gt;m_iY &lt;&lt; endl;<br>        p--;			<span class="hljs-comment">//p回退</span><br>    &#125;<br>    p++;				<span class="hljs-comment">//p指向第一个元素</span><br>    <span class="hljs-keyword">delete</span> []p;			<span class="hljs-comment">//释放p[], 执行所有对象的析构函数</span><br>    p = <span class="hljs-literal">NULL</span>;			<span class="hljs-comment">//指针指空</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><br></p>
<h3 id="对象成员"><a href="#对象成员" class="headerlink" title="对象成员"></a>对象成员</h3><p>对象也可以作为另一个对象的属性</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Coordinate.h&quot;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Line</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//...</span><br><span class="hljs-keyword">private</span>:<br>    Coordinate m_coorA;<br>    Coordinate m_coorB;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>默认实例化时的顺序</p>
<ol>
<li>实例化m_coorA</li>
<li>实例化m_coorB</li>
<li>实例化Line</li>
</ol>
<p>默认销毁时的顺序</p>
<ol>
<li>销毁Line</li>
<li>销毁m_coorB</li>
<li>销毁m_coorA</li>
</ol>
<p><br></p>
<h3 id="深拷贝与浅拷贝"><a href="#深拷贝与浅拷贝" class="headerlink" title="深拷贝与浅拷贝"></a>深拷贝与浅拷贝</h3><p>拷贝构造函数</p>
<h4 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a><strong>浅拷贝</strong></h4><p><img src="/Blog/intro/copyfunction-1558048558423.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>单纯的把所有属性赋值给新的对象</p>
<p><br></p>
<h5 id="浅拷贝的缺点"><a href="#浅拷贝的缺点" class="headerlink" title="浅拷贝的缺点"></a>浅拷贝的缺点</h5><p>如果对象有指针的话, 使用浅拷贝会使得两个指针指向同一个内存空间</p>
<p><img src="/Blog/intro/copy.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p><img src="/Blog/intro/copypointer.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>缺点:</p>
<ol>
<li>如果分别给两个指针赋值, 后者会覆盖掉原来的内容</li>
<li>销毁对象时会释放两个对象的内存, 如果已经释放一次, 再次释放系统会崩溃</li>
</ol>
<p><br></p>
<h4 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h4><p><img src="/Blog/intro/deepcopy.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>我们希望拷贝时不是简单的把内存地址拷贝过来,</p>
<p>而是把指针指向内存的每一个元素依次地拷贝过来, 这就是深拷贝</p>
<p><br></p>
<p><img src="/Blog/intro/deepcopyfunction.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p>上面首先新建了一片内存空间, 之后再逐一拷贝</p>
<p><br></p>
<h3 id="对象指针"><a href="#对象指针" class="headerlink" title="对象指针"></a>对象指针</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Coordinate</span>&#123;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-type">int</span> x;<br>	<span class="hljs-type">int</span> y;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p><img src="/Blog/intro/coordinateclass.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>(*p) 是一个对象, p是指针</p>
<p>p 实际指向对象中的第一个元素</p>
<p><img src="/Blog/intro/example.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p><br></p>
<h3 id="对象成员指针"><a href="#对象成员指针" class="headerlink" title="对象成员指针"></a>对象成员指针</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Coordinate</span>&#123;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-built_in">Coordinate</span>(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y);<br><span class="hljs-keyword">private</span>:<br>	<span class="hljs-type">int</span> x;<br>	<span class="hljs-type">int</span> y;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Line</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Line</span>()&#123;<br>        m_pCoorA = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Coordinate</span>(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>);<br>    	m_pCoorB = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Coordinate</span>(<span class="hljs-number">5</span>, <span class="hljs-number">6</span>);<br>    &#125;<br>    ~<span class="hljs-built_in">Line</span>()&#123;<br>        <span class="hljs-keyword">delete</span> m_pCoorA;<br>        <span class="hljs-keyword">delete</span> m_pCoorB;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    Coordinate *m_coorA;<br>    Coordinate *m_coorB;<br>&#125;;<br><br><span class="hljs-comment">// cout &lt;&lt; sizeof(line) &lt;&lt; endl; 32位编译环境下打印8, 每个指针占用4个内存单元</span><br></code></pre></td></tr></table></figure>
<p><br></p>
<p><img src="/Blog/intro/sizeofpointer.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>m_pCoorA 和 m_pCoorB 对象都在堆中, 而不再line对象中</p>
<h3 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this<br>指针</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Array</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Array</span>(<span class="hljs-type">int</span> len)&#123;<span class="hljs-keyword">this</span>-&gt;len = len;&#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setLen</span><span class="hljs-params">(<span class="hljs-type">int</span> len)</span></span>&#123;<span class="hljs-keyword">this</span>-&gt;len = len;&#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> len;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p><img src="/Blog/intro/thispointer.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>c++编译器会为所有方法添加this指针, 所以我们不用显示的写出了.</p>
<p><br></p>
<h4 id="this指针作为返回值"><a href="#this指针作为返回值" class="headerlink" title="this指针作为返回值"></a>this指针作为返回值</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//下面这两种方法返回值都可以操纵原本的对象</span><br><span class="hljs-function">Array* <span class="hljs-title">getObject</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>&#125;<br><span class="hljs-function">Array&amp; <span class="hljs-title">getObject</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><span class="hljs-comment">//下面这种方法返回值操纵的不是原来的对象</span><br><span class="hljs-function">Array <span class="hljs-title">getObject</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><br></p>
<h3 id="const-常对象成员和常成员函数"><a href="#const-常对象成员和常成员函数" class="headerlink" title="const 常对象成员和常成员函数"></a>const 常对象成员和常成员函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Coordinate</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Coordinate</span>(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y);<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">changeX</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;	<span class="hljs-comment">//常成员函数</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">changeX</span><span class="hljs-params">()</span></span>;			<span class="hljs-comment">//与上方的语句互为重载</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> x;<br>    <span class="hljs-type">int</span> y;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-type">const</span> Coordinate <span class="hljs-title">coordinate</span><span class="hljs-params">(<span class="hljs-number">3</span>, <span class="hljs-number">5</span>)</span></span>;	<span class="hljs-comment">//常对象</span><br>    coordinate.<span class="hljs-built_in">changeX</span>();	<span class="hljs-comment">//调用的是常成员函数</span><br>    <br>    <span class="hljs-function">Coordinate <span class="hljs-title">coordinate2</span><span class="hljs-params">(<span class="hljs-number">3</span>, <span class="hljs-number">5</span>)</span></span>;<br>    coordinate2.<span class="hljs-built_in">changeX</span>();	<span class="hljs-comment">//调用的是没有const的函数</span><br>    return0;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><br></p>
<p><img src="/Blog/intro/constfunction.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>第一个写法是错误的, 第二个写法是正确的</p>
<p><strong>常成员函数中为什么不能改变数据成员的值?</strong></p>
<p><img src="/Blog/intro/whyconstfunction.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>前面说过, 当调用函数时会默认传入参数this</p>
<p><img src="/Blog/intro/thisconst.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>使用常指针改变该指针指向的数据是不被允许的</p>
<p><br></p>
<h3 id="常指针与常引用"><a href="#常指针与常引用" class="headerlink" title="常指针与常引用"></a>常指针与常引用</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Coordinate</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printInfo</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>&#123;&#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getX</span><span class="hljs-params">()</span></span>&#123;&#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getY</span><span class="hljs-params">()</span></span>&#123;&#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> X;<br>    <span class="hljs-type">int</span> Y;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>    <span class="hljs-function">Coordinate <span class="hljs-title">coor1</span><span class="hljs-params">(<span class="hljs-number">3</span>,<span class="hljs-number">5</span>)</span></span>;<br>    <span class="hljs-type">const</span> Coordinate &amp;coor2 = coor1;<br>    <span class="hljs-type">const</span> Coordinate *pCoor = &amp;coor1;<br>    <br>    coor1.<span class="hljs-built_in">printInfo</span>();	<span class="hljs-comment">//正确</span><br>    coor2.<span class="hljs-built_in">getX</span>();		<span class="hljs-comment">//错误, 传入的this只有读权限, 而getX不是常成员方法, 需要传入的this要有读写权限</span><br>    pCoor-&gt;<span class="hljs-built_in">getY</span>();		<span class="hljs-comment">//错误, 原因同上</span><br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>    <span class="hljs-function">Coordinate <span class="hljs-title">coor1</span><span class="hljs-params">(<span class="hljs-number">3</span>,<span class="hljs-number">5</span>)</span></span>;<br>	<span class="hljs-function">Coordinate <span class="hljs-title">coor2</span><span class="hljs-params">(<span class="hljs-number">7</span>,<span class="hljs-number">9</span>)</span></span>;<br>	Coordinate * <span class="hljs-type">const</span> pCoor = &amp;coor1; <span class="hljs-comment">// 修饰pCoor指针, 所以pCoor不能再指向其他对象, 但它本身指向的对象的内容是可变的 即*pCoor是可变的</span><br>	pCoor-&gt;<span class="hljs-built_in">getY</span>();	<span class="hljs-comment">//正确</span><br>	pCoor=coor2;	<span class="hljs-comment">//错误</span><br>	pCoor-&gt;<span class="hljs-built_in">printInfo</span>();	<span class="hljs-comment">//正确</span><br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><br></p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h3 id="三种继承方式"><a href="#三种继承方式" class="headerlink" title="三种继承方式"></a>三种继承方式</h3><ul>
<li>公有继承    class A : <strong>public</strong> B</li>
<li>保护继承    class A : <strong>protected</strong> B</li>
<li>私有继承    class A : <strong>private</strong> B</li>
</ul>
<p><br></p>
<h4 id="公有继承"><a href="#公有继承" class="headerlink" title="公有继承"></a>公有继承</h4><h5 id="public"><a href="#public" class="headerlink" title="public"></a>public</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span></span>;<br>    string name;<br>    <span class="hljs-type">int</span> age;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Worker</span>: <span class="hljs-keyword">public</span> Person&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span></span>;		<span class="hljs-comment">//不用显示声明</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span></span>;<br>    string name;	<span class="hljs-comment">//不用显示声明</span><br>    <span class="hljs-type">int</span> age;		<span class="hljs-comment">//不用显示声明</span><br>    <span class="hljs-type">int</span> salary;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p><br></p>
<h5 id="protected"><a href="#protected" class="headerlink" title="protected"></a>protected</h5><p><img src="/Blog/intro/protectedextend.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<h5 id="private"><a href="#private" class="headerlink" title="private"></a>private</h5><p>m_strName 和 m_iAge 都被继承到 Worker下不可见位置 <strong>不是private</strong>, 是不可见位置</p>
<p>所有work中调用m_iAge会出错</p>
<p><img src="/Blog/intro/privateextend.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/public.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<h4 id="保护继承"><a href="#保护继承" class="headerlink" title="保护继承"></a>保护继承</h4><p><img src="/Blog/intro/protectextent.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<h4 id="私有继承"><a href="#私有继承" class="headerlink" title="私有继承"></a>私有继承</h4><p><img src="/Blog/intro/privateextent.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<h2 id="隐藏"><a href="#隐藏" class="headerlink" title="隐藏"></a>隐藏</h2><p><img src="/Blog/intro/hide.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>当子类当中定义了同名的函数时</p>
<p>此时子类就会隐藏掉父类的ABC() 函数 (通过特殊手段依然可以访问, 所以是隐藏)</p>
<p>数据成员也同样可以隐藏</p>
<p><img src="/Blog/intro/hide_example.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/use_hide.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>上面 调用了子类的play 又调用了父类的play</p>
<p><br></p>
<p><img src="/Blog/intro/hide_attr.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/use_hide_attr.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<h2 id="虚析构函数"><a href="#虚析构函数" class="headerlink" title="虚析构函数"></a>虚析构函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">Person *p = <span class="hljs-keyword">new</span> Soldier;<br>p-&gt;<span class="hljs-built_in">play</span>();<br><br><span class="hljs-built_in">delete</span>(p);		<span class="hljs-comment">// 只执行了父类的析构函数, 子类的析构函数没有执行, 有内存泄漏的可能</span><br>p = <span class="hljs-literal">NULL</span>;<br></code></pre></td></tr></table></figure>
<p>当用父类的指针指向子类对象后, 希望用父类指针释放内存,  此时要用虚析构函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Person</span>()&#123;&#125;		<span class="hljs-comment">// virtual 可以被继承, 也就是说子类如果不写virtual也可以</span><br><span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Student</span>()&#123;&#125;<br></code></pre></td></tr></table></figure>
<p><br></p>
<h2 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h2><p>写法:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Worker</span>&#123;&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Farmer</span>&#123;&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MigrantWorker</span> : <span class="hljs-keyword">public</span> Worker, <span class="hljs-keyword">public</span> Farmer&#123;<br>    <span class="hljs-comment">//...</span><br>&#125;;<br></code></pre></td></tr></table></figure>
<p><br></p>
<h2 id="虚继承"><a href="#虚继承" class="headerlink" title="虚继承"></a>虚继承</h2><h3 id="菱形继承"><a href="#菱形继承" class="headerlink" title="菱形继承"></a>菱形继承</h3><p><img src="/Blog/intro/virtualextend.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>当我们实力化类D时, 会实例化类B 在实例化类A. 实例化类C, 又实例化类A</p>
<p>类A实例化了两次. 但这并不好. 而避免这种情况的方法就是使用虚继承</p>
<p><br></p>
<p>写法:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// worker 被称为虚基类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Worker</span>: <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> Person&#123;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Farmer</span>: <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> Person&#123;<br>&#125;;<br><span class="hljs-comment">// 实例化MigrantWorker 时, 它只含有一份Person的数据</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MigrantWorker</span> : <span class="hljs-keyword">public</span> Worker, <span class="hljs-keyword">public</span> Farmer&#123;<br>    <br>&#125;;<br></code></pre></td></tr></table></figure>
<p>注意使用虚继承以后 Person就只能使用自己的默认参数, 而不能获取子类中的参数</p>
<p>经过测试, 这种情况下可以如此传参</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//构造函数, 使用初始化列表指定person的参数</span><br>MigrantWorker::<span class="hljs-built_in">MigrantWorker</span>(string name, string code, string color):<span class="hljs-built_in">Farmer</span>(name), <span class="hljs-built_in">Worker</span>(code),<span class="hljs-built_in">Person</span>(color) &#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;MigrantWorker()&quot;</span> &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><br></p>
<h3 id="重定义"><a href="#重定义" class="headerlink" title="重定义"></a>重定义</h3><p>而且菱形继承还有一个问题</p>
<p>B 中 引用了 A, C 中 也引用了A, D引用B,C. 则重复引用了A 2次</p>
<p>会报错. 而解决办法就是使用<strong>宏定义</strong></p>
<h4 id="宏定义"><a href="#宏定义" class="headerlink" title="宏定义"></a>宏定义</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//宏定义 当多次包含时,编译时只编译一次	后面加上唯一的名称 (最好是类名) </span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> IMOOC_PERSON_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMOOC_PERSON_H</span><br><br><span class="hljs-comment">//...class</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">//IMOOC_PERSON_H</span></span><br></code></pre></td></tr></table></figure>
<p><br></p>
<p><br></p>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>定义:</p>
<p>指相同对象收到不同消息或不同对象收到相同消息时产生不同的动作</p>
<p><br></p>
<p><strong>静态多态 vs 动态多态</strong></p>
<p><br></p>
<h3 id="静态多态-早绑定"><a href="#静态多态-早绑定" class="headerlink" title="静态多态(早绑定)"></a>静态多态(早绑定)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//计算机在调用函数之前就知道要使用哪个函数</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rect</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">calcArea</span><span class="hljs-params">(<span class="hljs-type">int</span> width)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">calcArea</span><span class="hljs-params">(<span class="hljs-type">int</span> width, <span class="hljs-type">int</span> height)</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="动态多态-晚绑定"><a href="#动态多态-晚绑定" class="headerlink" title="动态多态(晚绑定)"></a>动态多态(晚绑定)</h3><p>父类指针指向子类对象</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    Shape *s1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Circle</span>(<span class="hljs-number">4.0</span>);<br>    Shape *s2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Rect</span>(<span class="hljs-number">3.0</span>, <span class="hljs-number">5.0</span>);<br>    s1-&gt;<span class="hljs-built_in">calcArea</span>();		<span class="hljs-comment">//这里会调用父类的calcArea的方法</span><br>    s2-&gt;<span class="hljs-built_in">calcArea</span>();		<span class="hljs-comment">//这里会调用父类的calcArea的方法</span><br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这种结果不是我们想要的.</p>
<p>我们希望他们打印各自的函数</p>
<p><strong>解决方法:</strong></p>
<h4 id="virtual-虚函数"><a href="#virtual-虚函数" class="headerlink" title="virtual 虚函数"></a>virtual 虚函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Shape</span>&#123;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">double</span> <span class="hljs-title">calcArea</span><span class="hljs-params">()</span></span>&#123;		<span class="hljs-comment">//虚函数</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;calcArea()&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>	&#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>// 建议把子类的方法也加上 virtual 关键字</p>
<p>之后再使用上面的main方法就可以调用各自子类的函数</p>
<p><strong><em>建议所有方法都加上virtual关键字</em></strong></p>
<p><br></p>
<h4 id="virtual-的限制"><a href="#virtual-的限制" class="headerlink" title="virtual 的限制"></a>virtual 的限制</h4><p>前面讲过虚析构函数, 这里又讲虚函数, virtual有没有限制?</p>
<ol>
<li><p>virtual 只能修饰成员函数. 普通函数不能使虚函数</p>
</li>
<li><p>virtual 不能修饰静态的成员函数</p>
</li>
<li>内联函数 (inline) 不能是虚函数</li>
<li>构造函数不能是虚函数</li>
</ol>
<p><br></p>
<h2 id="虚函数与虚析构函数的实现原理"><a href="#虚函数与虚析构函数的实现原理" class="headerlink" title="虚函数与虚析构函数的实现原理"></a>虚函数与虚析构函数的实现原理</h2><h3 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h3><p>指针指向对象    —&gt;    对象指针</p>
<p>指针指向函数    —&gt;    函数指针</p>
<p><br></p>
<p>函数的本质就是一段二进制代码, 写在内存当中.</p>
<p>我们可以用指针指向代码的开头</p>
<p>其实函数指针和普通的对象指针没有区别</p>
<p>都是存储一段内存地址</p>
<p><img src="/Blog/intro/functionpointer.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<h3 id="实现原理的例子"><a href="#实现原理的例子" class="headerlink" title="实现原理的例子"></a>实现原理的例子</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Shape</span>&#123;<br><span class="hljs-keyword">public</span> :<br>	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">double</span> <span class="hljs-title">calcArea</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>	&#125;<br>protect:<br>	<span class="hljs-type">int</span> edge;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span>: <span class="hljs-keyword">public</span> Shape&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Circle</span>(<span class="hljs-type">double</span> r);<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">double</span> r;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>此时circle没有实现clacArea, 所以circle应该调用父类方法计算面积</p>
<p><br></p>
<p>当实例化Shape时, 出来实例化数据成员, 还实例化了一个虚函数表指针</p>
<p>虚函数表指针同样是指针, 占有4个内存单元</p>
<p>假设虚函数表的起始位置是0xccff, 那么虚函数表指针也就指向0xccff</p>
<p>如果实例化多个Shape对象, 它的虚函数表指针也指向0xccff, 确保每个对象的虚函数表指针都指向自己的虚函数表</p>
<p>虚函数表中一定有一个指针指向 calcArea 函数</p>
<p><br></p>
<p>调用时 先找到虚函数表指针 -&gt; 找到虚函数表 -&gt; 通过位置的偏移找到虚函数的入口地址 -&gt; 找到虚函数</p>
<p><img src="/Blog/intro/virtualtable.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p><br></p>
<p>如果实例化Circle</p>
<p>circle中没有定义虚函数, 但它从父类中继承了虚函数</p>
<p>所以实例化Circle时也会产生虚函数表 ( circle的虚函数表 0x6688, 和上面Shape的虚函数表 0xccff 不同)</p>
<p>但是在这个虚函数表中 指向 calcArea 的指针却是一样的 0x3355</p>
<p>这就能保证通过circle 运行calcArea 能通过 找到自己的虚函数表 -&gt; 找到calcArea的地址 并且执行</p>
<p><img src="/Blog/intro/circlevirtualtable.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>如果定义了 calcArea 那么会怎么样?</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span>: <span class="hljs-keyword">public</span> Shape&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Circle</span>(<span class="hljs-type">double</span> r);<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">double</span> <span class="hljs-title">calcArea</span><span class="hljs-params">()</span></span>;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">double</span> r;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="/Blog/intro/circlenewvirtualtable.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>此时 circle 的虚函数表中 关于计算面积的指针 覆盖掉了父类中原有指针的值</p>
<p>此时调用的是Circle自己定义的虚函数</p>
<p>这就是多态的原理</p>
<p><br></p>
<h3 id="函数的覆盖与隐藏"><a href="#函数的覆盖与隐藏" class="headerlink" title="函数的覆盖与隐藏"></a>函数的覆盖与隐藏</h3><p>隐藏    当父类和子类出现同名函数, 子类函数把父类函数隐藏</p>
<p>覆盖    当子类没定义同名虚函数, 子函数的虚函数表中就会写上父类虚函数的入口地址</p>
<p>​        当子类定义同名虚函数, 则会把父类虚函数的入口地址覆盖掉, 指向自己的虚函数入口地址</p>
<p><br></p>
<h2 id="虚析构函数的实现原理"><a href="#虚析构函数的实现原理" class="headerlink" title="虚析构函数的实现原理"></a>虚析构函数的实现原理</h2><p>回顾 虚析构函数的作用:</p>
<p>当用父类的指针指向子类的对象时, </p>
<p>使用delete只能执行父类的虚构函数, 子类的虚构函数没有执行</p>
<p>而如果父类使用虚析构函数 则会同样执行子类的虚析构函数</p>
<p><br></p>
<p><strong>理论前提:</strong></p>
<p><strong>执行完子类的析构函数就会执行父类的析构函数</strong></p>
<p><br></p>
<p>所以如果我们delete执行子类的析构函数, 那么就会实现目标</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Shape</span>&#123;<br><span class="hljs-keyword">public</span> :<br>	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">double</span> <span class="hljs-title">calcArea</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>	&#125;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Shape</span>()&#123;<br>        <span class="hljs-comment">//...</span><br>    &#125;<br>protect:<br>	<span class="hljs-type">int</span> edge;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span>: <span class="hljs-keyword">public</span> Shape&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Circle</span>(<span class="hljs-type">double</span> r);<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Circle</span>();<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">double</span> r;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><br></p>
<p>如果为父类析构函数添加virtual关键字 (子类会自动添加virtual, 但为了规范还是写上virtual关键字)</p>
<p>那么父类的虚析构表里 就会有一个父类析构函数的函数指针</p>
<p><br></p>
<p><img src="/Blog/intro/shapeVirtual.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>子类也同样在析构表中有一个指向析构函数的函数指针</p>
<p>此时如果用父类指针指向子类对象, 那么delete时就可以</p>
<p>找到虚函数表指针 -&gt; 找到虚函数表 -&gt; 找到子类的析构函数 -&gt; 从而指向子类的析构函数 -&gt; 系统自动执行父类的析构函数 </p>
<p><img src="/Blog/intro/circlevirtual.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<h4 id="深入理解对象与虚函数表"><a href="#深入理解对象与虚函数表" class="headerlink" title="深入理解对象与虚函数表 :"></a>深入理解对象与虚函数表 :</h4><p><a target="_blank" rel="noopener" href="https://www.imooc.com/video/9200">https://www.imooc.com/video/9200</a> <a target="_blank" rel="noopener" href="https://www.imooc.com/video/9201">https://www.imooc.com/video/9201</a></p>
<p><br></p>
<h2 id="纯虚函数抽象类"><a href="#纯虚函数抽象类" class="headerlink" title="纯虚函数抽象类"></a>纯虚函数抽象类</h2><p>纯虚函数例子:</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">Shape</span>&#123;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-built_in">double</span> <span class="hljs-title">calcArea</span>()</span>&#123;		<span class="hljs-comment">//虚函数</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>	&#125;<br>	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-built_in">double</span> <span class="hljs-title">calcPerimeter</span>()</span> = <span class="hljs-number">0</span>;		<span class="hljs-comment">//纯虚函数</span><br>&#125;;<br></code></pre></td></tr></table></figure>
<p>纯虚函数在虚函数表的情况</p>
<p>在虚函数表中如果是纯虚函数则是0</p>
<p><br></p>
<p><img src="/Blog/intro/purevirtual.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p><strong>包含纯虚函数的类叫做抽象类</strong></p>
<p>而因为没办法调用纯虚函数, 所有c++不允许抽象类实例化对象</p>
<p><br></p>
<p>只有子类实现了所有的纯虚函数 才能实例化对象</p>
<p><br></p>
<h3 id="接口类"><a href="#接口类" class="headerlink" title="接口类"></a>接口类</h3><p><strong>仅含有纯虚函数的类叫做接口类</strong>(不能含有数据成员)</p>
<p>接口类更多地表达一种能力或协议</p>
<p>接口类没有实现, 所以就不需要外部定义类, 只有头文件就可以了</p>
<p><br></p>
<h2 id="RTTI-运行时类型识别"><a href="#RTTI-运行时类型识别" class="headerlink" title="RTTI 运行时类型识别"></a>RTTI 运行时类型识别</h2><p>Run-time Type Indentification</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Flyable</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">takeoff</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">land</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bird</span>: <span class="hljs-keyword">public</span> Flyable&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foraging</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">takeoff</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">land</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Plane</span>: <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Flyable</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">carry</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">takeoff</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">land</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在使用的时候</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;typeinfo&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doSomething</span><span class="hljs-params">(Flyable *obj)</span></span>&#123;<br>    obj-&gt;<span class="hljs-built_in">takeoff</span>();<br>    cout &lt;&lt; <span class="hljs-built_in">typeid</span>(*obj).<span class="hljs-built_in">name</span>() &lt;&lt; endl;<br>    <span class="hljs-comment">//如果是bird类型</span><br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">typeid</span>(*obj) == <span class="hljs-built_in">typeid</span>(Bird))&#123;<br>        Bird *bird = <span class="hljs-built_in">dynamic_cast</span>&lt;Bird *&gt;(obj);		<span class="hljs-comment">//动态转换</span><br>        bird-&gt;foraging();<br>    &#125;<br>    obj-&gt;<span class="hljs-built_in">land</span>();<br>&#125;<br></code></pre></td></tr></table></figure>
<p><br></p>
<h3 id="dynamic-cast-注意事项"><a href="#dynamic-cast-注意事项" class="headerlink" title="dynamic_cast 注意事项"></a>dynamic_cast 注意事项</h3><ul>
<li>只能应用于指针和引用的转换</li>
<li>要转换的类型中必须包含虚函数</li>
<li>转换成功返回子类的地址, 失败返回NULL</li>
</ul>
<p><br></p>
<h3 id="typeId注意事项"><a href="#typeId注意事项" class="headerlink" title="typeId注意事项"></a>typeId注意事项</h3><p>typeId 返回 一个type_info 对象的引用</p>
<p>如果想通过基类的指针获得派生类的数据类型, 基类必须带有虚函数</p>
<p>只能获取对象的实际类型, 无法判断当前指针是基类还是子类</p>
<p><br></p>
<h3 id="type-info源码"><a href="#type-info源码" class="headerlink" title="type_info源码"></a>type_info源码</h3><p>type_info可以实现运算符重载</p>
<p><img src="/Blog/intro/1558983908939.png" srcset="/Blog/img/loading.gif" lazyload alt="1558983908939"></p>
<p><br></p>
<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>try … catch … throw</p>
<p><img src="/Blog/intro/1558989615257.png" srcset="/Blog/img/loading.gif" lazyload alt="1558989615257"></p>
<p>catch(…) 代表捕获所有类型的异常, 不建议这么做</p>
<p><br></p>
<h3 id="常见的异常"><a href="#常见的异常" class="headerlink" title="常见的异常"></a>常见的异常</h3><p>数组下标越界</p>
<p>除数为0</p>
<p>内存不足</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-comment">//    throw 1;</span><br>    <span class="hljs-keyword">throw</span> <span class="hljs-built_in">IndexException</span>(<span class="hljs-string">&quot;new Exception&quot;</span>);		<span class="hljs-comment">//IndexException 是自己实现的</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-built_in">test</span>();<br>    &#125;<span class="hljs-built_in">catch</span> (<span class="hljs-type">int</span> &amp;i)&#123;<br>        cout &lt;&lt; i &lt;&lt; endl;<br>    &#125;<span class="hljs-built_in">catch</span> (Exception &amp;e)&#123;						<span class="hljs-comment">//Exception 是自己实现的</span><br>        e.<span class="hljs-built_in">printException</span>();<br>    &#125;<span class="hljs-built_in">catch</span> (...)&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Exception&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><br></p>
<h2 id="友元函数-—-友元类"><a href="#友元函数-—-友元类" class="headerlink" title="友元函数 — 友元类"></a>友元函数 — 友元类</h2><p>友元的作用: 当在一个类中生命一个友元函数之后, 在这个函数中可以调用这个类的私有属性和方法</p>
<p>因此只有传递这个类才能体现友元的作用</p>
<p><br></p>
<p>函数可以是全局函数, 也可以是成员函数</p>
<p>所以就有: 友元全局函数, 友元成员函数</p>
<p>关键字: friend</p>
<p>友元函数需要包含一个能访问私有属性的参数(指针, 对象, 引用)</p>
<p>这样才能体现出友元的特征</p>
<h3 id="友元全局函数的例子"><a href="#友元全局函数的例子" class="headerlink" title="友元全局函数的例子"></a>友元全局函数的例子</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Coordinate</span>&#123;<br>  	<span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> <span class="hljs-title">printXY</span><span class="hljs-params">(Coordinate &amp;c)</span></span>;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-built_in">Coordinate</span>(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y);<br><span class="hljs-keyword">private</span>:<br>	<span class="hljs-type">int</span> x;<br>	<span class="hljs-type">int</span> y;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p><img src="/Blog/intro/1559090043720.png" srcset="/Blog/img/loading.gif" lazyload alt="1559090043720"></p>
<h3 id="友元成员函数的例子"><a href="#友元成员函数的例子" class="headerlink" title="友元成员函数的例子"></a>友元成员函数的例子</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Coordinate</span>&#123;<br>  	<span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> <span class="hljs-title">Circle::printXY</span><span class="hljs-params">(Coordinate &amp;c)</span></span>;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-built_in">Coordinate</span>(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y);<br><span class="hljs-keyword">private</span>:<br>	<span class="hljs-type">int</span> x;<br>	<span class="hljs-type">int</span> y;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p><br></p>
<p><img src="/Blog/intro/1559090460855.png" srcset="/Blog/img/loading.gif" lazyload alt="1559090460855"></p>
<p><br></p>
<h3 id="友元的缺点"><a href="#友元的缺点" class="headerlink" title="友元的缺点"></a>友元的缺点</h3><p>破坏了系统的封装性, 所以一般不建议大量使用友元</p>
<p><br></p>
<h3 id="友元类"><a href="#友元类" class="headerlink" title="友元类"></a>友元类</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span>;	<span class="hljs-comment">//先声明后定义</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Coordinate</span>&#123;<br>    <span class="hljs-keyword">friend</span> Circle;		<span class="hljs-comment">// 把circle类声明为coordinate的友元类</span><br>    					<span class="hljs-comment">// circle中就可以定义coordinate对象</span><br>    					<span class="hljs-comment">// 通过这个对象任意访问私有数据成员</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Coordinate</span>(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y);<br><span class="hljs-keyword">private</span>:<br>	<span class="hljs-type">int</span> x;<br>    <span class="hljs-type">int</span> y;<br>&#125;;<br></code></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printXY</span><span class="hljs-params">()</span></span>&#123;<br>        cout &lt;&lt; coor.x &lt;&lt; <span class="hljs-string">&quot;,&quot;</span> &lt;&lt; coor.y &lt;&lt; endl;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>	Coordinate coor;    <br>&#125;;<br></code></pre></td></tr></table></figure>
<p>友元的主要事项</p>
<ol>
<li>友元关系不可传递</li>
<li>友元关系是单向性的</li>
<li>友元声明的形式及数量不受限制</li>
</ol>
<p><strong>友元不是一个很好的语法, 只是封装的补充,不可多用</strong></p>
<p>更好地设计程序可以避免友元的使用</p>
<p><br></p>
<h2 id="静态"><a href="#静态" class="headerlink" title="静态"></a>静态</h2><p>静态成员不依赖于对象,而依赖于类</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">class</span> <span class="hljs-title">Tank</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Tank</span>()&#123;count ++;&#125;<br>    ~<span class="hljs-built_in">Tank</span>()&#123;count --;&#125;<br>	<span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">getCount</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> count;&#125;	<span class="hljs-comment">//静态成员函数</span><br>	<span class="hljs-type">static</span> <span class="hljs-type">int</span> count;		<span class="hljs-comment">//静态数据成员</span><br><span class="hljs-keyword">private</span>:<br>    string code;<br>&#125;;<br><span class="hljs-type">int</span> Tank::count = <span class="hljs-number">0</span>;	<span class="hljs-comment">//由于不依赖对象,所有不在构造函数内赋初始值</span><br></code></pre></td></tr></table></figure>
<p>访问方法:</p>
<p><img src="/Blog/intro/1559249707992.png" srcset="/Blog/img/loading.gif" lazyload alt="1559249707992"></p>
<p><br></p>
<h3 id="静态成员函数不能访问普通数据成员"><a href="#静态成员函数不能访问普通数据成员" class="headerlink" title="静态成员函数不能访问普通数据成员"></a>静态成员函数不能访问普通数据成员</h3><p><br></p>
<p><img src="/Blog/intro/1559250494410.png" srcset="/Blog/img/loading.gif" lazyload alt="1559250494410"></p>
<p>因为静态方法编译时没有this指针, 所以系统不知道调用那个成员变量</p>
<p>但是静态方法可以调用静态属性</p>
<p><br></p>
<h3 id="注意事项-2"><a href="#注意事项-2" class="headerlink" title="注意事项:"></a>注意事项:</h3><ol>
<li>静态数据成员必须单独初始化, 在类的编译之初就进行初始化</li>
<li>静态成员函数不能调用非静态的成员函数和非静态的数据成员</li>
<li>非静态的成员函数 可以调用静态的数据成员</li>
<li><p>静态数据成员只有一份, 不依赖对象而存在 (通过sizeof求对象的大小不包含数据成员)</p>
</li>
<li><p>静态成员方法不能加const关键字, 因为const修饰的是隐藏的this, 而静态成员方法没有this</p>
</li>
</ol>
<p><br></p>
<h2 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h2><p>为原有运算符赋予新的功能</p>
<p>比如 “+” 号 原本是进行数字的相加, 但如果重载以后, 我们可以用+号来拼接字符串</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">string <span class="hljs-title">s1</span><span class="hljs-params">(<span class="hljs-string">&quot;James&quot;</span>)</span></span>;<br>    <span class="hljs-function">string <span class="hljs-title">s2</span><span class="hljs-params">(<span class="hljs-string">&quot;yan&quot;</span>)</span></span>;<br>    string s3 = s1 + s2;<br>    cout &lt;&lt; s3 &lt;&lt; endl;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="本质-函数重载"><a href="#本质-函数重载" class="headerlink" title="本质: 函数重载"></a>本质: 函数重载</h3><p>关键字:</p>
<p>​    operator</p>
<h4 id="一元运算符重载"><a href="#一元运算符重载" class="headerlink" title="一元运算符重载"></a>一元运算符重载</h4><p>一元运算符:    至于一个操作数进行运算</p>
<p>“+” 号 是二元运算符, 但如果把他放在一个数字的前面就代表正数, 是一元运算符</p>
<p>“-“号同理, 代表负数</p>
<p>“++” 也是一元运算符, 他可以放在前面也可以放在后面</p>
<h5 id="负号重载"><a href="#负号重载" class="headerlink" title="负号重载"></a>负号重载</h5><p>​    <img src="/Blog/intro/1559287703066.png" srcset="/Blog/img/loading.gif" lazyload alt="1559287703066"></p>
<h6 id="成员函数重载"><a href="#成员函数重载" class="headerlink" title="成员函数重载"></a>成员函数重载</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Coordinate</span>&#123;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-built_in">Coordinate</span>(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y);<br>	Coordinate&amp; <span class="hljs-keyword">operator</span>-();<br><span class="hljs-keyword">private</span>:<br>	<span class="hljs-type">int</span> x;<br>	<span class="hljs-type">int</span> y;<br>&#125;;<br><br><span class="hljs-comment">//注意下面的写法会改变对象本来的值</span><br><span class="hljs-comment">//正确的写法应该新建一个对象, 该变这个对象并返回本身</span><br>Coordinate&amp; Coordinate::<span class="hljs-keyword">operator</span>-()&#123;		<span class="hljs-comment">//作为普通函数有隐性的this指针</span><br>	x = -x;<br>    y = -y;<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="/Blog/intro/1559287911981.png" srcset="/Blog/img/loading.gif" lazyload alt="1559287911981"></p>
<h6 id="非成员函数重载"><a href="#非成员函数重载" class="headerlink" title="非成员函数重载"></a>非成员函数重载</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Coordinate</span>&#123;<br>    <span class="hljs-keyword">friend</span> Coordinate&amp; <span class="hljs-keyword">operator</span>-(Coordinate &amp;coor);<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-built_in">Coordinate</span>(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y);<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getX</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getY</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setX</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setY</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span>;<br><span class="hljs-keyword">private</span>:<br>	<span class="hljs-type">int</span> x;<br>	<span class="hljs-type">int</span> y;<br>&#125;;<br><br>Coordinate&amp; <span class="hljs-keyword">operator</span>-(Coordinate &amp;coor)&#123;		<span class="hljs-comment">//作为普通函数有隐性的this指针</span><br>	<span class="hljs-function">Coordinate <span class="hljs-title">coor1</span><span class="hljs-params">(coor)</span></span>;<br>    coor1.x = -coor1.x;<br>    coor1.y = -coor1.y;<br>    <span class="hljs-keyword">return</span> coor1;		<span class="hljs-comment">//不改变本身的值</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="/Blog/intro/1559288051741.png" srcset="/Blog/img/loading.gif" lazyload alt="1559288051741"></p>
<p>如果不用友元函数能否重载运算符? 当然可以</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">Coordinate&amp; operator-(const Coordinate&amp; coor)&#123;<br>	Coordinate coor1(coor);<br>    coor1.set<span class="hljs-constructor">X( -<span class="hljs-params">coor1</span>.<span class="hljs-params">getX</span>()</span> );<br>    coor1.set<span class="hljs-constructor">Y( -<span class="hljs-params">coor1</span>.<span class="hljs-params">getY</span>()</span> );<br>    return coor1;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>但是如果我们没有getter和setter就无法进行操作, 友元函数确保我们可以在函数内访问类的私有属性</p>
<p><br></p>
<h5 id="运算符的重载"><a href="#运算符的重载" class="headerlink" title="++运算符的重载"></a>++运算符的重载</h5><p>回想一下int如何进行++操作的</p>
<figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-comment">x</span><span class="hljs-literal">++++</span><span class="hljs-comment">; // 语法错误</span><br><span class="hljs-comment">因为x</span><span class="hljs-literal">++</span> <span class="hljs-comment">返回的是一个值</span><span class="hljs-string">,</span> <span class="hljs-comment">例如4</span><span class="hljs-string">,</span> <span class="hljs-comment">而我们不能对一个值进行</span><span class="hljs-literal">++</span><span class="hljs-comment">操作</span><br><br><span class="hljs-literal">++++</span><span class="hljs-comment">x</span><span class="hljs-literal">++</span><span class="hljs-comment">; // 正确 因为</span> <span class="hljs-literal">++</span> <span class="hljs-comment">x 返回的是一个引用</span><span class="hljs-string">,</span> <span class="hljs-comment">因此可以继续对它进行</span><span class="hljs-literal">++</span><span class="hljs-comment">操作</span><br></code></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Coordinate</span>&#123;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-built_in">Coordinate</span>(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y);<br>    <br>    <span class="hljs-comment">//区别: 前置返回引用,无参数</span><br>    <span class="hljs-comment">//		后置返回对象, int 参数</span><br>	Coordinate&amp; <span class="hljs-keyword">operator</span>++();	<span class="hljs-comment">//前置++	返回引用</span><br>	Coordinate <span class="hljs-keyword">operator</span>++(<span class="hljs-type">int</span>);	<span class="hljs-comment">//后置++,	返回对象, int 是标识, 标识当前为后置重载</span><br><span class="hljs-keyword">private</span>:<br>	<span class="hljs-type">int</span> x;<br>	<span class="hljs-type">int</span> y;<br>&#125;;<br><br>Coordinate&amp; Coordinate::<span class="hljs-keyword">operator</span>++()&#123;	<span class="hljs-comment">//前置++</span><br>    x++;<br>    y++;<br>    <br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><br>Coordinate <span class="hljs-keyword">operator</span>++(<span class="hljs-type">int</span>)&#123;		<span class="hljs-comment">// int没有实际用处, 只是一个标志</span><br>    <span class="hljs-function">Coordinate <span class="hljs-title">old</span><span class="hljs-params">(*<span class="hljs-keyword">this</span>)</span></span>;		<span class="hljs-comment">// old 记录当前值,不改变本身的值, 如果接收后置++的值, 也是以前的值</span><br>    x++;						<span class="hljs-comment">// 但当下一行代码再去使用就会是新值</span><br>    y++;<br>	<br>    <span class="hljs-keyword">return</span> old;					<span class="hljs-comment">// 返回对象	</span><br>&#125;<br><br></code></pre></td></tr></table></figure>
<p><img src="/Blog/intro/1559342959015.png" srcset="/Blog/img/loading.gif" lazyload alt="1559342959015"></p>
<p>上面的0是系统自动编译的, 没有任何意义, 只是标识</p>
<h4 id="二元运算符重载"><a href="#二元运算符重载" class="headerlink" title="二元运算符重载"></a>二元运算符重载</h4><h5 id="加号重载"><a href="#加号重载" class="headerlink" title="加号重载"></a>加号重载</h5><h6 id="成员函数重载-1"><a href="#成员函数重载-1" class="headerlink" title="成员函数重载"></a>成员函数重载</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Coordinate</span>&#123;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-built_in">Coordinate</span>(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y);<br>    Coordinate <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> Coordinate &amp;coor);	<span class="hljs-comment">//传入的引用只有读权限, 因为我们用不着修改原来的值</span><br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> x;<br>    <span class="hljs-type">int</span> y;<br>&#125;;<br><br>Corrdinate <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> Coordinate &amp;coor)&#123;<br>    Coordinate temp;<br>    temp.x = <span class="hljs-keyword">this</span>-&gt;x + coor.x;<br>    temp.y = <span class="hljs-keyword">this</span>-&gt;y + coor.y;<br>    <span class="hljs-keyword">return</span> temp;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="/Blog/intro/1559409756258.png" srcset="/Blog/img/loading.gif" lazyload alt="1559409756258"></p>
<h6 id="非成员函数重载-1"><a href="#非成员函数重载-1" class="headerlink" title="非成员函数重载"></a>非成员函数重载</h6><p>为什么使用类外函数重载?</p>
<p>如果只进行成员函数重载, 我们可以实现 coor + 5, 即 coor.operator+(5)</p>
<p>但如果我们要使用5+coor, 则会报错, 因为5是int类型, 我们无法重载它的运算符, 让他能与coor相加</p>
<p>因此非成员函数重载便有了意义.</p>
<p>同样并不是必须要使用友元函数, 只要合理地设计类, 就可以避免友元函数的使用, 但通过友元函数可以直接访问类的私有属性</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Coordinate</span>&#123;<br><span class="hljs-keyword">friend</span> Coordinate <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> Coordinate &amp;c1, <span class="hljs-type">const</span> Coordinate &amp;c2);<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-built_in">Coordinate</span>(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y);<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> x;<br>    <span class="hljs-type">int</span> y;<br>&#125;;<br><br>Coordinate <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> Coordinate &amp;c1, <span class="hljs-type">const</span> Coordinate &amp;c2)&#123;<br>    Coordinate temp;<br>    temp.x = c1.x + c2.x;<br>    temp.y = c1.y + c2.y;<br><br>    <span class="hljs-keyword">return</span> temp;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="/Blog/intro/1559410471994.png" srcset="/Blog/img/loading.gif" lazyload alt="1559410471994"></p>
<h5 id="比较运算符重载"><a href="#比较运算符重载" class="headerlink" title="比较运算符重载"></a>比较运算符重载</h5><p>&lt;, &gt;, == … 比较运算符重载时, 甚至+-*/ 等等运算时, 尤其当我们要把类传入set, map等模版类库时,</p>
<p>一定要为函数添加const修饰, 因为他们只是比较, 而不改变内容. 如果不用const修饰, set, map会找不到重载的运算符, 因为他们内部生成的是const对象, 只能调用const函数</p>
<h5 id="lt-lt-号运算符"><a href="#lt-lt-号运算符" class="headerlink" title="&lt;&lt;号运算符"></a>&lt;&lt;号运算符</h5><p>返回值必须是 ostream&amp;, 第一个参数必须是ostream 的引用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Coordinate</span>&#123;<br><span class="hljs-keyword">friend</span> ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream &amp;out, <span class="hljs-type">const</span> Coordinate &amp;c);<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-built_in">Coordinate</span>(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y);<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> x;<br>    <span class="hljs-type">int</span> y;<br>&#125;;<br><br>ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream &amp;out, <span class="hljs-type">const</span> Coordinate &amp;coor)&#123;<br>    out &lt;&lt; coor.x &lt;&lt; <span class="hljs-string">&quot;,&quot;</span> &lt;&lt; coor.y;<br>    <span class="hljs-keyword">return</span> out;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="/Blog/intro/1559411923797.png" srcset="/Blog/img/loading.gif" lazyload alt="1559411923797"></p>
<p>可以看出 cout 就是一个ostream对象</p>
<p><strong>输出运算符可以采用成员函数重载吗?</strong></p>
<p>由于&lt;&lt;重载的必要条件是 第一个参数必须是ostream引用,</p>
<p>但成员函数的第一个对象却是隐性的this指针, 所有输出运算符不能进行重载</p>
<p><br></p>
<p><strong>&lt;&lt; 只能通过友元运算符进行重载</strong></p>
<p><br></p>
<h5 id="索引运算符"><a href="#索引运算符" class="headerlink" title="[] 索引运算符"></a>[] 索引运算符</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Coordinate</span>&#123;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-built_in">Coordinate</span>(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y);<br>	<span class="hljs-type">int</span> <span class="hljs-keyword">operator</span>[](<span class="hljs-type">int</span> index);	<span class="hljs-comment">//索引需要index</span><br><span class="hljs-keyword">private</span>:<br>	<span class="hljs-type">int</span> x;<br>	<span class="hljs-type">int</span> y;<br>&#125;;<br><br><span class="hljs-type">int</span> Coordinate::<span class="hljs-keyword">operator</span> [](<span class="hljs-type">int</span> index)&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span> == index)<br>        <span class="hljs-keyword">return</span> x;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-number">1</span> == index)<br>        <span class="hljs-keyword">return</span> y;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="/Blog/intro/1559413773666.png" srcset="/Blog/img/loading.gif" lazyload alt="1559413773666"></p>
<p><strong>索引运算符可以使用友元函数重载吗?</strong></p>
<p>不能, 因为索引运算符的第一个参数必须是this指针,</p>
<p>而友元函数却可以是其他值</p>
<p><strong><em>索引运算符只能用成员函数重载</em></strong></p>
<p><br></p>
<h2 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h2><p>有时候会有这种情况</p>
<p>函数大体一致, 但是参数不同,导致需要重复写同一份逻辑</p>
<p><img src="/Blog/intro/1559417380744.png" srcset="/Blog/img/loading.gif" lazyload alt="1559417380744"></p>
<p>解决方案是 把类型当做参数</p>
<p><strong>关键字:</strong>  template typename class (这里的class不是定义类的, 而是表明数据类型的, 和typename作用一样)</p>
<h3 id="使用class定义"><a href="#使用class定义" class="headerlink" title="使用class定义:"></a>使用class定义:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-function">T <span class="hljs-title">max</span><span class="hljs-params">(T a, T b)</span></span>&#123;		<span class="hljs-comment">// 函数模板, 如果没有使用, 不会产生任何代码数据</span><br>    <span class="hljs-keyword">return</span> (a &gt; b) ? a : b;<br>&#125;<br><br><span class="hljs-comment">//....</span><br><span class="hljs-comment">//模板函数</span><br><span class="hljs-type">int</span> ival = <span class="hljs-built_in">max</span>(<span class="hljs-number">100</span>, <span class="hljs-number">99</span>);			<span class="hljs-comment">//自动识别数据类型</span><br><span class="hljs-type">char</span> cval = <span class="hljs-built_in">max</span>&lt;<span class="hljs-type">char</span>&gt;(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>);	<span class="hljs-comment">//指定数据类型</span><br></code></pre></td></tr></table></figure>
<h3 id="使用typename定义"><a href="#使用typename定义" class="headerlink" title="使用typename定义:"></a>使用typename定义:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(T&amp; a, T&amp; b)</span></span>&#123;<br>    T tmp = a; a=b; b=tmp;<br>&#125;<br><span class="hljs-comment">//...</span><br><span class="hljs-type">int</span> x=<span class="hljs-number">20</span>, y=<span class="hljs-number">30</span>;<br><span class="hljs-type">void</span> <span class="hljs-built_in">swap</span>&lt;<span class="hljs-type">int</span>&gt;(x, y);<br></code></pre></td></tr></table></figure>
<p><br></p>
<h3 id="变量作为模板参数"><a href="#变量作为模板参数" class="headerlink" title="变量作为模板参数"></a>变量作为模板参数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-type">int</span> size&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span></span>&#123;<br>	cout &lt;&lt; size &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-built_in">display</span>&lt;<span class="hljs-number">10</span>&gt;();<br></code></pre></td></tr></table></figure>
<p><br></p>
<h3 id="多参数函数模板"><a href="#多参数函数模板" class="headerlink" title="多参数函数模板"></a>多参数函数模板</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> C&gt;	<span class="hljs-comment">//typename 不能省略</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">(T&amp; a, C&amp; b)</span></span>&#123;<br>    cout &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot;,&quot;</span> &lt;&lt; b &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-type">int</span> a = <span class="hljs-number">1024</span>; <br>string b = <span class="hljs-string">&quot;hello&quot;</span>;<br><span class="hljs-built_in">display</span>&lt;<span class="hljs-type">int</span>, string&gt;(a,b);<br></code></pre></td></tr></table></figure>
<p><br></p>
<h3 id="混用"><a href="#混用" class="headerlink" title="混用"></a>混用</h3><p>typename 和 class 可以混用:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">class</span> <span class="hljs-title class_">U</span>&gt;<br><span class="hljs-function">T <span class="hljs-title">minus</span><span class="hljs-params">(T* a, U b)</span></span>;<br></code></pre></td></tr></table></figure>
<p>typename 或 class 也可以和变量模板参数混用:</p>
<p><img src="/Blog/intro/1559421288091.png" srcset="/Blog/img/loading.gif" lazyload alt="1559421288091"></p>
<p><br></p>
<h3 id="函数模板与重载"><a href="#函数模板与重载" class="headerlink" title="函数模板与重载"></a>函数模板与重载</h3><p>模板函数本身就有重载的特性</p>
<p>因为我们可以通过指定模板参数来生成不同的函数</p>
<p><br></p>
<p>而如下情况更加复杂:</p>
<p><img src="/Blog/intro/1559421660209.png" srcset="/Blog/img/loading.gif" lazyload alt="1559421660209"></p>
<p><img src="/Blog/intro/1559421726463.png" srcset="/Blog/img/loading.gif" lazyload alt="1559421726463"></p>
<p><br></p>
<h2 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyArray</span>&#123;<br>   <br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span></span>&#123;...&#125;;	<span class="hljs-comment">//类内定义</span><br>	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>;<br><span class="hljs-keyword">private</span>:<br>	T *arr;<br>&#125;;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;		<span class="hljs-comment">//类外定义</span><br><span class="hljs-type">void</span> MyArray&lt;T&gt;::<span class="hljs-built_in">test</span>()&#123;	<br>	<span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p><br></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>, <span class="hljs-type">int</span> size&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Container</span>&#123;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span></span>;<br><span class="hljs-keyword">private</span>:<br>	T obj;<br>&#125;;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>, <span class="hljs-type">int</span> size&gt;			<span class="hljs-comment">//每一个成员函数前面都要加上</span><br><span class="hljs-type">void</span> Container&lt;T, size&gt;::<span class="hljs-built_in">display</span>()&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i &lt; size; i++)&#123;<br>		cout &lt;&lt; obj &lt;&lt; endl;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    Container&lt;<span class="hljs-type">int</span> <span class="hljs-number">10</span>&gt; c;<br>    c.<span class="hljs-built_in">display</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><br></p>
<p><strong>重点: 模板代码不能分离编译, 必须把模板的声明和定义写在 .h 文件中, 不能一个写在.h 一个写在 .cpp中</strong></p>
<p><br></p>
<h2 id="STL-标准模板库"><a href="#STL-标准模板库" class="headerlink" title="STL 标准模板库"></a>STL 标准模板库</h2><p>STL : standard Template lib</p>
<p><br></p>
<h3 id="vector-向量"><a href="#vector-向量" class="headerlink" title="vector 向量"></a>vector 向量</h3><p>向量就是对数组的封装</p>
<p>可以根据存储元素的个数自动变长</p>
<p>特点: 读取能在常数时间内完成</p>
<p><img src="/Blog/intro/1559507167140.png" srcset="/Blog/img/loading.gif" lazyload alt="1559507167140"></p>
<p><img src="/Blog/intro/1559507362989.png" srcset="/Blog/img/loading.gif" lazyload alt="1559507362989"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; vec;<br>    vec.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">10</span>);	<span class="hljs-comment">//在尾部插入元素10</span><br>    vec.<span class="hljs-built_in">push_pop</span>();		<span class="hljs-comment">//把10 抹掉</span><br>    cout &lt;&lt; vec.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i &lt; vec.size; i++)<br>        cout &lt;&lt; vec[i] &lt;&lt; endl;		<span class="hljs-comment">//像数组一样使用</span><br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><br></p>
<h4 id="迭代器-iterator"><a href="#迭代器-iterator" class="headerlink" title="迭代器: iterator"></a>迭代器: iterator</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    vector vec;<br>    vec.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br>    <span class="hljs-comment">// 也可以用auto自动识别类型</span><br>    vector&lt;string&gt;::iterator citer = vec.<span class="hljs-built_in">begin</span>();<br>   <br>    <span class="hljs-keyword">for</span>(; citer!=vec.<span class="hljs-built_in">end</span>();citer++)&#123;<br>        cout &lt;&lt; *citer &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><br></p>
<h3 id="list-链表"><a href="#list-链表" class="headerlink" title="list 链表"></a>list 链表</h3><p>特点:数据插入速度快</p>
<p>成员方法和vector一样</p>
<p>但list不能像vector一样使用 [] </p>
<p><br></p>
<h3 id="map-映射"><a href="#map-映射" class="headerlink" title="map 映射"></a>map 映射</h3><p><img src="/Blog/intro/1559509776738.png" srcset="/Blog/img/loading.gif" lazyload alt="1559509776738"></p>
<p><img src="/Blog/intro/1559510118344.png" srcset="/Blog/img/loading.gif" lazyload alt="1559510118344"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++">map&lt;<span class="hljs-type">int</span>, string&gt; m;<br>   <span class="hljs-function">pair&lt;<span class="hljs-type">int</span>, string&gt; <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;hello&quot;</span>)</span></span>;<br>   <span class="hljs-function">pair&lt;<span class="hljs-type">int</span>, string&gt; <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-number">6</span>, <span class="hljs-string">&quot;world&quot;</span>)</span></span>;<br><br>   m.<span class="hljs-built_in">insert</span>(p1);<br>   m.<span class="hljs-built_in">insert</span>(p2);<br><br>   <span class="hljs-keyword">auto</span> iter = m.<span class="hljs-built_in">begin</span>();<br><span class="hljs-comment">//打印是按索引（key）的顺序打印的，如“A”，先于“B”打印。</span><br>   <span class="hljs-keyword">while</span> (iter!=m.<span class="hljs-built_in">end</span>())&#123;<br>       cout &lt;&lt; iter-&gt;first ;			<span class="hljs-comment">// 不能直接打印</span><br>       cout &lt;&lt; iter-&gt;second &lt;&lt; endl;<br>       iter++;<br>   &#125;<br></code></pre></td></tr></table></figure>
<p><br></p>
<h1 id="C语言相关"><a href="#C语言相关" class="headerlink" title="C语言相关"></a>C语言相关</h1><h2 id="C语言操作文件"><a href="#C语言操作文件" class="headerlink" title="C语言操作文件"></a>C语言操作文件</h2><p>文件类型 FILE* file</p>
<p>打开文件 FILE* fopen(path, mode);</p>
<p>关闭文件 fcolse(FILE*);</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span>&#123;<br>	<br>	FILE* file;<br>	<span class="hljs-type">char</span> buf[<span class="hljs-number">1024</span>] = &#123;<span class="hljs-number">0</span>,&#125;;<br>	<span class="hljs-comment">// a append的意思,往文件里追加内容会添加到文件后面, 游标(可以理解为光标)在文件末尾</span><br>	<span class="hljs-comment">// +	如果文件不存在 则创建, 有则直接打开</span><br>	file = fopen(<span class="hljs-string">&quot;1.txt&quot;</span>,<span class="hljs-string">&quot;a+&quot;</span>);<br><br>	<span class="hljs-comment">// 每个元素大小为1, 有13个元素</span><br>	fwrite(<span class="hljs-string">&quot;hello, World!\n&quot;</span>,<span class="hljs-number">1</span>, <span class="hljs-number">13</span>, file);<br>	<br>	<span class="hljs-comment">//将游标放到文件开头</span><br>	rewind(file);<br><br>    <span class="hljs-comment">//读取文件到 buf 中, 每个元素大小为1, 读取10个</span><br>	fread(buf, <span class="hljs-number">1</span>, <span class="hljs-number">10</span>, file);<br><br>    <span class="hljs-comment">//关闭文件</span><br>	fclose(file);<br><br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;buf:%s\n&quot;</span>, buf);<br><br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><br></p>
<h2 id="C语言内存分配"><a href="#C语言内存分配" class="headerlink" title="C语言内存分配"></a>C语言内存分配</h2><p>分配内存</p>
<p>系统自动分配栈空间内存</p>
<p><br></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//从堆空间里分配</span><br><span class="hljs-type">void</span>* mem = <span class="hljs-built_in">malloc</span>(size);<br><br><span class="hljs-comment">//释放内存</span><br><span class="hljs-built_in">free</span>(men);<br></code></pre></td></tr></table></figure>
<h2 id="函数指针-1"><a href="#函数指针-1" class="headerlink" title="函数指针"></a>函数指针</h2><p>语法:</p>
<p>返回值类型 ( *指针变量名 ) ( [ 形参列表 ] );</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">func</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span>; 	<span class="hljs-comment">// 声明一个函数</span><br><span class="hljs-type">int</span> (*f)(<span class="hljs-type">int</span> x);	<span class="hljs-comment">// 声明一个函数指针</span><br>f = func;		<span class="hljs-comment">// 将func函数的首地址赋值给指针f</span><br> <br></code></pre></td></tr></table></figure>
<p><br></p>
<h2 id="生成自己的函数库并调用"><a href="#生成自己的函数库并调用" class="headerlink" title="生成自己的函数库并调用"></a>生成自己的函数库并调用</h2><p>add.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __MY_LIBRARY__</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __MY_LIBRARY__</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span>&#123;<br>	<span class="hljs-keyword">return</span> a+b;<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure>
<p> 预编译 生成 .o 文件</p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm">gcc -g -<span class="hljs-keyword">c</span> <span class="hljs-keyword">add</span>.<span class="hljs-keyword">c</span><br></code></pre></td></tr></table></figure>
<p><br></p>
<p>整合.o文件 生成 libmylib.a 文件</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">ar -r libmylib.<span class="hljs-keyword">a</span> <span class="hljs-built_in">add</span>.o<br></code></pre></td></tr></table></figure>
<p><br></p>
<p>add.h 头文件</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __MY_LIBRARY__</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __MY_LIBRARY__</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span>;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure>
<p><br></p>
<p>testlib.c     程序入口</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;add.h&quot;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span>&#123;<br>	<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;add=%d\n&quot;</span>, add(<span class="hljs-number">2</span>,<span class="hljs-number">4</span>));<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>编译</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs diff">gcc -g -o testlib testlib.c -I . -L . -lmylib<br><br><span class="hljs-deletion">-I 路径</span><br><span class="hljs-deletion">-L 路径</span><br><span class="hljs-deletion">-l 文件名	-l 会忽略最开始的lib(原名是libmylib, 这里只用写mylib), 没有后缀 </span><br><br><span class="hljs-deletion">-L 和 -l 是进行连接 (链接器), 链接所需要的库</span><br></code></pre></td></tr></table></figure>
<p><br></p>
<h2 id="C语言调试器"><a href="#C语言调试器" class="headerlink" title="C语言调试器"></a>C语言调试器</h2><p>linux 中使用gdb</p>
<p>mac 下使用 lldb</p>
<p><img src="/Blog/intro/1560654681063.png" srcset="/Blog/img/loading.gif" lazyload alt="1560654681063"></p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/Blog/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/Blog/tags/c/">c++</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/Blog/2019/07/02/optimize-sql/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">调优sql</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/Blog/2019/06/29/database-structure/">
                        <span class="hidden-mobile">数据库架构</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/Blog/js/events.js" ></script>
<script  src="/Blog/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/Blog/js/local-search.js" ></script>



  
    <script  src="/Blog/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
        typing(title);
      
    })(window, document);
  </script>





  

  
    <!-- MathJax -->
    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']]
        },
        loader: {
          load: ['ui/lazy']
        },
        options: {
          renderActions: {
            findScript: [10, doc => {
              document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
                const display = !!node.type.match(/; *mode=display/);
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
                const text = document.createTextNode('');
                node.parentNode.replaceChild(text, node);
                math.start = { node: text, delim: '', n: 0 };
                math.end = { node: text, delim: '', n: 0 };
                doc.math.push(math);
              });
            }, '', false],
            insertedScript: [200, () => {
              document.querySelectorAll('mjx-container').forEach(node => {
                let target = node.parentNode;
                if (target.nodeName.toLowerCase() === 'li') {
                  target.parentNode.classList.add('has-jax');
                }
              });
            }, '', false]
          }
        }
      };
    </script>

    <script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js" ></script>

  











<!-- 主题的启动项 保持在最底部 -->
<script  src="/Blog/js/boot.js" ></script>


</body>
</html>
