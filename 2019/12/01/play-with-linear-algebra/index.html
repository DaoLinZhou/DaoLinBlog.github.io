

<!DOCTYPE html>
<html lang="" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/Blog/img/favicon.png">
  <link rel="icon" href="/Blog/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Daolin">
  <meta name="keywords" content="">
  
    <meta name="description" content="bobo老师的 “专为程序员设计的线性代数” 课程的学习笔记 讲的太好了 线性代数入门课">
<meta property="og:type" content="article">
<meta property="og:title" content="&lt;专为程序员设计的线性代数&gt;学习笔记(1)">
<meta property="og:url" content="https://daolinzhou.github.io/Blog/2019/12/01/play-with-linear-algebra/index.html">
<meta property="og:site_name" content="Daolin&#39;s Repository">
<meta property="og:description" content="bobo老师的 “专为程序员设计的线性代数” 课程的学习笔记 讲的太好了 线性代数入门课">
<meta property="og:locale">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/vector1.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/3d_vector2.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/vector2.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/vector_linear_algebra.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/vector_simble_with_origion.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/rl_vector.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/vector_t.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/add_vector.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/understanding_add_vector.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/3d_vector_add.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/nd_vector_add.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/time_vector.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/nd_vector_time.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/vector_operational_properties.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/proof_k_u_v_time.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/proof_k_u_v_time_R.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/zero_vector_proof1.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/zero_vector_proof2.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/def_negative_vector.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/proof_negative_vector_unique.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/negative_vector_1.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/length_of_vec.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/length_of_3d_vec.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/length_of_nd_vec.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/unit_vector.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/infinite_unit_vec.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/standard_unit_vec.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/vector_point_time.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/dot_product_vector.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/proof_dot_product.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/dot_product_vector_fomular.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/visual_understand_vector_dot_product.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/visual_understand_vector_dot_product_2.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/visual_understand_vector_dot_product_3.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/dot_product_vector_fomular.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/use_of_dot_product.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/standard_unit_vector_use.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/use_of_dot_product_similar.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/gometric_use_of_dot_product.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/what_is_matrix.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/how_to_see_matrix.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/3r4cmatrix_example.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/sqare_matrix.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/A_matrix.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/excel_matrix.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/matrix_operation.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/matrix_add.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/matrix_num_product.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/matrix_num_product_example.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/matrix_pro.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/matrix_pro2.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/matrix_a_b.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/matrix_a_b_2.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/excel_matrix.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/econ_system.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/functions.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/net_system.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/electron_system.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/chemistry_system.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/system_and_matrix.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/system_and_matrix2.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/matrix_product_vector.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/matrix_product_vector3.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/matrix_product_vector4.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/matrix_product_vector5.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/matrix_product_vector6.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/matrix_product_vector7.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/matrix_product_vector5.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/dot_product_and_matrix_product.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/matrix_product_vector5.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/matrix_function.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/matrix_num_product_example.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/matrix_product_matrix_1.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/matrix_product_matrix_2.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/matrix_for_point.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/matrix_product_matrix_2.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/matrix_product_matrix_3.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/matrix_product_matrix_4.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/def_matrix_product.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/def_matrix_product_2.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/def_matrix_product_3.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/matrix_product_property.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/proof_matrix_property.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/a_to_pow_k.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/matrix_pow_zero_ne.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/matrix_product_trap.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/matrix_transaction.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/matrix_ele_transpose.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/property_transpose_matrix.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/example_matrix_transform.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/transform_a_b.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/flip_graph_by_matrix.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/find_matrix_filping.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/abcd_T_matrix.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/product_abcd_T_vector.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/flip_solution_T.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/flip_about_y.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/flip_about_O.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/tx_ty_flip_about_O.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/shear_example.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/shear_example_solution.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/shear_example_solution2.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/shear_example_y.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/routing_matrix.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/routing_matrix_0.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/routing_matrix_1.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/find_matrix_after_routing.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/find_matrix_after_routing_1.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/find_matrix_after_routing_2.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/find_matrix_after_routing_3.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/find_matrix_after_routing_4.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/find_matrix_after_routing_5.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/find_matrix_after_routing_6.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/find_matrix_after_routing_7.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/find_matrix_after_routing_8.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/find_matrix_after_routing_9.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/uni_matrix.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/uni_matrix_1.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/uni_matrix_2.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/uni_matrix_3.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/def_uni_matrix.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/property_uni_matrix_1.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/property_uni_matrix_2.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/property_uni_matrix_3.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/inverse_x_number_sys.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/inverse_matrix.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/example_non_singular_matrix.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/lr_singular_matrix.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/inverse_matrix.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/inverse_matrix.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/property_inv_A.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/property_inv_A_B.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/property_inv_A_B_2.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/property_inv_A_B_3.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/property_inv_A_B_4.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/property_inv_A_B_5.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/matrix_product_with_vector.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/matrix_product_with_vector_c.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/understand_matrix_product_vector_col.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/example_col_product.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/show_col_product.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/example_standard_unit_vector_2d.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/show_col_product.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/relationship_suv_dot.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/fomular_product.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/graph_col_pov_matrix_product.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/graph_col_pov_matrix_product_2.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/graph_col_pov_matrix_product_3.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/matrix_pov_space.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/matrix_grid.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/matrix_grid_1.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/matrix_grid_2.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/matrix_grid_3.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/matrix_grid_4.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/matrix_grid_5.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/matrix_grid_6.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/matrix_filp_npov.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/matrix_filp_npov_1.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/matrix_filp_npov_2.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/F_rout.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/F_grid_sys.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/F_grid_sys_2.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/F_grid_sys_3.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/F_grid_sys_4.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/excel_matrix.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/system_and_matrix2.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/system_and_matrix_3.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/func_vector.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/transform_vec.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/matrix_grid_1.PNG">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/matrix_grid_6.PNG">
<meta property="article:published_time" content="2019-12-02T05:06:48.000Z">
<meta property="article:modified_time" content="2019-12-19T19:26:09.727Z">
<meta property="article:author" content="Daolin">
<meta property="article:tag" content="数学">
<meta property="article:tag" content="线性代数">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://daolinzhou.github.io/Blog/intro/vector1.PNG">
  
  
  <title>&lt;专为程序员设计的线性代数&gt;学习笔记(1) - Daolin&#39;s Repository</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/Blog/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"daolinzhou.github.io","root":"/Blog/","version":"1.8.14","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/Blog/local-search.xml"};
  </script>
  <script  src="/Blog/js/utils.js" ></script>
  <script  src="/Blog/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 6.1.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/Blog/">
      <strong>Fluid</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/Blog/">
                <i class="iconfont icon-home-fill"></i>
                Home
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/Blog/archives/">
                <i class="iconfont icon-archive-fill"></i>
                Archives
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/Blog/categories/">
                <i class="iconfont icon-category-fill"></i>
                Categories
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/Blog/tags/">
                <i class="iconfont icon-tags-fill"></i>
                Tags
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/Blog/about/">
                <i class="iconfont icon-user-fill"></i>
                About
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/Blog/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="&lt;专为程序员设计的线性代数&gt;学习笔记(1)">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2019-12-01 21:06" pubdate>
        December 1, 2019 pm
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      undefined 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      NaN 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">&lt;专为程序员设计的线性代数&gt;学习笔记(1)</h1>
            
            <div class="markdown-body">
              <blockquote>
<p>bobo老师的 “专为程序员设计的线性代数” 课程的学习笔记</p>
<p>讲的太好了</p>
<p>线性代数入门课</p>
</blockquote>
<span id="more"></span>

<h1 id="一切从向量开始"><a href="#一切从向量开始" class="headerlink" title="一切从向量开始"></a>一切从向量开始</h1><blockquote>
<p>github : </p>
<p>python版本 : <a target="_blank" rel="noopener" href="https://github.com/DaoLinZhou/learning-linear-algebra">https://github.com/DaoLinZhou/learning-linear-algebra</a></p>
<p>以后可能会实现相应的c++和java版本</p>
</blockquote>
<br>

<h2 id="什么是向量"><a href="#什么是向量" class="headerlink" title="什么是向量"></a>什么是向量</h2><br>

<h3 id="为什么要引入向量"><a href="#为什么要引入向量" class="headerlink" title="为什么要引入向量"></a>为什么要引入向量</h3><p>为什么线性代数这么重要? </p>
<ul>
<li>因为它把数学从只 <strong>研究一个一个数</strong> 拓展到 <strong>研究一组数</strong>, 这使得表达多维度的世界变得非常方便</li>
</ul>
<p>如何来表达一组数?  –  向量 (vector)</p>
<p>向量 (vector) 是线性代数研究的基本元素</p>
<p>一个数: 666 ,      一组数: (6, 66, 666)</p>
<br>

<p>那么研究一组数究竟有什么用?  最根本的出发点: 表示方向</p>
<p>例如:</p>
<p>从同样的一个起始点走5000米很可能会达到不同的终止点</p>
<p>为了简单, 省略 * 1000</p>
<p><img src="/Blog/intro/vector1.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<p>第一个终点的位置表示为: (4, 3)</p>
<p>第二个终点的位置表示为: (4.6, 1)</p>
<p>就是说, 需要使用两个数才能准确表达出这两个位置的不同, 这就是因为我们引入了 <strong>方向</strong> 这一概念</p>
<p>同样从起始点出发, 同样走5000米, 但方向有偏差最后得到的终止点就会不一样</p>
<br>

<p>而这同样适用与三维(高维)</p>
<p><img src="/Blog/intro/3d_vector2.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<br>

<p>这个例子只是物理中位移的例子, 但实际上, 位移, 速度, 加速度, 力…都是有<strong>方向</strong>这个概念的, 我们只看它们的大小是不够的, 片面的. </p>
<p>为了更加准确地看到这些物理量表达的真实的物理含义, <strong>必须要考虑它的方向</strong></p>
<br>

<h3 id="为什么基于原点"><a href="#为什么基于原点" class="headerlink" title="为什么基于原点"></a>为什么基于原点</h3><p>难道我们在研究向量的过程中只考虑方向吗? </p>
<p>例如: 起始点也是一个因素, 那么起始点不重要吗?</p>
<p><img src="/Blog/intro/vector2.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<p>恕我直言, 在向量的研究中的确不重要</p>
<br>

<p>我们当然可以从(-1, -1)出发, 达到(3, 2),  但是在线性代数的世界中, 我们认为它等价于从(0, 0) 出发, 抵达(4, 3)</p>
<p>因为这两个的区别在于坐标系的不同, 换句话说这两个的不同在于我们认为哪里是原点</p>
<p>向量只表征从一个点到另外一个点相应的结果, 而不区分是从哪个起始点出发的, 所以为了方便默认统一从原点出发</p>
<p>再思考一下, 再基础数学的学习中, 数轴上的所有点都是基于0来说的, 说一个数字是6是因为它距离0这一点的距离为6, 而不会认为6到-1的间隔为7而产生疑问: 为什么不将他表示为7. </p>
<p>对于向量来说也是同理的, 每一个向量都是基于原点, 从原点出发的 </p>
<br>

<h3 id="顺序很重要"><a href="#顺序很重要" class="headerlink" title="顺序很重要"></a>顺序很重要</h3><p>同样以上面的例子来说, (4, 3) 和 (3, 4) 截然不同</p>
<p><strong>向量是一组有序的数</strong></p>
<br>

<h3 id="N维向量"><a href="#N维向量" class="headerlink" title="N维向量"></a>N维向量</h3><p>向量如果只是用来表示方向, 最多三个维度就够了</p>
<p>更加抽象的 : n维向量</p>
<p>虽然高维空间人们无法直观感受到, 但人们经常用高维空间的角度来描述事物, 我们经常说要从不同的角度刻画一个事情, 而这不同的角度就是不同的维度</p>
<p>例如:</p>
<table>
<thead>
<tr>
<th align="center">面积</th>
<th align="center">卧室</th>
<th align="center">卫生间</th>
<th align="center">最近地铁站(km)</th>
<th align="center">价格(万)</th>
</tr>
</thead>
<tbody><tr>
<td align="center">120</td>
<td align="center">3</td>
<td align="center">2</td>
<td align="center">2</td>
<td align="center">666</td>
</tr>
</tbody></table>
<p>刻画一个房子, 我们可以从这些角度来刻画它,</p>
<p> (120, 3, 2, 2, 666) 每一个数字都是一个维度, 我们使用5个维度的向量刻画一个一个的房屋</p>
<p>此时, 向量就是一组数, 这组数的含义由使用者定义</p>
<br>

<p>如果调换最后两个数 2, 666. 那么它表示的就是一个房子离地铁站666km, 价格2万, 再一次说明向量是有顺序性的</p>
<br>

<h3 id="看待向量的两个视角"><a href="#看待向量的两个视角" class="headerlink" title="看待向量的两个视角"></a>看待向量的两个视角</h3><ol>
<li>把向量看作时一个方向 ( 更准确地说, 方向和大小 例如 (4, 3) 和 (8,6)是同一个方向的 )</li>
<li>把向量仅仅看作时一组有序的数字, 而它是高维空间中的一个数据点, 例如: 把上面的五维向量看作是在一个有5个维度坐标轴的空间中的一个点, 每个维度坐标轴的取值都是正无穷到负无穷</li>
</ol>
<p>而这两个视角看似不同, 但却可以相互转换, 这是因为一个方向, 就是一个点</p>
<p>前面也说过, 向量默认统一从原点出发, 因此</p>
<p>空间中的任意一点, 都可以看作是从原点指向这个点的一个方向</p>
<br>

<p>更为关键的是: 这两个视角, 都不是简单的”一组数”, 我们在看待向量时, 是把它和<strong>空间</strong>联系起来的</p>
<p>对于第一个视角 : 我们把向量看作是<strong>一个有向线段</strong></p>
<p>对于第二个视角 : 我们把向量看作时<strong>一个空间中的点</strong></p>
<p>这两个视角都具有一定的几何意义, 而不仅仅是数字的堆叠</p>
<br>

<h2 id="向量的更多术语和表示法"><a href="#向量的更多术语和表示法" class="headerlink" title="向量的更多术语和表示法"></a>向量的更多术语和表示法</h2><p>更严格的一些定义: </p>
<ul>
<li><p>和向量相对应, 一个数字, 成为<strong>标量</strong></p>
</li>
<li><p>代数, 用符号代表数. 和标量相区别, 向量的符号画箭头 <img src="/Blog/intro/vector_linear_algebra.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
</li>
</ul>
<p>前面也说过, 在线性代数里, 我们是不考虑起始点的, 但由于线性代数<strong>应用广泛</strong>, 在一些应用中, 起始点可能是重要的</p>
<p>个别情况下, 尤其是<strong>几何学</strong>中, 我们会考虑向量的起始点, 因此我们会在起始点和终止点上画箭头</p>
<p><img src="/Blog/intro/vector_simble_with_origion.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<br>

<h3 id="行向量和列向量"><a href="#行向量和列向量" class="headerlink" title="行向量和列向量"></a>行向量和列向量</h3><p><img src="/Blog/intro/rl_vector.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<p>左边是行向量, 右边是列向量, 在下一章讲解矩阵时有重大作用</p>
<p>通常教材, 论文, 提到向量, 都指的是列向量</p>
<p>由于横版印刷原因, 有的书可能使用符号: (3, 4)<em>T</em></p>
<p><img src="/Blog/intro/vector_t.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<p>T其实是运算符号, 表示的是把这个向量进行一下<strong>转置</strong>的操作, 可以简单理解为把行向量颠倒90度成为一个列向量</p>
<br>

<h2 id="向量的两个基本运算"><a href="#向量的两个基本运算" class="headerlink" title="向量的两个基本运算"></a>向量的两个基本运算</h2><h3 id="向量加法"><a href="#向量加法" class="headerlink" title="向量加法"></a>向量加法</h3><p>两个向量之间的运算        </p>
<br>

<p>例如: (5, 2)T + (2, 5)T &#x3D; ? </p>
<p>在物理中, 有这样一个原则 : 两个向量相加, 他们的和是以a, b 为边所组成的<strong>平行四边形的对角线</strong>的终点</p>
<p><img src="/Blog/intro/add_vector.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<p>为什么?</p>
<p>可以看出, 我们先向x移动5个单位, 再想y移动2个单位</p>
<p>​                         再向x移动2个单位, 再向y移动5个单位</p>
<p>同样反过来也是可以的. 这样虚线和实线就形成了一个平行四边形</p>
<p><img src="/Blog/intro/understanding_add_vector.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<br>

<p>从数值的角度讲:</p>
<p>(5, 2)T + (2, 5)T &#x3D; (7, 7)T</p>
<p>总共向x移动7个单位, 总共向y移动7个单位</p>
<p><strong>两个向量相加的结果, 是将这两向量中每一个分量分别相加组合成的向量</strong></p>
<p>(a,b)T + (c, d)T &#x3D; (a+c, b+d)T</p>
<br>

<p>三维(多维)空间同理</p>
<p><img src="/Blog/intro/3d_vector_add.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<p><img src="/Blog/intro/nd_vector_add.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<br>

<h3 id="数量乘法"><a href="#数量乘法" class="headerlink" title="数量乘法"></a>数量乘法</h3><p>一个<strong>标量</strong>和一个向量之间的运算</p>
<br>

<p>例如: 2 * (5, 2)T &#x3D; ?</p>
<p>乘法本身是多次的加法, n * 3 代表 n 个 3 相加</p>
<p>而这个基本思想同样可以应用在向量的数量乘法中</p>
<p>2 * (5, 2) &#x3D; (5, 2) + (5, 2) &#x3D; (10, 4)</p>
<p><img src="/Blog/intro/time_vector.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<br>

<p>抽象一点 : k * (a, b)T &#x3D; ?</p>
<p>向 x 移动 k 次 a 个单位, 向 y 移动 k 次 b 个单位</p>
<p>总共向 x 移动 ka 个单位, y 移动 kb 个单位</p>
<p> k * (a, b)T &#x3D; (ka, kb)T</p>
<br>

<p>n维同理</p>
<p><img src="/Blog/intro/nd_vector_time.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<br>

<h2 id="向量基本运算的性质"><a href="#向量基本运算的性质" class="headerlink" title="向量基本运算的性质"></a>向量基本运算的性质</h2><p><img src="/Blog/intro/vector_operational_properties.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<p>看起来很白痴, 但其实很重要.</p>
<p>举个例子, 两个string, s1, s2.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s1 + s2 != s2 + s1</span><br></pre></td></tr></table></figure>

<p>而且这些基本性质并不是以定义的形式出现, 而是可以通过严谨的数学证明来证明出来的</p>
<br>

<p>例子: 证明 k(u + v) &#x3D; ku + kv , u 和 v 是向量</p>
<p>我们目前可以使用的 ( 定理 ? 定义 ) </p>
<ul>
<li>向量加法</li>
<li>数量乘法</li>
</ul>
<p>假设 u 和 v 是 n 维向量</p>
<br>

<p><strong>等式左边</strong></p>
<p><img src="/Blog/intro/proof_k_u_v_time.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<p>由于un, vn 都是一个一个数, 所以可以直接相乘</p>
<br>

<p><strong>等式右边</strong></p>
<p><img src="/Blog/intro/proof_k_u_v_time_R.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<p>左边 &#x3D;&#x3D; 右边, 证明成功</p>
<p>同样其余的性质也可以只使用向量加法和数量乘法来进行证明, 由于过于简单, 所以这里就不再赘述了</p>
<br>

<h2 id="零向量和负向量"><a href="#零向量和负向量" class="headerlink" title="零向量和负向量"></a>零向量和负向量</h2><h3 id="零向量"><a href="#零向量" class="headerlink" title="零向量"></a>零向量</h3><p>我们不定义什么是零向量, 我们从推导出一个性质出发</p>
<p>对于任意一个向量u, 都存在一个向量O, 满足 u + O &#x3D; u</p>
<br>

<h4 id="证明-零向量存在"><a href="#证明-零向量存在" class="headerlink" title="证明: 零向量存在"></a>证明: 零向量存在</h4><p><img src="/Blog/intro/zero_vector_proof1.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<p> <img src="/Blog/intro/zero_vector_proof2.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<p>既然我们已经求出来了向量O, 那么就说明零向量是存在的</p>
<br>

<p>我们证明出了向量O的存在性, 进而我们<strong>称</strong>这个向量为零向量</p>
<p>我们不是直接定义的, 而是首先被我们证明一定存在, 而在证明它存在的过程中, 顺手把它的样子求出来了</p>
<br>

<h4 id="为什么没有零向量箭头"><a href="#为什么没有零向量箭头" class="headerlink" title="为什么没有零向量箭头"></a>为什么没有零向量箭头</h4><p><strong>注意: 这个零向量O没有箭头</strong></p>
<br>

<p>当我们以方向这一个视角看待向量时, 那么一个向量就可以理解为 : <strong>从坐标原点指向这个向量所代表的数据点的有限的线段</strong></p>
<p>而原点, 显然就是各个维度都为0的这一点</p>
<p>而如果使用这样的定义来看待零向量的话, 零向量就是 : <strong>从坐标原点又指向自身</strong></p>
<p>而显然这不是一个线段, 它是一个点, 因此我们不能说它的方向是在哪里</p>
<br>

<p>我们称呼它为零向量只是为了称呼上的统一, 但它本质其实是没有方向的, 它本质是一个点, 在整个坐标系的原点</p>
<br>

<h4 id="零向量和零"><a href="#零向量和零" class="headerlink" title="零向量和零"></a>零向量和零</h4><p>另外, 我们没有说零向量有多少个0, 而它有多少个0是根据当前所研究的空间所决定的</p>
<p>所以, 零向量和数字0还是有所区别的, 因为数字0是唯一的数字, 而零向量可以<strong>在维度上进行扩充,</strong> 在不同的空间中有唯一的一个0向量</p>
<p>不过通常我们在研究问题时, 都会限定空间, 所以一般不用特别强调零向量的维度, 在问题的语义中我们自然可以理解讨论的零向量是谁</p>
<br>

<h3 id="负向量"><a href="#负向量" class="headerlink" title="负向量"></a>负向量</h3><p>而在我们定义好零向量之后, 就可以定义 “负” 这个概念了</p>
<p><img src="/Blog/intro/def_negative_vector.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<br>

<h4 id="证明-上述-u-唯一"><a href="#证明-上述-u-唯一" class="headerlink" title="证明: 上述 -u 唯一"></a>证明: 上述 -u 唯一</h4><p>反证法 : 假设负向量不唯一, 则存在另一个向量 v, v !&#x3D; -u, 也满足 u + v &#x3D; O</p>
<p><img src="/Blog/intro/proof_negative_vector_unique.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<p>和假设矛盾, 说明假设错误: -u唯一</p>
<blockquote>
<p>在(计算机领域 &#x2F;  离散数学), 反证法和数学归纳法是经常被使用的两种证明方法, 在证明问题上如果没有思路可以尝试从这两个方法上寻找突破口</p>
</blockquote>
<br>

<h4 id="证明-u-x3D-1-u"><a href="#证明-u-x3D-1-u" class="headerlink" title="证明: -u &#x3D; -1 * u"></a>证明: -u &#x3D; -1 * u</h4><p><img src="/Blog/intro/negative_vector_1.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<p>等式左右同时加上 <strong>u</strong></p>
<p><strong>u</strong> + (<strong>-u</strong>) &#x3D; -1 * <strong>u</strong> + <strong>u</strong></p>
<p>左边, 根据负向量的定义 &#x3D; O</p>
<p>右边, 根据数量乘法和向量加法 &#x3D; O</p>
<p>左边等于右边, 所以是正确的</p>
<br>

<h2 id="向量的长度和单位向量"><a href="#向量的长度和单位向量" class="headerlink" title="向量的长度和单位向量"></a>向量的长度和单位向量</h2><p> 我们可以把向量看作是一个有向的线段, 从原点指向空间中的某一个点, </p>
<p>既然它是一个有向的线段, 那么它除了<strong>方向</strong>也有<strong>大小</strong></p>
<p>所以在我们看待向量的时候, 除了看待方向之外, 还有一个问题, 它的大小是多少</p>
<br>

<h3 id="向量的模"><a href="#向量的模" class="headerlink" title="向量的模"></a>向量的模</h3><br>

<h4 id="二维向量的模"><a href="#二维向量的模" class="headerlink" title="二维向量的模"></a>二维向量的模</h4><p><img src="/Blog/intro/length_of_vec.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<p>在二维的空间中, 实际上求的是原点到向量所代表的点的<strong>欧拉距离</strong>, 而欧拉距离在数学中又被成为<strong>二范数</strong></p>
<br>

<h4 id="三维向量的模"><a href="#三维向量的模" class="headerlink" title="三维向量的模"></a>三维向量的模</h4><p><img src="/Blog/intro/length_of_3d_vec.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<p>依然可以表达成: <strong>这个向量在坐标轴上每一个分量的平方和再开根</strong></p>
<br>

<h4 id="n维向量的模"><a href="#n维向量的模" class="headerlink" title="n维向量的模"></a>n维向量的模</h4><p><img src="/Blog/intro/length_of_nd_vec.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<br>

<h3 id="单位向量-unit-vector"><a href="#单位向量-unit-vector" class="headerlink" title="单位向量 unit vector"></a>单位向量 unit vector</h3><p>长度为<strong>固定的一个单位</strong></p>
<br>

<p><strong>求单位向量的方法</strong></p>
<p><img src="/Blog/intro/unit_vector.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<p>单位向量的模永远等于1, 它的长度已经不重要了, 单位向量重要的在于: 它只表示方向</p>
<br>

<p>当我们将向量看作是有向的线段的时候, 我们把它的<strong>大小和方向</strong>拆开了</p>
<p>大小可以由<strong>向量的模</strong>来表示, 方向可以由<strong>单位向量</strong>来表示</p>
<br>

<p><strong>单位向量有无数多个</strong></p>
<p>例如在二维中以原点为圆心, 画一个半径为1的圆, 原点到圆上的任意一点都是一个单位向量. 而在二维空间中, 有两个特殊的单位向量, 下图用蓝色标记出来</p>
<p><img src="/Blog/intro/infinite_unit_vec.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<p>约定俗成: 标准单位向量被记为e</p>
<p>因为单位向量的模固定是1, 更近一步, 在标准单位向量中, 只能有一个维度的值为1, 其他维度的值都应该为0</p>
<br>

<p><img src="/Blog/intro/standard_unit_vec.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<p>标准单位向量是很重要的<strong>一组</strong>向量</p>
<p>由于所有单位向量都指向坐标轴的正方向, 我们甚至可以说, 我们整个坐标系是由这些标准单位向量所组建的</p>
<br>

<blockquote>
<ol>
<li></li>
</ol>
<p>“标准单位向量指向的是正方向，那么负方向的岂不是也很重要？”</p>
<p>负方向不重要了。因为 e1 是正方向的话，-e1 就是负方向。我们可以很容易的靠正方向找到负方向。</p>
<p>相反，e2 这个方向很重要，因为，我们用 e1 表达不了 e2 这个方向。e2 这个方向蕴含着 e1 不包含的新信息</p>
<ol start="2">
<li></li>
</ol>
<p>“为什么会说整个空间是标准单位所组建的？我理解的不是应该也会存在负半轴吗？”</p>
<p>就是因为整个空间的任何一个向量，都可以使用标准单位向量表示。包括你所说的负半轴的任何向量。</p>
<p>从初等数学的角度理解，就是定义了 x y 两个轴，平面上的任何一个点，就能在这个坐标系中找到相应的位置了。</p>
</blockquote>
<br>

<h2 id="向量的点乘与几何意义"><a href="#向量的点乘与几何意义" class="headerlink" title="向量的点乘与几何意义"></a>向量的点乘与几何意义</h2><p><img src="/Blog/intro/vector_point_time.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<p>两个向量 “相乘”, 结果是一个数(标量)</p>
<p>更严格的说法, 这是<strong>两个向量的点乘</strong>(dot product), 或者成为<strong>两个向量的内积</strong>(inner product)</p>
<br>

<p>而在<strong>几何</strong>上它等于 </p>
<p><img src="/Blog/intro/dot_product_vector.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<p>u的模乘以v的模, 再乘以cosθ, θ等于u和v两个向量之间的夹角</p>
<br>

<h3 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h3><p><img src="/Blog/intro/proof_dot_product.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<p>这个结论同样可以拓展到n维空间</p>
<br>

<h2 id="向量点乘的直观理解"><a href="#向量点乘的直观理解" class="headerlink" title="向量点乘的直观理解"></a>向量点乘的直观理解</h2><p><img src="/Blog/intro/dot_product_vector_fomular.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<h3 id="右侧"><a href="#右侧" class="headerlink" title="右侧"></a>右侧</h3><br>

<p><img src="/Blog/intro/visual_understand_vector_dot_product.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<p>对于向量v 向 向量u作垂线, 将v这个向量<strong>投影</strong>到向量u中 ( 蓝色线段 ) , 而此时这条蓝色线段的长度<strong>正好等于</strong>向量v的模乘以cosθ, 因此我们可以把等式中的这两个合在一起看待</p>
<p>即: 把向量v投影到向量u之后, 投影向量的大小再乘以u的大小</p>
<br>

<p>也就是向量的点乘通过投影的方式让两个向量都指向同一个方向</p>
<p>向量的点乘在想办法处理向量是<strong>具有方向性</strong>这件事情, 它认为不同方向的两个向量不能<strong>直接做乘法</strong>, 因此把一个向量投影到另外一个向量上, 让他们<strong>指向同一个方向</strong>后再作乘法, 此时这两个向量的相乘就有意义了</p>
<br>

<p>同理可以把u投影到v上</p>
<p><img src="/Blog/intro/visual_understand_vector_dot_product_2.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<br>

<h3 id="左侧"><a href="#左侧" class="headerlink" title="左侧"></a>左侧</h3><br>

<p>除了把 u 投影到 v 上, 或者把 v 投影到 u 上.</p>
<p>我们还可以把 u 和 v 这两个向量分解投影到 x轴 和 y轴 上</p>
<p><img src="/Blog/intro/visual_understand_vector_dot_product_3.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<p>每个向量都有两个分量, 很自然地, 每一个分量都应该和另外一个向量的两个分量相乘, 排列组合之后, 我们一共要做4次乘法</p>
<ol>
<li>x1x2</li>
<li>y1y2</li>
<li>x1y2</li>
<li>x2y1</li>
</ol>
<p>由于x1y2是垂直的关系, 根本不在一个方向上, 且由于垂直, x1对y2没有一点影响, 二者完全没有关系, 所以我们认为这二者结合起来是0, x2y1同理</p>
<p>只有同方向的数值相乘才是有意义的</p>
<br>

<p>无论左侧(<strong>数值表达式</strong>) 还是 右侧(<strong>几何表达式</strong>), 其实都表示要将这两个向量它们的<strong>方向从某种程度上统一</strong>, 或者统一到一个方向, 或者把它们都映射到坐标轴上看看每个轴上做乘法是怎么样的最终把它们加起来</p>
<br>

<h2 id="向量点乘的应用"><a href="#向量点乘的应用" class="headerlink" title="向量点乘的应用"></a>向量点乘的应用</h2><p><img src="/Blog/intro/dot_product_vector_fomular.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<p>通过这个式子可以求出两个向量的夹角是多少, 在线性代数中, 判断两个向量<strong>相互垂直</strong>十分重要</p>
<p><img src="/Blog/intro/use_of_dot_product.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<p>无论是解析几何还是计算几何, 判断两个向量之间的夹角本身也是很重要的一个步骤</p>
<br>

<p>回忆标准单位向量:</p>
<p><img src="/Blog/intro/standard_unit_vector_use.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<p>可以看到, 不同的标准单位向量进行点乘后结果都为0, 说明他们垂直</p>
<p>推广到n维空间中, n个标准单位向量一定是两两互相垂直, 这也是<strong>坐标轴</strong>这个概念的意义: 在n维空间中, n个坐标轴是两两垂直的</p>
<br>

<h3 id="相似度-推荐系统"><a href="#相似度-推荐系统" class="headerlink" title="相似度(推荐系统)"></a>相似度(推荐系统)</h3><p><img src="/Blog/intro/use_of_dot_product_similar.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<p>如果是锐角, 就说明是相似; 垂直, 说明他们无关; 钝角则说明他们是背离的</p>
<br>

<p>除了夹角, 我们还可以看点乘后的值</p>
<p>当两个向量完全重合时, <strong>投影</strong>将不会产生任何损耗, 因此会达到最大值</p>
<p>而如果他们是相反的, 那么点乘的结果是负值, 并且这个负值将是最小值</p>
<p>点乘的值越大, 两个数据点 (以空间中的点看待向量) 越相似; 值越小, 越不一样</p>
<br>

<blockquote>
<p> 实际上，当我们说<strong>两个向量的点乘越大，相似度越高时（有的时候也会说：两个向量之间的夹角越小，相似度越高）</strong>，是不考虑向量的大小的。或者，你可以理解成：两个向量的长度是固定的 </p>
<p>另外参考: 余弦相似性 <a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2013/03/cosine_similarity.html">http://www.ruanyifeng.com/blog/2013/03/cosine_similarity.html</a></p>
</blockquote>
<p>当然现在的推荐系统有更多更加准确的算法, 点乘只能提供一个参考信息</p>
<br>

<h3 id="几何计算"><a href="#几何计算" class="headerlink" title="几何计算"></a>几何计算</h3><p>计算投影点的坐标</p>
<p><img src="/Blog/intro/gometric_use_of_dot_product.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<br>

<br>

<br>

<h1 id="矩阵不止是-m-n-个数字"><a href="#矩阵不止是-m-n-个数字" class="headerlink" title="矩阵不止是 m*n 个数字"></a>矩阵不止是 m*n 个数字</h1><br>

<h2 id="什么是矩阵"><a href="#什么是矩阵" class="headerlink" title="什么是矩阵"></a>什么是矩阵</h2><h3 id="矩阵-Matrix"><a href="#矩阵-Matrix" class="headerlink" title="矩阵 Matrix"></a>矩阵 Matrix</h3><p><img src="/Blog/intro/what_is_matrix.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<p>那么矩阵表达怎样的一组向量呢? 这组向量一共有几个向量, 每个向量分别是什么?</p>
<p>由于我们看待矩阵的<strong>视角</strong>不一样, 应用场景不一样, 所有通常会有不同的看待方式.</p>
<p>具体在实际应用一个矩阵的时候怎么去看待它是一个非常有意思的话题</p>
<p>不过整体来说, 如果非常宽泛地回答这个问题, 我们可以有两个视角来看待矩阵</p>
<p><img src="/Blog/intro/how_to_see_matrix.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<ul>
<li>一行一行地看, 上述矩阵是由4个行向量组成的</li>
<li>一列一列地看,  上述矩阵是由4个列向量组成的 (这种视角通常更有用)</li>
</ul>
<br>

<p>矩阵的行数和列数可以不一样</p>
<p><img src="/Blog/intro/3r4cmatrix_example.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<br>

<p>对于行数和列数一样的矩阵我们称为<strong>方阵</strong></p>
<p><img src="/Blog/intro/sqare_matrix.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<br>

<p>代数, 就是用字母代表数, 通常我们使用<strong>大写字母代表矩阵</strong>, 矩阵中的每一个元素通常都用和大写字母相对应的小写字母来表示, 由小写字母的下标来表示所对应的行数和列数 </p>
<p><img src="/Blog/intro/A_matrix.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<br>

<p><strong>表格就是矩阵</strong></p>
<p><img src="/Blog/intro/excel_matrix.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<p>每一个行向量就代表每一个人各个科目的成绩</p>
<p>每一个列向量就代表每一个科目不同的人的成绩</p>
<br>

<p>在线性代数的世界中, 一个矩阵除了可以这样显示的表示一组数据之外, 还可以表示更加抽象的内容: 比如表示一组变换, 或表示一组空间, 而这些内容才是线性代数更加关注的内容</p>
<br>

<h2 id="矩阵的基本运算和基本性质"><a href="#矩阵的基本运算和基本性质" class="headerlink" title="矩阵的基本运算和基本性质"></a>矩阵的基本运算和基本性质</h2><p><img src="/Blog/intro/matrix_operation.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<h3 id="矩阵的基本运算"><a href="#矩阵的基本运算" class="headerlink" title="矩阵的基本运算"></a>矩阵的基本运算</h3><h4 id="矩阵加法"><a href="#矩阵加法" class="headerlink" title="矩阵加法"></a>矩阵加法</h4><p><img src="/Blog/intro/matrix_add.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<br>

<h4 id="矩阵数量乘法"><a href="#矩阵数量乘法" class="headerlink" title="矩阵数量乘法"></a>矩阵数量乘法</h4><p><img src="/Blog/intro/matrix_num_product.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<p>例子: </p>
<p>矩阵表示一组向量, 每个向量又可以表示空间中的一个点, 假设以行向量的视角来看待这个矩阵 P , 每个行向量都代表二维平面上的一个点, P 这个矩阵便定义了二维平面上的一个三角形</p>
<p><img src="/Blog/intro/matrix_num_product_example.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<p>而对这个矩阵进行数量乘法之后所得到的新的三角形, 感觉就像是在原来 P 所对应的三角形的基础上进行了缩放</p>
<p>可以看出矩阵的运算在图形学上有很多应用</p>
<br>

<h3 id="通过矩阵的基本运算可以推导出来的基本性质"><a href="#通过矩阵的基本运算可以推导出来的基本性质" class="headerlink" title="通过矩阵的基本运算可以推导出来的基本性质"></a>通过矩阵的基本运算可以推导出来的基本性质</h3><p><img src="/Blog/intro/matrix_pro.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<p><img src="/Blog/intro/matrix_pro2.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<br>

<p><strong>举例: 证明 k * ( A + B ) &#x3D; k * A + k * B</strong></p>
<p>假设, A, B 都是 r * c 矩阵</p>
<p><img src="/Blog/intro/matrix_a_b.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<br>

<p>这样就可以分别表示等式左边的部分和等式右边的部分</p>
<p><img src="/Blog/intro/matrix_a_b_2.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<br>

<p>这两个矩阵每一个对应的位置都是相等的, 说明这两个矩阵本身是相等的</p>
<br>

<h2 id="把矩阵看作是对系统的描述"><a href="#把矩阵看作是对系统的描述" class="headerlink" title="把矩阵看作是对系统的描述"></a>把矩阵看作是对系统的描述</h2><p>为了更加深刻地理解什么是矩阵的乘法, 我们要先理解看待矩阵的另一个<strong>视角</strong>: 系统</p>
<br>

<p><img src="/Blog/intro/excel_matrix.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<p>之前的例子中, 我们把矩阵当作是表格来看, 但这只是看待矩阵最简单的一个视角</p>
<p>而我们可以使用不同的视角, 在不同的应用场景中, 把矩阵看待成不同的内容</p>
<p>最为典型地, 可以把矩阵看作是一个系统</p>
<br>

<h3 id="什么是系统"><a href="#什么是系统" class="headerlink" title="什么是系统"></a>什么是系统</h3><p><strong>经济系统</strong>: </p>
<p><img src="/Blog/intro/econ_system.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<p>在这个例子中, 由于IT对 电子, 矿产, 房产都有影响, 所以除了自身最基础的 100 之外, 还要按照比例投入另外一些资金来维持 电子, 矿产, 房产的发展</p>
<br>

<p><img src="/Blog/intro/functions.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<p>同理, 其余的三个产业也可以列出相应的方程式, 我们就得到了4个方程, 连立起来就形成了方程组, 我们的整个系统必须满足这些方程足所表达的条件, 我们便可以说这个方程组表达了这个系统</p>
<br>

<p><strong>网络中 (交通网络, 信息网络…)(图论)</strong></p>
<p><img src="/Blog/intro/net_system.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<p>左边的图 (交通网络) 可以用右边的方程组来表示</p>
<p>同样这个方程组描述了这个<strong>网络系统</strong></p>
<br>

<p><strong>电路系统</strong></p>
<p>在电路中, 每一个回路都满足一个基本方程</p>
<p><img src="/Blog/intro/electron_system.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<p>左边回路由第一个方程表示</p>
<p>右边回路由第二个方程表示</p>
<p>通过求解这个方程组, 可以找到最为合适的电阻的值</p>
<p>这个方程组描述了一个<strong>电路系统</strong></p>
<br>

<p><strong>化学方程式中</strong></p>
<p>为了配平化学方程式, 假设系数分别为 a, b, c, d, 就可以得到以下方程式</p>
<p><img src="/Blog/intro/chemistry_system.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<br>

<p>线性方程组在各个领域, 有着重要的作用</p>
<p>在线性代数的世界中, 我们将更加系统地研究线性方程组这个看起来非常简单的话题</p>
<br>

<p>这是因为在实际的应用中使用线性方程组不会像小学或者初中考试那样列出两三个方程进行联立求解, 真实的情况有可能在方程组中<strong>未知数</strong>的数量是巨大的, 同时方程的个数也是非常多的. 因此需要更加系统的手段来研究线性方程组的求解问题</p>
<p>在线性代数中, 称这样的线性方程组为<strong>线性系统</strong></p>
<br>

<h3 id="系统和矩阵的关系"><a href="#系统和矩阵的关系" class="headerlink" title="系统和矩阵的关系"></a>系统和矩阵的关系</h3><p>在金融系统的例子中的线性方程组 (线性系统), 每一个未知数的前面都有一个<strong>系数</strong>, 那么我就可以把这些系数综合起来看作是一个矩阵</p>
<p><img src="/Blog/intro/system_and_matrix.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<p>线性方程组的左侧使用矩阵来代替, 矩阵中的每一行都代表方程组中的一个方程, 而每一列都代表在不同的方程中每一个未知数前面的系数</p>
<br>

<p>而右侧部分则可以直接使用一个向量来表示, 很自然地我们使用<strong>列向量</strong>来和矩阵的每一行进行对齐</p>
<br>

<p>在线性代数的世界中, 我们就可以这样来表述一个线性系统, <strong>进而对这个系统的求解完全转换成对矩阵的运算</strong></p>
<br>

<p>这便是线性系统和矩阵的关系, 也是我们看待矩阵的另一个视角, 我们完全可以使用一个矩阵来<strong>表示</strong>一个线性系统</p>
<p>一旦我们把矩阵看作时这样的一个系统之后, 我们再来看矩阵的乘法会变得非常简单</p>
<br>

<br>

<h2 id="矩阵和向量的乘法与把矩阵看作向量的函数"><a href="#矩阵和向量的乘法与把矩阵看作向量的函数" class="headerlink" title="矩阵和向量的乘法与把矩阵看作向量的函数"></a>矩阵和向量的乘法与把矩阵看作向量的函数</h2><h3 id="矩阵和向量的乘法"><a href="#矩阵和向量的乘法" class="headerlink" title="矩阵和向量的乘法"></a>矩阵和向量的乘法</h3><p><img src="/Blog/intro/system_and_matrix2.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<p>有时候我们也称这样的矩阵为<strong>系数矩阵</strong>, 可以明显看到, 除了系数矩阵和等号右侧组成的列向量之外, 还缺少一部分.</p>
<p>缺少的就是我们要表达这个线性方程组中的每一个<strong>未知数</strong>, 这个方程组有4个未知数, 也就排成<strong>向量</strong>的形式</p>
<br>

<p>这样一来, 有一个系数矩阵, 一个表达未知数的列向量, 有一个表达等号右侧结果的列向量, 这个形式和我们普通的数字方程是非常一致的</p>
<p><img src="/Blog/intro/matrix_product_vector.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<p>这个式子就是 A * <strong>x</strong> &#x3D; <strong>b</strong>, 这种表示方法和初中所学习的: <strong>一个系数 乘以一个未知数 等于另外一个数字</strong>. 这种表示方法本质是一样的</p>
<br>

<p>而在上图中, 等式的左侧, 一个矩阵乘以一个向量的部分和我们之前的线性方程组是等价的, 而那个线性方程组就是4个方程</p>
<p><img src="/Blog/intro/matrix_product_vector3.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<p>上图就是描述矩阵和向量是如何相乘的</p>
<br>

<p><img src="/Blog/intro/matrix_product_vector4.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<p>左侧系数矩阵中的第一行元素, 和未知数向量中的每一个元素**相乘再相加 (行向量和列向量进行点乘)**得到的结果就是右侧向量中的第一个元素</p>
<br>

<p><img src="/Blog/intro/matrix_product_vector5.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<p>一个有若干行的矩阵乘以一个向量得到的结果也是一个向量</p>
<p>这个结果向量就是把矩阵中的每一行都拿出来和列向量进行<strong>点乘</strong>组成的向量</p>
<p>在数学中, 更加形式化的表达方式如下</p>
<p><img src="/Blog/intro/matrix_product_vector6.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<br>

<p>点乘是有条件的: <strong>点乘的两个向量的个数必须是一致的</strong></p>
<p>换句话说, 矩阵和向量进行乘法操作的前提条件是 : <strong>矩阵 A 的列数必须和向量 u 的元素个数一致</strong>, 但对于矩阵 A 的行数没有限制</p>
<br>

<p>而这种形式化的表示方法也可以再稍微改动一下</p>
<p><img src="/Blog/intro/matrix_product_vector7.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<p>每一个 r 都是一个 (行) 向量, 这个矩阵乘以向量u的结果</p>
<p><strong>注意:</strong> 这是以<strong>行视角</strong>看待矩阵, 因为我们把矩阵拆成了一行一行的样子,</p>
<p>以后还会讲述关于以<strong>列的视角</strong>看待矩阵的乘法吗这两种视角都非常重要</p>
<blockquote>
<p>个人思考: 如果把向量看作是标量, 矩阵看作向量的话简直和向量的数量乘法一样啊</p>
<p>bobo回复:  不过左右有区分哦。对于矩阵和向量的乘法，只能矩阵在左，向量在右；但是对于向量的数量乘法，标量 k 是没有左右分别的  </p>
<p>同时，矩阵和向量的乘法，还要保证矩阵的列数和向量的元素数相同；向量的数量乘法没有任何限制：） </p>
</blockquote>
<br>

<h4 id="再回头看向量的点乘"><a href="#再回头看向量的点乘" class="headerlink" title="再回头看向量的点乘"></a>再回头看向量的点乘</h4><p><img src="/Blog/intro/matrix_product_vector5.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<p>我们对矩阵的行数没有限制, 如果矩阵的行数为 1, 此时矩阵就变成了一个向量</p>
<p><img src="/Blog/intro/dot_product_and_matrix_product.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<p>唯一的行向量就和列向量进行点乘, 相应的结果中只有唯一的一个元素</p>
<p>由换了一个角度理解向量的点乘: <strong>只有一行的矩阵和向量进行点乘的结果</strong></p>
<br>

<h3 id="重点-把矩阵看作是向量的函数"><a href="#重点-把矩阵看作是向量的函数" class="headerlink" title="重点 ! 把矩阵看作是向量的函数"></a>重点 ! 把矩阵看作是向量的函数</h3><p><img src="/Blog/intro/matrix_product_vector5.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<p><img src="/Blog/intro/matrix_function.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<p>对于一个 m * n 的矩阵来说, 乘以一个有 n 个元素的向量, 最终的结果就是有m个元素的向量</p>
<p>如果把矩阵写作 T, 相乘的列向量写作 <strong>a</strong>, 得到的结果就是一个 <strong>b</strong> 向量, 我们可以换另外一个角度来理解这个乘法</p>
<br>

<p>这个过程相当是: 我们通过某种方式, <strong>把向量 a 转换成了向量 b</strong>, 或者是把<strong>向量 a 映射成为 向量 b</strong></p>
<p>这种 (转换 &#x2F; 映射) 的方法, 就是由 <strong>矩阵T</strong> 来定义的</p>
<p>通过这样一个视角来理解的话, 可以把 矩阵T 理解成是<strong>向量的函数</strong>(这个视角非常重要)</p>
<br>

<p>函数的概念就是将一个数转换成另外一个数, 例如: f(x) &#x3D; x ^ 2, 把 2 转换成4, 3 转换成 9…</p>
<blockquote>
<p>个人的感悟: 这一刻我真正地感觉到数学是一个工具, 你看待一个东西的角度决定了你使用它的方法, 重点是看待事物的角度, 而不是数学的推导 </p>
</blockquote>
<br>

<br>

<h2 id="矩阵和矩阵的乘法"><a href="#矩阵和矩阵的乘法" class="headerlink" title="矩阵和矩阵的乘法"></a>矩阵和矩阵的乘法</h2><p>在介绍矩阵数量乘法的时候我们使用了这样的一个例子</p>
<p><img src="/Blog/intro/matrix_num_product_example.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<p>相当于将原来的三角形向x轴和y轴扩大2倍</p>
<br>

<p>但如果问题更加复杂, 如果不是每个点的横纵坐标都扩大2倍, 而是横坐标扩大1.5倍, 纵坐标扩大2倍呢?</p>
<p>这是一个典型的, 需要把一个向量转换成另外一个向量的问题</p>
<p>相当于对于每个点坐标 (x, y), 通过一种<strong>转换</strong>, 把它转换成 (1.5x, 2y)</p>
<br>

<p><img src="/Blog/intro/matrix_product_matrix_1.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<p>矩阵可以看作是向量的函数的用途就体现出来了</p>
<p>相当于我们要找到一个函数, 传入 (x, y), 输出 (1.5x, 2y)</p>
<p>由于对于向量来说, 矩阵就是向量的函数, 相当于找到这样的 变化矩阵 T, 满足  T * (x, y) &#x3D; (1.5x, 2y)</p>
<br>

<p><strong>矩阵T的形状</strong>: 由于 矩阵T 要和 (x, y) 相乘, 所以 <strong>矩阵T的列数</strong>一定是2, 同时由于<strong>结果向量</strong>中有两个元素, 所以 <strong>矩阵T的行数</strong> 也必须为2</p>
<p>不妨把这4个元素设置为 a, b, c, d, 根据矩阵和向量乘法的定义, 得到的结果为 (ax+by, cx + dy), 同时我们直到结果为 (1.5x, 2y) , 很容易就能求得a, b, c, d的值</p>
<br>

<p>也就是说, 如果要满足我们的需求, 进行T这个矩阵的变换就可以了</p>
<p><img src="/Blog/intro/matrix_product_matrix_2.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<br>

<p>那么问题来了, 在这个图形中是有很多点的, 如果把每一个点都化作向量用矩阵和每一个点进行乘法操作的话固然可以, 不过是否有更简单更批量化的做法呢?</p>
<p>思路也非常简单, 只要把所有点 (向量) 合成为一个矩阵就可以了</p>
<br>

<p>矩阵应该长这样: </p>
<p><img src="/Blog/intro/matrix_for_point.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<p>因为之前一个矩阵对一个点进行变换的时候, <strong>乘以的是这个点所对应的列向量</strong></p>
<p><img src="/Blog/intro/matrix_product_matrix_2.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<p>这个列向量也可以理解为是 2 * 1 的矩阵, <strong>行数2</strong> 表示每个点坐标有2个维度 (x 和 y), <strong>列数1</strong>说明当前只处理一个点坐标</p>
<p>相应的如果处理三个点坐标只需要做一个 2 * 3 的矩阵就好了, 每一列相当于一个点坐标</p>
<p><img src="/Blog/intro/matrix_product_matrix_3.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<br>

<p>由此我们可以直接让 <strong>矩阵T</strong> 直接和 <strong>矩阵P</strong> 相乘来批量地把 矩阵P 的点坐标转换成另外的一组点坐标, 显然最后得到的结果也是一个矩阵, </p>
<p>这个结果是 <strong>矩阵T</strong> 将 **矩阵P **中的所有的坐标全都转换成新的坐标, 这些新的坐标所组成的矩阵</p>
<br>

<p>这个转换方式是一样的, 每次都用矩阵T乘以矩阵P中的一列</p>
<p><img src="/Blog/intro/matrix_product_matrix_4.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<br>

<p>这里就定义出了两个矩阵进行乘法运算的法则</p>
<p>我们是基于矩阵和向量的乘法定义, 定义出矩阵和矩阵的乘法定义</p>
<p><img src="/Blog/intro/def_matrix_product.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<p>由于每次都是矩阵和列向量相乘</p>
<p>所以 矩阵A ( 前一个矩阵 ) 的<strong>列数</strong>必须和 矩阵B ( 后一个矩阵 ) 的<strong>行数</strong>一致</p>
<br>

<p>更加形式化的表达 : </p>
<p><img src="/Blog/intro/def_matrix_product_2.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<br>

<p>回忆一下, 矩阵和向量的乘法是矩阵中每一个行向量和列向量点乘, 也就是说要把矩阵拆成一行一行</p>
<p>因此更近一步, 就可以把结果矩阵中的每一个元素表示出来</p>
<p><img src="/Blog/intro/def_matrix_product_3.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<p>结果矩阵中 i 行 j 列的元素就是 A的 第 i 行 和 B的第 j 列进行点乘的结果</p>
<br>

<p>这样来看的时候, 在回头看两个矩阵进行相乘的条件: <strong>矩阵A的列数必须和矩阵B的行数一致</strong></p>
<p>而结果矩阵中, 每一个元素都是 <strong>矩阵A的一行</strong> 和 <strong>矩阵B的一列</strong> 进行<strong>点乘</strong>的结果, 点乘若想成立, 每一个 r 和每一个 c 的元素个数必须一样</p>
<p>翻译过来, 每一个 r 的元素个数就是矩阵A的列数, 每一个 c 的元素个数就是矩阵B的行数</p>
<br>

<p>因此, 如果A是 m * k 的矩阵, B是 k * n 的矩阵, 则结果矩阵为 m * n 的矩阵</p>
<p>A矩阵列数为 k , B矩阵行数为 k, 而结果矩阵中却不包含k了, 因为 r c的元素个数都为k, 点乘后是一个数, k就没有了</p>
<br>

<p>而且由此也可以看出, <strong>矩阵的乘法是不遵守交换率</strong>的</p>
<p>A * B !&#x3D; B * A</p>
<p>甚至很有可能根本不能相乘</p>
<br>

<br>

<h2 id="矩阵乘法的性质和矩阵的幂"><a href="#矩阵乘法的性质和矩阵的幂" class="headerlink" title="矩阵乘法的性质和矩阵的幂"></a>矩阵乘法的性质和矩阵的幂</h2><h3 id="矩阵乘法的性质"><a href="#矩阵乘法的性质" class="headerlink" title="矩阵乘法的性质"></a>矩阵乘法的性质</h3><p>虽然矩阵乘法不遵守交换律, 但矩阵乘法依然遵守一些其他的性质</p>
<p><img src="/Blog/intro/matrix_product_property.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<p>注意由于矩阵乘法<strong>不遵守交换律</strong>, 所以第二条和第三条是两个不同的性质</p>
<p>注意第四条和第五条中的等式左右的<strong>零矩阵的形状</strong>是不同的</p>
<br>

<h4 id="如何证明-A-B-C-x3D-A-B-C"><a href="#如何证明-A-B-C-x3D-A-B-C" class="headerlink" title="如何证明: (A * B) * C &#x3D; A * (B * C)"></a>如何证明: (A * B) * C &#x3D; A * (B * C)</h4><p>假设A, B, C是任意可相乘的矩阵, </p>
<p><img src="/Blog/intro/proof_matrix_property.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<p>A的形状是 m * k, B的形状是 k * n, C的形状是 n * l</p>
<p>A的列数等于B的行数, B的列数等于C的行数</p>
<p>之后只要分别就出来等式左边和等式右边的结果就可以证明</p>
<p>但由于不好打字, 这里不做证明了, 只提供思路</p>
<br>

<h3 id="矩阵的幂"><a href="#矩阵的幂" class="headerlink" title="矩阵的幂"></a>矩阵的幂</h3><p>在算数中, a 的 k 次方就是 k 个 a 相乘</p>
<p>对于矩阵是同理的, 然而由于矩阵的乘法是有限制的: <strong>前一个矩阵的列数必须要等于后一个矩阵的行数</strong></p>
<p><img src="/Blog/intro/a_to_pow_k.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<p>而在矩阵的幂运算中, 前一个矩阵和后一个矩阵都是一样的矩阵, 则这一个矩阵的<strong>行数和列树必须相等</strong>, 即: 只有<strong>方阵</strong>才可以进行矩阵的幂运算</p>
<br>

<p>如果 k &gt;&#x3D; 1 一切好说, 但如果 k &#x3D; 0 或者 k 为负数怎么办?</p>
<p><img src="/Blog/intro/matrix_pow_zero_ne.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<p>下一章见分晓 : ) </p>
<blockquote>
<p>A的0次方等于 I</p>
<p>A的-1次方等于 A 的逆矩阵</p>
<p>A的-2次方等于 (A的-1次方) 的平方</p>
</blockquote>
<br>

<h3 id="陷阱"><a href="#陷阱" class="headerlink" title="陷阱"></a>陷阱</h3><p>一定要时刻注意: <strong>矩阵的乘法是不遵守交换律的!</strong></p>
<p><img src="/Blog/intro/matrix_product_trap.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<br>

<br>

<h2 id="矩阵的转置"><a href="#矩阵的转置" class="headerlink" title="矩阵的转置"></a>矩阵的转置</h2><p>人们习惯以行的形式读取, T 是 transpose 的意思</p>
<p><img src="/Blog/intro/matrix_transaction.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<p>简而言之, 矩阵的转置: 行变成列, 列变成行</p>
<p><img src="/Blog/intro/matrix_ele_transpose.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<br>

<p>之前介绍向量时也说过, 通常在线性代数中, 说起向量一般是列向量</p>
<p>但由于横版印刷的原因, 使用T对行向量进行转置</p>
<p>例如: 行向量 (3, 4), 会印刷为 (3, 4)<em>T</em></p>
<br>

<h3 id="矩阵转置的性质"><a href="#矩阵转置的性质" class="headerlink" title="矩阵转置的性质"></a>矩阵转置的性质</h3><p><img src="/Blog/intro/property_transpose_matrix.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<br>

<p>最后一条性质看起来稍微有些不同, 依然可以假设A和B的矩阵, 之后进行严谨地证明</p>
<p>但在这里, 提供一个视角, 虽然没有严格地证明, 但却可以帮助理解这个性质:</p>
<br>

<p>关注A和B两个矩阵的<strong>形状</strong></p>
<p>假设A是 m * k 的矩阵, B是 k * n 的矩阵 </p>
<p>AB 是 m * n 形状的矩阵, AB的转置是 n * m 的矩阵</p>
<p>那么A的转置是 k * m 的矩阵, B的转置是 n * k 的矩阵</p>
<p>(B的转置)(A的转置) 是 n*m的矩阵</p>
<p>它们的形状是相同的</p>
<blockquote>
<p>很多时候, 面对矩阵的运算, 要关注一下矩阵的形状, 这对我们理解这个式子为什么成立可能是非常有帮助的</p>
</blockquote>
<br>

<br>

<h2 id="更多变换矩阵"><a href="#更多变换矩阵" class="headerlink" title="更多变换矩阵"></a>更多变换矩阵</h2><h3 id="缩放变换"><a href="#缩放变换" class="headerlink" title="缩放变换"></a>缩放变换</h3><p>前文已经举过一个例子</p>
<p><img src="/Blog/intro/example_matrix_transform.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<p>更加通用地, 如果让每一个点的横坐标扩大 a 倍, 纵坐标扩大 b 倍</p>
<p><img src="/Blog/intro/transform_a_b.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<br>

<p>对于变换矩阵的学习, 通常应用在图形学, 这里只提及一些简单的变换矩阵</p>
<p><strong>目标:</strong> </p>
<ol>
<li><p>深刻地理解<strong>矩阵是怎样表示变换的 ( 理解矩阵是向量的函数 )</strong></p>
</li>
<li><p>熟悉矩阵的乘法, 后续很多内容的学习都需要建立在深刻地理解矩阵的乘法的基础上</p>
</li>
</ol>
<br>

<h3 id="进行翻转变化"><a href="#进行翻转变化" class="headerlink" title="进行翻转变化"></a>进行翻转变化</h3><br>

<h4 id="例如-让每个点关于x轴旋转"><a href="#例如-让每个点关于x轴旋转" class="headerlink" title="例如: 让每个点关于x轴旋转"></a>例如: 让每个点关于x轴旋转</h4><p><img src="/Blog/intro/flip_graph_by_matrix.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<p>很显然, 对于每个点来说, x不变, 但y取反</p>
<p>我们要找到矩阵 T, 使得</p>
<p><img src="/Blog/intro/find_matrix_filping.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<br>

<p>由于矩阵T<strong>乘以的向量</strong>行数为2, 所以 T 要有2列,</p>
<p>由于<strong>结果向量</strong>的行数为2, 所以 T 要有2行</p>
<p>所以T应该是 2 * 2 的方阵</p>
<br>

<p>很自然地, 假设 矩阵T 是这样的 </p>
<p><img src="/Blog/intro/abcd_T_matrix.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<p>于是, </p>
<p><img src="/Blog/intro/product_abcd_T_vector.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<p>因此求得: a &#x3D; 1, b &#x3D; 0, c &#x3D; 0, d &#x3D; -1</p>
<p><img src="/Blog/intro/flip_solution_T.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<br>

<h4 id="例如-让每个点关于y轴翻转"><a href="#例如-让每个点关于y轴翻转" class="headerlink" title="例如: 让每个点关于y轴翻转"></a>例如: 让每个点关于y轴翻转</h4><p>所有点, y 不变, x 变为 -x</p>
<p><img src="/Blog/intro/flip_about_y.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<br>

<h4 id="例如-让每个点关于原点翻转-x轴-y轴均翻转"><a href="#例如-让每个点关于原点翻转-x轴-y轴均翻转" class="headerlink" title="例如: 让每个点关于原点翻转(x轴, y轴均翻转)"></a>例如: 让每个点关于原点翻转(x轴, y轴均翻转)</h4><p><img src="/Blog/intro/flip_about_O.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<br>

<p>另一种思考方法: 之前已经求过关于x轴翻转和关于y轴翻转.</p>
<p>我们可以先进行 x 轴翻转, 再进行 y 轴翻转</p>
<p><img src="/Blog/intro/tx_ty_flip_about_O.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<p>通过矩阵乘法的结合率, 让两个变换矩阵先相乘</p>
<p>这里没有假设变换矩阵是 abcd, 而是直接使用已知的矩阵性质进行推导</p>
<br>

<h3 id="错切"><a href="#错切" class="headerlink" title="错切"></a>错切</h3><h4 id="沿x方向错切"><a href="#沿x方向错切" class="headerlink" title="沿x方向错切"></a>沿x方向错切</h4><p><img src="/Blog/intro/shear_example.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<p>可以看到, y没有变化, 但x进行了一些偏移, 通常偏移量和y坐标成一定的比例</p>
<p><img src="/Blog/intro/shear_example_solution.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<p><img src="/Blog/intro/shear_example_solution2.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<br>

<h4 id="沿y方向错切"><a href="#沿y方向错切" class="headerlink" title="沿y方向错切"></a>沿y方向错切</h4><p>x没有变化, y根据x成比例偏移</p>
<p><img src="/Blog/intro/shear_example_y.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<br>

<br>

<h2 id="矩阵旋转变换和矩阵在图形学中的应用"><a href="#矩阵旋转变换和矩阵在图形学中的应用" class="headerlink" title="矩阵旋转变换和矩阵在图形学中的应用"></a>矩阵旋转变换和矩阵在图形学中的应用</h2><p><img src="/Blog/intro/routing_matrix.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<br>

<p>同之前不同, 这次我们想求的是旋转后点的坐标</p>
<p><img src="/Blog/intro/routing_matrix_0.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<p>有了旋转后的坐标才能求出 矩阵 T</p>
<br>

<p>先假设只对一个点进行旋转</p>
<p><img src="/Blog/intro/routing_matrix_1.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<br>

<p>假设(x, y) 和 x轴的夹角为 α, (x,y)距离原点 O 的距离(<strong>(x, y)的模</strong>)为 d</p>
<p><img src="/Blog/intro/find_matrix_after_routing.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<p>于是我们可以求出</p>
<p><img src="/Blog/intro/find_matrix_after_routing_1.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<br>

<p>而(x’, y’) 和 (x, y) 的关系除了旋转θ, 还有一个重要的点, (x’, y’) 的模也是 d 等于(x, y)的模, 因为进行的是旋转操作, 所以旋转前后距离原点的位置是不变的</p>
<p>因此, 同样可以用x’ 和 y’ 表达出 d</p>
<p><img src="/Blog/intro/find_matrix_after_routing_2.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<br>

<p>由于上面这4个式子都代表d, 于是, 我们便可以把它们连起来, 换句话说, 现在可以通过x来表示x’, y来表示y’</p>
<p><img src="/Blog/intro/find_matrix_after_routing_3.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<br>

<p>下面就是基于这两个等式, 化简求出x’, y’</p>
<p>根据两角差的余弦公式</p>
<p><img src="/Blog/intro/find_matrix_after_routing_4.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<p>而 tanα &#x3D; sinα &#x2F; cosα &#x3D; 对边 &#x2F; 邻边 &#x3D; y &#x2F; x, 而tanα * x &#x3D; y</p>
<p>所以最后可以写成</p>
<p><img src="/Blog/intro/find_matrix_after_routing_5.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<br>

<p>同理, 也可以求出 y’ </p>
<p>根据两角差的正弦公式</p>
<p><img src="/Blog/intro/find_matrix_after_routing_6.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<br>

<p>由此: </p>
<p><img src="/Blog/intro/find_matrix_after_routing_7.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<p>所以可以求出矩阵T为</p>
<p><img src="/Blog/intro/find_matrix_after_routing_8.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<br>

<p>验证: </p>
<p><img src="/Blog/intro/find_matrix_after_routing_9.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<blockquote>
<p>在图形学中, 我们会经常处理一个问题: 动画, 所谓的动画就是把所有点不停地进行这样的变换</p>
<p>可以尝试用js实现一个动画</p>
<p>可以思考以下拓展思路</p>
<ol>
<li>三维坐标中的应用?</li>
<li>平移操作? 仿射变换</li>
<li>图形学</li>
</ol>
</blockquote>
<br>

<br>

<h2 id="从缩放变换到单位矩阵"><a href="#从缩放变换到单位矩阵" class="headerlink" title="从缩放变换到单位矩阵"></a>从缩放变换到单位矩阵</h2><p>前面说过</p>
<p><img src="/Blog/intro/uni_matrix.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<p>但如果让每个点保持原位, 即让每个点的横坐标扩大1倍, 纵坐标扩大1倍</p>
<p>a 和 b 都取1, 此时矩阵 T 和 任何坐标相乘得到的都是<strong>自身</strong></p>
<p><img src="/Blog/intro/uni_matrix_1.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<p>换句话说, 变换矩阵没有对点坐标所表示的列向量<strong>产生任何变换</strong></p>
<p>这样的矩阵我们称之为<strong>单位矩阵</strong>, 一般记作 <em>I</em>, 就是 identity 的意思</p>
<br>

<p>同样, 单位矩阵也是有形状的, 通过下标来标记矩阵的形状</p>
<p><img src="/Blog/intro/uni_matrix_2.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<p><img src="/Blog/intro/uni_matrix_3.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<br>

<p>可以观察到, 单位矩阵的<strong>主对角线(左上至右下)</strong>, 都为1, 更为形式化地定义:</p>
<p><img src="/Blog/intro/def_uni_matrix.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<p>单位矩阵一定是方阵, 因为矩阵要和行数为n的矩阵(向量)相乘, 单位矩阵的列数必须为n, 得到的结果是原矩阵, 也有n行的, 所以单位矩阵的行数也必须为n, 因此单位矩阵必须是方阵.</p>
<p><strong>很多特殊矩阵都是方阵</strong></p>
<p><img src="/Blog/intro/property_uni_matrix_1.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<p>由于 ri 中只有第i个元素是1, 其余的都是0, 所以点乘后的结果就相当于从cj中取出第i个元素, </p>
<p>同理反过来也可以</p>
<p><img src="/Blog/intro/property_uni_matrix_2.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<p>但是, 进行乘法的顺序不同, 单位矩阵的<strong>形状</strong>也不同, 这一点和零矩阵是类似的, 例如:</p>
<p><img src="/Blog/intro/property_uni_matrix_3.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<br>

<br>

<h2 id="矩阵的逆"><a href="#矩阵的逆" class="headerlink" title="矩阵的逆"></a>矩阵的逆</h2><p>单位矩阵就相当与数字系统中的1, 一旦有了数字系统中的1, 相应地我们就可以引入矩阵的逆的概念了</p>
<p><img src="/Blog/intro/inverse_x_number_sys.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<p>除 0 之外.</p>
<br>

<p>同理, 在矩阵中, 由于”1” 就是单位矩阵, 那我们就可以这样定义</p>
<p><img src="/Blog/intro/inverse_matrix.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<p>注意在矩阵运算中, 不是简单的 A<em>B &#x3D; I, 因为矩阵的乘法*<em>不满足交换律</em></em></p>
<br>

<p>同理, 在数字系统中, 不是所有的数都有逆(倒数), 在数字系统中只有0没有逆(倒数)</p>
<p>而在矩阵系统中, 有<strong>无数的矩阵</strong>, 不存在逆</p>
<br>

<p>所以, 如果对于矩阵A 我们能找到它的逆的话, A便被称为<strong>可逆矩阵</strong>, 或者叫<strong>非奇异</strong>矩阵 (non-singular matrix)</p>
<p>大部分矩阵都是可逆矩阵, 不存在逆矩阵的矩阵还是更加少的</p>
<p>所以称它们为: <strong>不可逆矩阵</strong>, 或者<strong>奇异</strong>矩阵(singular matrix)</p>
<br>

<p>举个例子</p>
<p><img src="/Blog/intro/example_non_singular_matrix.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<p>如何判断一个矩阵是否可逆, 如果可逆如何算出逆矩阵..? 以后见分晓: )</p>
<br>

<p>既然矩阵乘法不满足交换律, 那么一定存在以下情况</p>
<p><img src="/Blog/intro/lr_singular_matrix.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<p>但我们在线性代数的学习中, 更重视逆矩阵, 这里引入左逆矩阵和右逆矩阵是为了得出逆矩阵一个非常重要的概念:</p>
<p><strong>如果一个矩阵A既存在左逆矩阵B, 又存在右逆矩阵C, 则B&#x3D;C</strong></p>
<br>

<h3 id="证明-如果一个矩阵A既存在左逆矩阵B-又存在右逆矩阵C-则B-x3D-C"><a href="#证明-如果一个矩阵A既存在左逆矩阵B-又存在右逆矩阵C-则B-x3D-C" class="headerlink" title="证明: 如果一个矩阵A既存在左逆矩阵B, 又存在右逆矩阵C, 则B&#x3D;C"></a>证明: 如果一个矩阵A既存在左逆矩阵B, 又存在右逆矩阵C, 则B&#x3D;C</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">已知: BA = I, AC = I</span><br><span class="line">证明: </span><br><span class="line">	AC = I</span><br><span class="line">	B(AC) = BI		使用结合律</span><br><span class="line">	(BA)C = B		</span><br><span class="line">	IC = B</span><br><span class="line">	C = B</span><br></pre></td></tr></table></figure>

<br>

<p>在回头看矩阵的逆的定义</p>
<p><img src="/Blog/intro/inverse_matrix.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<p>B 既是矩阵的左逆又是矩阵的右逆, 既然B 既能和A矩阵左乘(矩阵B的列数等于A的行数), 又能和A矩阵右乘(矩阵B的行数要等于A的列数), 综合起来, 矩阵A一定是一个方阵</p>
<blockquote>
<p> 这里的A * B和B * A要求是同阶的单位矩阵。否则A * B&#x3D;I(n)，B * A&#x3D;I(m)，其实A * B和B * A不相等 </p>
</blockquote>
<p><strong>可逆矩阵一定是方阵</strong>, 非方阵一定不可逆</p>
<br>

<p>之前在矩阵的幂中提出过问题, 矩阵的0次方是什么, -1次方是什么, 这里就可以给出答案了</p>
<blockquote>
<p>A的0次方等于 I</p>
<p>A的-1次方等于 A 的逆矩阵</p>
<p>A的-2次方等于 (A的-1次方) 的平方</p>
</blockquote>
<br>

<h2 id="矩阵的逆的性质"><a href="#矩阵的逆的性质" class="headerlink" title="矩阵的逆的性质"></a>矩阵的逆的性质</h2><p><img src="/Blog/intro/inverse_matrix.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<br>

<h3 id="对于矩阵A-如果存在逆矩阵B-则B唯一"><a href="#对于矩阵A-如果存在逆矩阵B-则B唯一" class="headerlink" title="对于矩阵A, 如果存在逆矩阵B, 则B唯一"></a>对于矩阵A, 如果存在逆矩阵B, 则B唯一</h3><p>证明: 反证法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">假设矩阵A存在两个不同的逆矩阵B和C</span><br><span class="line">	AB = AC = I</span><br><span class="line">	B(AB) = B(AC)</span><br><span class="line">	(BA)B = (BA)C</span><br><span class="line">	IB = IC</span><br><span class="line">	B = C</span><br><span class="line">矛盾, 所以假设错误</span><br><span class="line">所以对于非奇异矩阵A, 只有一个逆矩阵</span><br></pre></td></tr></table></figure>

<br>

<h3 id="A的逆矩阵的逆矩阵还是A"><a href="#A的逆矩阵的逆矩阵还是A" class="headerlink" title="A的逆矩阵的逆矩阵还是A"></a>A的逆矩阵的逆矩阵还是A</h3><p><img src="/Blog/intro/property_inv_A.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<br>

<h3 id="A-B-的逆等于-B-的逆乘以-A-的逆"><a href="#A-B-的逆等于-B-的逆乘以-A-的逆" class="headerlink" title="(A * B) 的逆等于 B 的逆乘以 A 的逆"></a>(A * B) 的逆等于 B 的逆乘以 A 的逆</h3><p><img src="/Blog/intro/property_inv_A_B.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<p><img src="/Blog/intro/property_inv_A_B_2.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<br>

<p>回忆一下, 学习矩阵的转置时得到过一个类似的性质</p>
<p><img src="/Blog/intro/property_inv_A_B_3.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<p>矩阵的逆和矩阵的转置之间, 在特殊情况下确实有着非常特殊的关系</p>
<blockquote>
<p>对于某一类特殊的矩阵, 它的转置就等于它的逆</p>
</blockquote>
<br>

<h3 id="A的转置的逆矩阵等于A的逆矩阵的转置"><a href="#A的转置的逆矩阵等于A的逆矩阵的转置" class="headerlink" title="A的转置的逆矩阵等于A的逆矩阵的转置"></a>A的转置的逆矩阵等于A的逆矩阵的转置</h3><p><img src="/Blog/intro/property_inv_A_B_4.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<p><img src="/Blog/intro/property_inv_A_B_5.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<p>单位矩阵的转置是自身</p>
<blockquote>
<p>这一节主要的证明思路就是根据矩阵的逆的定义进行推导</p>
</blockquote>
<br>

<h2 id="看待矩阵的关键视角-用矩阵表示空间"><a href="#看待矩阵的关键视角-用矩阵表示空间" class="headerlink" title="看待矩阵的关键视角: 用矩阵表示空间"></a>看待矩阵的关键视角: 用矩阵表示空间</h2><h3 id="通过列视角看待矩阵乘法"><a href="#通过列视角看待矩阵乘法" class="headerlink" title="通过列视角看待矩阵乘法"></a>通过列视角看待矩阵乘法</h3><p>把矩阵看作<strong>空间</strong>是线性代数的核心之一</p>
<p>回忆 : 矩阵和向量的乘法</p>
<p><img src="/Blog/intro/matrix_product_with_vector.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<p>当初我们是以<strong>行视角</strong>来看待的</p>
<br>

<p>我们还可以用<strong>列视角</strong>来看待矩阵乘法</p>
<p><img src="/Blog/intro/matrix_product_with_vector_c.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<p>即把矩阵拆成一列一列地, 和向量中对应的元素进行相乘, 最终结果再加起来</p>
<p><img src="/Blog/intro/understand_matrix_product_vector_col.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<p>由于矩阵的列数要和向量的行数相等, 所以这里向量也被分为4块元素</p>
<p>向量中的元素和矩阵中对应的一列进行数量乘法, 在相加</p>
<br>

<p>使用列的视角看待矩阵乘法是非常<strong>有意义</strong>的</p>
<p><img src="/Blog/intro/example_col_product.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<p>仔细地看一些列的表达的方式: </p>
<p><img src="/Blog/intro/show_col_product.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<p><strong>回忆: 标准单位向量</strong></p>
<p>单位向量 : 模为1的相邻</p>
<p>标准单位向量 : 只由 0 和 1 组成的单位向量</p>
<p><img src="/Blog/intro/example_standard_unit_vector_2d.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<p><strong>标准单位向量就是在当前所讨论的坐标系中指向相应坐标轴的正方向的向量</strong></p>
<br>

<p><img src="/Blog/intro/show_col_product.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<p>这个式子就相当于</p>
<p><img src="/Blog/intro/relationship_suv_dot.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<br>

<p><img src="/Blog/intro/fomular_product.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<p>这就意味着在e1所对应的轴上伸缩x倍,</p>
<p>在e2所对应的轴上伸缩y倍</p>
<p><img src="/Blog/intro/graph_col_pov_matrix_product.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<p>之后对这两个向量求加法: </p>
<p><img src="/Blog/intro/graph_col_pov_matrix_product_2.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<p>向量加法的定义: 以这两个向量为边得到的平行四边形的对角线</p>
<p>这个结果同样可以推导到n维空间</p>
<br>

<h3 id="矩阵表示空间"><a href="#矩阵表示空间" class="headerlink" title="矩阵表示空间"></a>矩阵表示空间</h3><p><img src="/Blog/intro/graph_col_pov_matrix_product_3.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<p>第一列代表一个轴就是e1, 第二列代表另外一个轴e2 </p>
<p>通过列视角看待: 第一个轴和第一个元素相乘 + 第二个轴和第二个元素相乘, 最终得到的坐标</p>
<p>整个空间就是由这两个轴来定义, <strong>矩阵定义了两个坐标轴</strong>, 就相当于矩阵表示出了整个空间</p>
<br>

<p>再去扩展, 对于任意矩阵</p>
<p><img src="/Blog/intro/matrix_pov_space.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<p>这个矩阵是否代表了由<strong>向量u和向量v所组成的空间</strong>呢? 是的</p>
<p><img src="/Blog/intro/matrix_grid.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<p>向量u (4, 1) 就相当于x轴, 向量v(2, 3)就相当于y轴</p>
<br>

<p><img src="/Blog/intro/matrix_grid_1.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<p>问在这个空间上(2, 2)的点, 首先先向u方向走2步, 再向v方向走2步</p>
<p>就相当于(2, 2)坐标点在u, v两个坐标轴上的所对应的分量</p>
<p><img src="/Blog/intro/matrix_grid_2.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<br>

<p>我们就可以理解成, 这个矩阵定义了一个空间, 这个空间由两个坐标轴组成, 这<strong>两个坐标轴分别是两个列向量</strong>的结果</p>
<p>这个新的空间乘以某一个点(假设是(2, 2))最终得到的结果就是: <strong>从新的空间的角度来看这个点</strong>(2, 2)的位置</p>
<br>

<p>更加<strong>直观</strong>的看到什么是新的空间: </p>
<p>由上面u, v两个轴组成的空间的样子</p>
<p><img src="/Blog/intro/matrix_grid_3.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<p>由虚线所表示的空间就是u, v组成的新的空间</p>
<br>

<p>下面把标准的二维坐标系去掉, 我们得到的就是这样一个空间</p>
<p><img src="/Blog/intro/matrix_grid_4.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<p>这个矩阵乘以(2, 2), 就是这个新的空间中所对应的(2, 2)这个点</p>
<p><img src="/Blog/intro/matrix_grid_5.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<p>再回到标准空间中</p>
<p><img src="/Blog/intro/matrix_grid_6.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<p>这就是这个矩阵乘以(2, 2) 所得到的结果</p>
<br>

<h3 id="回头再看图形变换"><a href="#回头再看图形变换" class="headerlink" title="回头再看图形变换"></a>回头再看图形变换</h3><p>之前用一个矩阵乘以一个向量, 这个矩阵是这个向量的<strong>函数</strong></p>
<p>其实我们也可以把这个矩阵看作是<strong>新的空间</strong></p>
<br>

<p>比如: 让图形沿着y轴进行翻转</p>
<p><img src="/Blog/intro/matrix_filp_npov.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<p>我们可以把 T看作是对空间的描述, 这个空间是由(-1, 0)这个轴和(0, 1)这个轴所定义的空间</p>
<p>所谓地反转图像就是将原来的图像放到新的空间中</p>
<p><img src="/Blog/intro/matrix_filp_npov_1.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<br>

<p>同理对于错切变化, 新的空间的样子如下</p>
<p><img src="/Blog/intro/matrix_filp_npov_2.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<br>

<p>当有了这个视角之后, 有时我们就不需要过多的计算, 就可以直接推导出我们想要的变换矩阵</p>
<p>例如我们向将图形F放倒</p>
<p><img src="/Blog/intro/F_rout.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<p>就相当于将原先的F放入下面这样的坐标系中</p>
<p><img src="/Blog/intro/F_grid_sys.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<p>既然我们直到空间是这个样子, 我们就可以用矩阵表示空间直接写出矩阵来</p>
<p><img src="/Blog/intro/F_grid_sys_2.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<p>x轴是(0, 1), y轴是(-1, 0)</p>
<br>

<p>而且其实这个变换本身是一次旋转变换(顺时针选择3&#x2F;2 pi, 或逆时针旋转1&#x2F;2 pi)</p>
<p>如果我们把这个值代入旋转矩阵中, 得到的是同样的矩阵</p>
<p><img src="/Blog/intro/F_grid_sys_3.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<br>

<p>当然这种用矩阵表示空间的思路不仅可以用于二维空间, 3 * 3 的矩阵我们照样可以把它的每一列看作是三维空间中的一个轴</p>
<p>n维空间就应该由n个轴来定义, 而每个轴也应该是一个n维向量 (参考标准单位向量). 即: <strong>如果用矩阵表示空间, 则必须是n * n的方阵</strong></p>
<p><img src="/Blog/intro/F_grid_sys_4.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<p>这一小节中, 矩阵表示空间是很粗糙的, 主要是先理解它的概念, 以后会更加深入学习</p>
<blockquote>
<p>是不是可以说，这个矩阵就是所谓的映射，另一个空间的映射到我们横平竖直的坐标轴的样子? </p>
<p>可以：）把矩阵看作是空间的看法和函数的看法（映射就是函数）存在一定的联系，尤其是当我们使用矩阵做乘法的时候。毕竟，乘法本身是一个动作：）我们在这个课程的后续，还会仔细探讨这两个视角之间的关系：）</p>
</blockquote>
<br>

<h2 id="总结-看待矩阵的四个重要视角"><a href="#总结-看待矩阵的四个重要视角" class="headerlink" title="总结: 看待矩阵的四个重要视角"></a>总结: 看待矩阵的四个重要视角</h2><h3 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h3><p>矩阵的运算:</p>
<ul>
<li>矩阵的加法</li>
<li><strong>矩阵的乘法</strong> (和数字; 和<strong>向量</strong>; 和矩阵) (最为重点, 必须熟练掌握)</li>
<li>矩阵的幂</li>
<li>矩阵的转置</li>
<li>矩阵的逆 (没有介绍怎么求, 但介绍了相关的性质)</li>
</ul>
<br>

<p>更为重要的, 对怎么<strong>看待</strong>矩阵有更加深刻的认识</p>
<p><strong>矩阵到底能够表示什么?</strong> 这个问题将一直贯穿我们的线性代数的学习中</p>
<blockquote>
<p>代数, 就是用字母代表数, 我们到底能代表哪些数, 在更高级的学习中, 可能不仅仅代表数, 而是代表一个对象, 那么我们代表的对象到底是什么? 必须要明确这个问题的答案</p>
</blockquote>
<br>

<h3 id="看待矩阵的视角-1-数据"><a href="#看待矩阵的视角-1-数据" class="headerlink" title="看待矩阵的视角 (1) : 数据"></a>看待矩阵的视角 (1) : 数据</h3><p>数据科学经常使用的视角, 并非线性代数所讨论的重要的视角</p>
<p>每一行代表一个<strong>样本</strong>, 每一列代表一个<strong>特征</strong></p>
<p><img src="/Blog/intro/excel_matrix.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<br>

<h3 id="看待矩阵的视角-2-系统"><a href="#看待矩阵的视角-2-系统" class="headerlink" title="看待矩阵的视角 (2) : 系统"></a>看待矩阵的视角 (2) : 系统</h3><p>在线性代数中, 特指<strong>线性系统</strong>, 即线性方程组</p>
<p><img src="/Blog/intro/system_and_matrix2.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<p>更进一步, 在下一章中, 我们甚至不关心未知数的向量, 因为线性方程组有4列就一定有4个未知数</p>
<p>将结果向量和叙述矩阵合起来形成这样的一个矩阵, 我们可以直接用这个矩阵代表整个线性系统</p>
<p><img src="/Blog/intro/system_and_matrix_3.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<p>这样, 我们就有一系列方法, <strong>直接运用矩阵运算求解出我们的线性系统</strong></p>
<br>

<h3 id="看待矩阵的视角-3-变换-向量的函数"><a href="#看待矩阵的视角-3-变换-向量的函数" class="headerlink" title="看待矩阵的视角 (3) : 变换 (向量的函数)"></a>看待矩阵的视角 (3) : 变换 (向量的函数)</h3><p><img src="/Blog/intro/func_vector.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<p>矩阵和向量相乘得到新的向量, 因此可以把矩阵看作时一个函数, 输入一个向量, 输出一个向量</p>
<p>经常用于图形变换中 (图形学)</p>
<p><img src="/Blog/intro/transform_vec.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<blockquote>
<p>图形学中, 最为重要的是仿射变换, 图形的任意变换全部都归结到对一个矩阵中参数的求解</p>
<p>这里只是举例, 能更加直观地看到这个式子究竟能够做哪些事情</p>
</blockquote>
<br>

<h3 id="看待矩阵的视角-4-空间"><a href="#看待矩阵的视角-4-空间" class="headerlink" title="看待矩阵的视角 (4) : 空间"></a>看待矩阵的视角 (4) : 空间</h3><p>可以和第三个视角联系起来</p>
<p><img src="/Blog/intro/matrix_grid_1.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<p> <img src="/Blog/intro/matrix_grid_6.PNG" srcset="/Blog/img/loading.gif" lazyload></p>
<p>看向量在矩阵所表示的空间中所对应的位置</p>
<p>“空间”这个词甚至可以认为是线性代数这个领域所研究的核心词汇</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/Blog/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/Blog/tags/%E6%95%B0%E5%AD%A6/">数学</a>
                    
                      <a class="hover-with-bg" href="/Blog/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/">线性代数</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/Blog/2019/12/19/stat-for-programmer/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile"><专为程序员设计的统计课>学习笔记(1)</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/Blog/2019/11/28/learn-assembly-language/">
                        <span class="hidden-mobile">汇编语言学习</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;TOC</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/Blog/js/events.js" ></script>
<script  src="/Blog/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/Blog/js/local-search.js" ></script>



  
    <script  src="/Blog/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
        typing(title);
      
    })(window, document);
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/Blog/js/boot.js" ></script>


</body>
</html>
